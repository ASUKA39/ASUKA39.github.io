<!DOCTYPE html>
<html lang="en-gb"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">LLVM Tutor Note | a39&#39;s blog</title>
<meta property="og:title" content="LLVM Tutor Note | a39&#39;s blog" />
<meta name="twitter:title" content="LLVM Tutor Note | a39&#39;s blog" />
<meta itemprop="name" content="LLVM Tutor Note | a39&#39;s blog" />
<meta name="application-name" content="LLVM Tutor Note | a39&#39;s blog" />
<meta property="og:site_name" content="Awesome hugo blog" />

<meta name="description" content="LLVM Tutor 笔记">
<meta itemprop="description" content="LLVM Tutor 笔记" />
<meta property="og:description" content="LLVM Tutor 笔记" />
<meta name="twitter:description" content="LLVM Tutor 笔记" />

<meta property="og:locale" content="en-gb" />
<meta name="language" content="en-gb" />

  <link rel="alternate" hreflang="en-gb" href="http://localhost:1313/posts/2024-03-31-llvm-tutor/" title="English" />



  <meta itemprop="image" content="http://localhost:1313/" />
  <meta property="og:image" content="http://localhost:1313/" />
  <meta name="twitter:image" content="http://localhost:1313/" />
  <meta name="twitter:image:src" content="http://localhost:1313/" />




    
    
    

    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content=2024-03-31T00:00:00Z />
    <meta property="article:published_time" content=2024-03-31T00:00:00Z />

    
    <meta property="og:article:author" content="A39" />
    <meta property="article:author" content="A39" />
    <meta name="author" content="A39" />
    

    

    <script defer type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "LLVM Tutor Note",
        "author": {
        "@type": "Person",
        "name": ""
        },
        "datePublished": "2024-03-31",
        "description": "LLVM Tutor 笔记",
        "wordCount":  7107 ,
        "mainEntityOfPage": "True",
        "dateModified": "2024-03-31",
        "image": {
        "@type": "imageObject",
        "url": ""
        },
        "publisher": {
        "@type": "Organization",
        "name": "a39\u0027s blog"
        }
    }
    </script>


<meta name="generator" content="Hugo 0.124.1">

    

    <link rel="canonical" href="http://localhost:1313/posts/2024-03-31-llvm-tutor/">
    <link href="/style.min.438600358716ffcca2c03b3bd92033c379583f8a88e7181207671f5b8dec4ac1.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon.ico">
    <link rel="mask-icon" href="/icons/favicon.ico">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="http://localhost:1313/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    <meta name="google-site-verification" content="OBu2RkZZmMk9xXDviEo5asuAjsd_8wa5j_4Ii17jFEU" />
    <meta name="msvalidate.01" content="BBF6721C148EF3AB67B2821F85888D4D" />

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    </head>
<body data-theme = "dark" class="notransition">

<script src="/js/theme.js"></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="http://localhost:1313/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title>Home</title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        Home
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/posts/">
                        Posts
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/about/">
                        About
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/friends/">
                        Friends
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">LLVM Tutor Note</h1>
                
                
                <div class="post-meta">
                    <time datetime="2024-03-31T00:00:00&#43;00:00" itemprop="datePublished"> 31 Mar 2024 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b>Table of Contents</b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#environment">Environment</a></li>
    <li><a href="#helloworld">HelloWorld</a>
      <ul>
        <li><a href="#first-taste">First Taste</a></li>
        <li><a href="#code-analysis">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#opcodecounter">OpcodeCounter</a>
      <ul>
        <li><a href="#first-taste-1">First Taste</a></li>
        <li><a href="#code-analysis-1">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#injectfunccall">InjectFuncCall</a>
      <ul>
        <li><a href="#first-taste-2">First Taste</a></li>
        <li><a href="#code-analysis-2">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#staticcallcounter">StaticCallCounter</a>
      <ul>
        <li><a href="#first-taste-3">First Taste</a></li>
        <li><a href="#code-analysis-3">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#dynamiccallcounter">DynamicCallCounter</a>
      <ul>
        <li><a href="#first-taste-4">First Taste</a></li>
        <li><a href="#code-analysis-4">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#mbasub">MBASub</a>
      <ul>
        <li><a href="#first-taste-5">First Taste</a></li>
        <li><a href="#code-analysis-5">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#mbaadd">MBAAdd</a>
      <ul>
        <li><a href="#first-taste-6">First Taste</a></li>
        <li><a href="#code-analysis-6">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#riv">RIV</a>
      <ul>
        <li><a href="#first-taste-7">First Taste</a></li>
        <li><a href="#code-analysis-7">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#duplicatebb">DuplicateBB</a>
      <ul>
        <li><a href="#first-taste-8">First Taste</a></li>
        <li><a href="#code-analysis-8">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#mergebb">MergeBB</a>
      <ul>
        <li><a href="#first-taste-9">First Taste</a></li>
        <li><a href="#code-analysis-9">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#findfcmpeq">FindFCmpEq</a>
      <ul>
        <li><a href="#first-taste-10">First Taste</a></li>
        <li><a href="#code-analysis-10">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#convertfcmpeq">ConvertFCmpEq</a>
      <ul>
        <li><a href="#first-taste-11">First Taste</a></li>
        <li><a href="#code-analysis-11">Code Analysis</a></li>
      </ul>
    </li>
    <li><a href="#tips">Tips</a></li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <ul>
<li>本人学习<a href="https://github.com/banach-space/llvm-tutor">banach-space/llvm-tutor</a>的一点笔记</li>
</ul>
<h2 id="environment">Environment</h2>
<p>首先安装 LLVM-17。Ubuntu 的包版本普遍滞后，22.04 到目前只有 LLVM-14，如果想使用更现代的 LLVM-17 就需要添加第三方源（其实是因为 LLVM project 的 API 更换太频繁到现在都没稳定下来）</p>
<ul>
<li>Ubuntu 22.04</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key <span class="p">|</span> sudo apt-key add -
</span></span><span class="line"><span class="cl">sudo apt-add-repository <span class="s2">&#34;deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-17 main&#34;</span>
</span></span><span class="line"><span class="cl">sudo apt update
</span></span><span class="line"><span class="cl">sudo apt install -y llvm-17 llvm-17-dev llvm-17-tools clang-17
</span></span></code></pre></div><p>安装完就能在<code>/usr/lib/llvm-17</code>找到所需的头文件、库和二进制文件了</p>
<ul>
<li>推荐给 shell 加个配置</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LLVM_DIR</span><span class="o">=</span>/usr/lib/llvm-17
</span></span></code></pre></div><ul>
<li>如果用的 vscode，建个<code>.vscode</code>后<code>F1</code>输入<code>C++: Edit Configurations (UI)</code>，加上编译器路径、Include Path 和 C++ 标准
<ul>
<li>Include Path 加上：<code>/usr/include/llvm-17</code>、<code>/usr/include/llvm-c-17</code></li>
</ul>
</li>
</ul>
<h2 id="helloworld">HelloWorld</h2>
<h3 id="first-taste">First Taste</h3>
<p>编译 HelloWorldPass</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> /path/to/llvm-tutor
</span></span><span class="line"><span class="cl">mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake -DLT_LLVM_INSTALL_DIR<span class="o">=</span><span class="nv">$LLVM_DIR</span> ../HelloWorld/
</span></span><span class="line"><span class="cl">make
</span></span></code></pre></div><p>编译完成后就可以在<code>build</code>目录看到 Pass <code>libHelloWorld.so</code>了</p>
<p>在使用 Pass 之前，首先需要准备一个小白鼠作为输入文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -O1 -S -emit-llvm ../inputs/input_for_hello.c -o input_for_hello.ll
</span></span></code></pre></div><p>小白鼠长这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="nf">foo</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fez</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">+=</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">+=</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">+=</span> <span class="nf">fez</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>运行完成后可以在<code>build</code>目录下发现<code>input_for_hello.c</code>的 IR 文件<code>input_for_hello.ll</code></p>
<p>生成出的 IR 长这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="c">; ModuleID = &#39;../inputs/input_for_hello.c&#39;
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">source_filename</span> <span class="p">=</span> <span class="s">&#34;../inputs/input_for_hello.c&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">&#34;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">&#34;x86_64-pc-linux-gnu&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">%2</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%1</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">%3</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl">  <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%3</span><span class="p">,</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%4</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@fez</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%1</span><span class="p">,</span> <span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%2</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">%4</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">  <span class="n">%5</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%2</span><span class="p">,</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">  <span class="n">%6</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">  <span class="n">%7</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%6</span><span class="p">,</span> <span class="n">%4</span>
</span></span><span class="line"><span class="cl">  <span class="n">%8</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%7</span><span class="p">,</span> <span class="n">%5</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="k">nocapture</span> <span class="err">no</span><span class="k">undef</span> <span class="k">readnone</span> <span class="n">%1</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="m">12915</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="err">mustprogress</span> <span class="err">no</span><span class="k">free</span> <span class="k">norecurse</span> <span class="err">nosyn</span><span class="k">c</span> <span class="k">nounwind</span> <span class="err">willreturn</span> <span class="err">memory</span><span class="p">(</span><span class="k">none</span><span class="p">)</span> <span class="k">uwtable</span> <span class="s">&#34;min-legal-vector-width&#34;</span><span class="p">=</span><span class="s">&#34;0&#34;</span> <span class="s">&#34;no-trapping-math&#34;</span><span class="p">=</span><span class="s">&#34;true&#34;</span> <span class="s">&#34;stack-protector-buffer-size&#34;</span><span class="p">=</span><span class="s">&#34;8&#34;</span> <span class="s">&#34;target-cpu&#34;</span><span class="p">=</span><span class="s">&#34;x86-64&#34;</span> <span class="s">&#34;target-features&#34;</span><span class="p">=</span><span class="s">&#34;+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87&#34;</span> <span class="s">&#34;tune-cpu&#34;</span><span class="p">=</span><span class="s">&#34;generic&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">!llvm.module.flags</span> <span class="p">=</span> <span class="p">!{</span><span class="n">!0</span><span class="p">,</span> <span class="n">!1</span><span class="p">,</span> <span class="n">!2</span><span class="p">,</span> <span class="n">!3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">!llvm.ident</span> <span class="p">=</span> <span class="p">!{</span><span class="n">!4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!&#34;wchar_size&#34;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="nv">!&#34;PIC Level&#34;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">!2</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">7</span><span class="p">,</span> <span class="nv">!&#34;PIE Level&#34;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">!3</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">7</span><span class="p">,</span> <span class="nv">!&#34;uwtable&#34;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">!4</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&#34;Ubuntu clang version 17.0.6 (++20231209124227+6009708b4367-1~exp1~20231209124336.77)&#34;</span><span class="p">}</span>
</span></span></code></pre></div><p>最后把 IR 和 Pass 交给 opt，看看输出的效果如何</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ opt-17 -load-pass-plugin ./libHelloWorld.so -passes<span class="o">=</span>hello-world -disable-output input_for_hello.ll
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: foo
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: bar
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: fez
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: main
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">2</span>
</span></span></code></pre></div><p>可以看到 Pass 只是将函数名和参数数量输出了一遍</p>
<h3 id="code-analysis">Code Analysis</h3>
<p>首先看 Pass 的主体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">HelloWorld</span> <span class="o">:</span> <span class="n">PassInfoMixin</span><span class="o">&lt;</span><span class="n">HelloWorld</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Main entry point, takes IR unit to run the pass on (&amp;F) and the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// corresponding pass manager (to be queried if need be)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">PreservedAnalyses</span> <span class="nf">run</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">visitor</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Without isRequired returning true, this pass will be skipped for functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// decorated with the optnone LLVM attribute. Note that clang -O0 decorates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// all functions with optnone.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">static</span> <span class="kt">bool</span> <span class="nf">isRequired</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>可以看到 Pass 的主体<code>HelloWorld</code>继承自模板<code>PassInfoMixin&lt;PassT&gt;</code>。<code>PassInfoMixin</code>是新版的 PassManager 的实现，它是一个 CRTP 模板，Pass 需要继承它并实现<code>run</code>方法，接收一些 IR 单元和一个分析管理器，返回类型为<code>PreservedAnalyses</code></p>
<ul>
<li>
<p>旧版的 PM 是什么样的我没看不知道</p>
</li>
<li>
<p>CRTP 是 C++ 里的一种很有趣的技巧，其特点就是先实现一个模板类，然后实现一个派生类，但派生类声明的父类类型是该派生类本身。这样做可以实现很多很有趣的特性，比如父类可以访问派生类的方法、实现静态多态（省去虚函数绑定的同时实现多态）、方便地进行子类计数等</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Derived</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span></code></pre></div></li>
<li>
<p>C++ 的 struct 和 class 除了成员的默认访问权限不同外完全一样，同样有构造函数和虚构函数，同样有 OOP 特性，但要注意的是 C++ 的结构体与 C 结构体的内存布局（用 C++ 的描述说，C struct 是 POD 类型的）已经完全不同，各个成员的内存存储不再是连续的，因此 C 也无法再兼容调用 C++ 实现的结构体，需要手动做一些兼容设计</p>
</li>
</ul>
<p>继续看<code>visitor</code>方法，其实就是在 stderr 输出函数名和 argc</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">visitor</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(llvm-tutor) Hello from: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(llvm-tutor)   number of arguments: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">.</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后是关于新 PM 下 Pass 的注册方面的内容。注册 Pass 的核心接口是要实现<code>llvmGetPassPluginInfo</code>函数。 这是一个无参并返回<code>PassPluginLibraryInfo</code>的函数。<code>PassPluginLibraryInfo</code>是一个纯 C 结构体（定义前带<code>extern &quot;C&quot;</code>，因此各成员在内存里是连续的），结构体内包含：32 位整数<code>APIVersion</code>、字符串<code>PluginName</code>、字符串<code>PluginVersion</code>和一个在 Pass 被装载时调用的回调函数指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">llvm</span><span class="o">::</span><span class="n">PassPluginLibraryInfo</span> <span class="n">getHelloWorldPluginInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span><span class="n">LLVM_PLUGIN_API_VERSION</span><span class="p">,</span> <span class="s">&#34;HelloWorld&#34;</span><span class="p">,</span> <span class="n">LLVM_VERSION_STRING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="p">[](</span><span class="n">PassBuilder</span> <span class="o">&amp;</span><span class="n">PB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">PB</span><span class="p">.</span><span class="n">registerPipelineParsingCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="p">[](</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">FunctionPassManager</span> <span class="o">&amp;</span><span class="n">FPM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">PassBuilder</span><span class="o">::</span><span class="n">PipelineElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&#34;hello-world&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">FPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">HelloWorld</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">});</span>
</span></span><span class="line"><span class="cl">          <span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// This is the core interface for pass plugins. It guarantees that &#39;opt&#39; will
</span></span></span><span class="line"><span class="cl"><span class="c1">// be able to recognize HelloWorld when added to the pass pipeline on the
</span></span></span><span class="line"><span class="cl"><span class="c1">// command line, i.e. via &#39;-passes=hello-world&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="n">LLVM_ATTRIBUTE_WEAK</span> <span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">PassPluginLibraryInfo</span>
</span></span><span class="line"><span class="cl"><span class="n">llvmGetPassPluginInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">getHelloWorldPluginInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><code>extern &quot;C&quot;</code>用于告诉编译器以 C 的规则处理该处定义，由于 C++ 在 C 的基础上做了很多改动（比如编译时会修饰函数、结构体的内存布局等），于是用 <code>extern &quot;C&quot;</code>就可以告诉编译器此处使用 C 标准，从而解决 C/C++ 混合编程带来的兼容性问题</li>
</ul>
<p>最后看看 Pass 的编译，不太懂 CMake，找了半天最后找到下面这条，其中<code>c++</code>是个指向<code>g++</code>的符号链接，所以最后 Pass 是被编译成一个带位置无关代码的动态链接库</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="err">/usr/bin/c++</span> <span class="err">-fPIC</span> <span class="err">-shared</span> <span class="err">-Wl,-soname,libHelloWorld.so</span> <span class="err">-o</span> <span class="err">libHelloWorld.so</span> <span class="err">CMakeFiles/HelloWorld.dir/HelloWorld.cpp.o
</span></span></span></code></pre></div><h2 id="opcodecounter">OpcodeCounter</h2>
<h3 id="first-taste-1">First Taste</h3>
<p>这次编译要将所有示例全部编译完</p>
<p>先将整个<code>build</code>删掉，然后重新生成 CMake 文件重新 make</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">rm -r build
</span></span><span class="line"><span class="cl">mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake -DLT_LLVM_INSTALL_DIR<span class="o">=</span><span class="nv">$LLVM_DIR</span> ../
</span></span><span class="line"><span class="cl">make
</span></span></code></pre></div><p>中间可能会缺库报错，比如我就缺了 libedit 和 libzstd</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt install -y libedit-dev
</span></span><span class="line"><span class="cl">sudo apt install -y libzstd-dev
</span></span></code></pre></div><p>然后在<code>build/lib</code>里就能看到所有编译完的 Pass 了</p>
<p>然后我们生成小白鼠的 bitcode，并运行 Pass</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -emit-llvm -c ../inputs/input_for_cc.c -o input_for_cc.bc
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libOpcodeCounter.so -passes<span class="o">=</span><span class="s2">&#34;print&lt;opcode-counter&gt;&#34;</span> -disable-output input_for_cc.bc
</span></span></code></pre></div><p>小白鼠长这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span><span class="nf">foo</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fez</span><span class="p">()</span> <span class="p">{</span><span class="nf">bar</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nf">fez</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出长这样，把每个函数里的各种指令统计了一遍</p>
<pre tabindex="0"><code>Printing analysis &#39;OpcodeCounter Pass&#39; for function &#39;foo&#39;:
=================================================
LLVM-TUTOR: OpcodeCounter results
=================================================
OPCODE               #TIMES USED
-------------------------------------------------
ret                  1
-------------------------------------------------

Printing analysis &#39;OpcodeCounter Pass&#39; for function &#39;bar&#39;:
=================================================
LLVM-TUTOR: OpcodeCounter results
=================================================
OPCODE               #TIMES USED
-------------------------------------------------
call                 1
ret                  1
-------------------------------------------------

Printing analysis &#39;OpcodeCounter Pass&#39; for function &#39;fez&#39;:
=================================================
LLVM-TUTOR: OpcodeCounter results
=================================================
OPCODE               #TIMES USED
-------------------------------------------------
call                 1
ret                  1
-------------------------------------------------

Printing analysis &#39;OpcodeCounter Pass&#39; for function &#39;main&#39;:
=================================================
LLVM-TUTOR: OpcodeCounter results
=================================================
OPCODE               #TIMES USED
-------------------------------------------------
add                  1
call                 4
ret                  1
load                 2
br                   4
alloca               2
store                4
icmp                 1
-------------------------------------------------
</code></pre><p>除了上面这种直接指定调用 Pass 的方法外，还可以通过指定优化级别（<code>-On</code>）来自动调用 Pass，前提是在 Pass 里写了对应的规则，后面会讲到</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libOpcodeCounter.so --passes<span class="o">=</span><span class="s1">&#39;default&lt;O1&gt;&#39;</span> -disable-output input_for_cc.bc
</span></span></code></pre></div><h3 id="code-analysis-1">Code Analysis</h3>
<p>代码开始变复杂了。首先看看注册部分，可以看到这里有三个注册操作</p>
<ul>
<li>首先注册整个 Plugin，其可以通过命令行传入字符串<code>print&lt;opcode-counter&gt;</code>向 PM 添加 Pass</li>
<li>然后将<code>OpcodeCounterPrinter</code>注册进现有的 pipeline 的一部分，意思大概就是开优化时（<code>-O{1|2|3|s}</code>）自动调用它</li>
<li>最后将<code>OpcodeCounter</code>注册为 Analysis Pass，注册完其就可以被<code>FAM.getResult</code>调用了
<ul>
<li>关于 Pass 下面的几个派生类，大体上分为 AnalysisPass、TransformPass 和 UtilityPass
<ul>
<li>AnalysisPass 用于计算相关 IR 单元的信息，但不做修改，通常作为查询和分析的接口供其他 Pass 使用</li>
<li>TransformPass 会检视 IR、调 AnalysisPass 查询 IR 的信息，然后按规则优化或改变 IR</li>
<li>UtilityPass 主要是一些功能性的程序，故单独将其分离出来一个派生类</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">llvm</span><span class="o">::</span><span class="n">PassPluginLibraryInfo</span> <span class="n">getOpcodeCounterPluginInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LLVM_PLUGIN_API_VERSION</span><span class="p">,</span> <span class="s">&#34;OpcodeCounter&#34;</span><span class="p">,</span> <span class="n">LLVM_VERSION_STRING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">[](</span><span class="n">PassBuilder</span> <span class="o">&amp;</span><span class="n">PB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// #1 REGISTRATION FOR &#34;opt -passes=print&lt;opcode-counter&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Register OpcodeCounterPrinter so that it can be used when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// specifying pass pipelines with `-passes=`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">PB</span><span class="p">.</span><span class="n">registerPipelineParsingCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">FunctionPassManager</span> <span class="o">&amp;</span><span class="n">FPM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					<span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">PassBuilder</span><span class="o">::</span><span class="n">PipelineElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&#34;print&lt;opcode-counter&gt;&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">FPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">OpcodeCounterPrinter</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">});</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// #2 REGISTRATION FOR &#34;-O{1|2|3|s}&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Register OpcodeCounterPrinter as a step of an existing pipeline.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// The insertion point is specified by using the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// &#39;registerVectorizerStartEPCallback&#39; callback. To be more precise,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// using this callback means that OpcodeCounterPrinter will be called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// whenever the vectoriser is used (i.e. when using &#39;-O{1|2|3|s}&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">PB</span><span class="p">.</span><span class="n">registerVectorizerStartEPCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">				<span class="p">[](</span><span class="n">llvm</span><span class="o">::</span><span class="n">FunctionPassManager</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					<span class="n">llvm</span><span class="o">::</span><span class="n">OptimizationLevel</span> <span class="n">Level</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">PM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">OpcodeCounterPrinter</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">				<span class="p">});</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// #3 REGISTRATION FOR &#34;FAM.getResult&lt;OpcodeCounter&gt;(Func)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Register OpcodeCounter as an analysis pass. This is required so that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// OpcodeCounterPrinter (or any other pass) can request the results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// of OpcodeCounter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">PB</span><span class="p">.</span><span class="n">registerAnalysisRegistrationCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">				<span class="p">[](</span><span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="n">FAM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">FAM</span><span class="p">.</span><span class="n">registerPass</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">OpcodeCounter</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">				<span class="p">});</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="n">LLVM_ATTRIBUTE_WEAK</span> <span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">PassPluginLibraryInfo</span>
</span></span><span class="line"><span class="cl"><span class="n">llvmGetPassPluginInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">getOpcodeCounterPluginInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后来看看两个 Pass 的主体</p>
<ul>
<li><code>FAM.getResult</code>会在函数对象<code>Func</code>上运行模板指定的 Pass 的<code>run</code>方法，并将结果作为引用返回
<ul>
<li>Pass 的具体运作方式还得看看 PM 的源码</li>
</ul>
</li>
<li><code>OpcodeCounterPrinter</code>的输出流<code>OS</code>在<code>includeOpcodeCounter.h</code>里有定义，是一个 LLVM 自己封装的输入输出流<code>raw_ostream</code>，<code>raw_ostream</code>不仅支持标准流，还支持文件流和 string 流，常用于内部打印</li>
<li>当 Pass 运行后，其有可能会改变 IR，<code>PreservedAnalyses</code>表示的就是哪些改变将被保留，<code>PreservedAnalyses::all()</code>表示所有分析结果都被保留</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">OpcodeCounter</span><span class="o">::</span><span class="n">Result</span> <span class="n">OpcodeCounter</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">llvm</span><span class="o">::</span><span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">generateOpcodeMap</span><span class="p">(</span><span class="n">Func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PreservedAnalyses</span> <span class="n">OpcodeCounterPrinter</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="n">FAM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">&amp;</span><span class="n">OpcodeMap</span> <span class="o">=</span> <span class="n">FAM</span><span class="p">.</span><span class="n">getResult</span><span class="o">&lt;</span><span class="n">OpcodeCounter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// In the legacy PM, the following string is printed automatically by the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pass manager. For the sake of consistency, we&#39;re adding this here so that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// it&#39;s also printed when using the new PM.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Printing analysis &#39;OpcodeCounter Pass&#39; for function &#39;&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;&lt;</span> <span class="n">Func</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&#39;:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">printOpcodeCounterResult</span><span class="p">(</span><span class="n">OS</span><span class="p">,</span> <span class="n">OpcodeMap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后来看看 counter 的主逻辑</p>
<ul>
<li><code>OpcodeMap</code>的具体定义在头文件里，是一个<code>llvm::StringMap&lt;unsigned&gt;</code>，LLVM 似乎把与 string 关联的很多数据结构自行封装了一遍</li>
<li>代码逻辑就是先遍历<code>Func</code>的 Basic Block，容纳后遍历 Basic Block 里的所有指令，获取指令的名称后在哈希表里做记录，最后返回存有结果的哈希表</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">OpcodeCounter</span><span class="o">::</span><span class="n">Result</span> <span class="n">OpcodeCounter</span><span class="o">::</span><span class="n">generateOpcodeMap</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">OpcodeCounter</span><span class="o">::</span><span class="n">Result</span> <span class="n">OpcodeMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">Func</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Inst</span> <span class="p">:</span> <span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">StringRef</span> <span class="n">Name</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">OpcodeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span> <span class="o">==</span> <span class="n">OpcodeMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">OpcodeMap</span><span class="p">[</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">OpcodeMap</span><span class="p">[</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcodeName</span><span class="p">()]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">OpcodeMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>综合前面的代码，可知这个 Pass 的粒度是单个 Function，于是其就会在 opt 将每个函数放进 pipeline 时都被调用一遍</p>
<h2 id="injectfunccall">InjectFuncCall</h2>
<h3 id="first-taste-2">First Taste</h3>
<p>这个 Pass 会在每个函数里插个桩，输出函数名和 argc</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;(llvm-tutor) Hello from: %s</span><span class="se">\n</span><span class="s">(llvm-tutor)   number of arguments: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">FuncName</span><span class="p">,</span> <span class="n">FuncNumArgs</span><span class="p">)</span>
</span></span></code></pre></div><p>首先还是生成 bitcode、过 pipeline</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -O0 -emit-llvm -c ../inputs/input_for_hello.c -o input_for_hello.bc
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libInjectFuncCall.so --passes<span class="o">=</span><span class="s2">&#34;inject-func-call&#34;</span> input_for_hello.bc -o instrumented.bin
</span></span></code></pre></div><ul>
<li>最后生成的 bin 文件似乎是 bitcode</li>
</ul>
<p>然后我们可以用 lli 测试工具来运行它</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ lli-17 instrumented.bin
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: main
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: foo
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: bar
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: foo
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: fez
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: bar
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span> Hello from: foo
</span></span><span class="line"><span class="cl"><span class="o">(</span>llvm-tutor<span class="o">)</span>   number of arguments: <span class="m">1</span>
</span></span></code></pre></div><ul>
<li>lli 还可以测试运行 IR 文件</li>
<li>IR 和 bitcode 似乎并没有什么不同，当我没说（）</li>
</ul>
<p>用 llvm-dis 工具可以将 bitcode 转回可读的 IR。diff 一下看看原来的 IR 和现在的有何不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">$ diff input_for_hello.ll instrumented.bin.ll
</span></span><span class="line"><span class="cl"><span class="gu">1c1
</span></span></span><span class="line"><span class="cl"><span class="gu"></span><span class="gd">- ; ModuleID = &#39;input_for_hello.bc&#39;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gs">---
</span></span></span><span class="line"><span class="cl"><span class="gs"></span><span class="gi">+ ; ModuleID = &#39;./instrumented.bin&#39;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">5a6,11
</span></span></span><span class="line"><span class="cl"><span class="gu"></span><span class="gi">+ @PrintfFormatStr = global [68 x i8] c&#34;(llvm-tutor) Hello from: %s\0A(llvm-tutor)   number of arguments: %d\0A\00&#34;
</span></span></span><span class="line"><span class="cl"><span class="gi">+ @0 = private unnamed_addr constant [4 x i8] c&#34;foo\00&#34;, align 1
</span></span></span><span class="line"><span class="cl"><span class="gi">+ @1 = private unnamed_addr constant [4 x i8] c&#34;bar\00&#34;, align 1
</span></span></span><span class="line"><span class="cl"><span class="gi">+ @2 = private unnamed_addr constant [4 x i8] c&#34;fez\00&#34;, align 1
</span></span></span><span class="line"><span class="cl"><span class="gi">+ @3 = private unnamed_addr constant [5 x i8] c&#34;main\00&#34;, align 1
</span></span></span><span class="line"><span class="cl"><span class="gi">+
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">8,12c14,19
</span></span></span><span class="line"><span class="cl"><span class="gu"></span><span class="gd">-   %2 = alloca i32, align 4
</span></span></span><span class="line"><span class="cl"><span class="gd">-   store i32 %0, ptr %2, align 4
</span></span></span><span class="line"><span class="cl"><span class="gd">-   %3 = load i32, ptr %2, align 4
</span></span></span><span class="line"><span class="cl"><span class="gd">-   %4 = mul nsw i32 %3, 2
</span></span></span><span class="line"><span class="cl"><span class="gd">-   ret i32 %4
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gs">---
</span></span></span><span class="line"><span class="cl"><span class="gs"></span><span class="gi">+   %2 = call i32 (ptr, ...) @printf(ptr @PrintfFormatStr, ptr @0, i32 1)
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %3 = alloca i32, align 4
</span></span></span><span class="line"><span class="cl"><span class="gi">+   store i32 %0, ptr %3, align 4
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %4 = load i32, ptr %3, align 4
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %5 = mul nsw i32 %4, 2
</span></span></span><span class="line"><span class="cl"><span class="gi">+   ret i32 %5
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>...
</span></span></code></pre></div><ul>
<li>可以看到除了那些由于 SSA 改变的临时寄存器名外主要还是在函数前多了条<code>call @printf</code></li>
</ul>
<h3 id="code-analysis-2">Code Analysis</h3>
<p>注册没什么特别的，那就先看看<code>run</code>。其实就是调用<code>runOnModule</code>处理 module，然后根据 IR 是否有所改变返回<code>llvm::PreservedAnalyses</code></p>
<ul>
<li>按照新 PM 的规定，<code>run</code>返回<code>llvm::PreservedAnalyses.all()</code>表示当前 Pass 没有修改任何 IR，也就意味着当前 Pass 执行后所有分析结果依然有效，这是新 PM 用来提高效率的做法</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">PreservedAnalyses</span> <span class="n">InjectFuncCall</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">llvm</span><span class="o">::</span><span class="n">ModuleAnalysisManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span>  <span class="n">runOnModule</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">Changed</span> <span class="o">?</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">none</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="o">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后看看主逻辑</p>
<ul>
<li>step 0
<ul>
<li>首先获取 module 的 context</li>
<li>然后<code>Type::getInt8Ty</code>从 context 获取一个 8 比特（1 字节）的 int 类型，即 char 类型</li>
<li><code>PointerType::getUnqual</code>构造一个指向 0 地址的指定类型的指针，代表<code>printf</code>的第一个参数的类型<code>char *</code></li>
</ul>
</li>
<li>step 1
<ul>
<li><code>FunctionType::get</code>用于创建一个新的函数类型，第一个参数是函数的返回类型（这里是 32 位的 int），第二个参数是一个参数类型的列表（这里只指明了第一个参数的类型<code>char *</code>），第三个参数表明函数是否是可变参数的</li>
<li><code>getOrInsertFunction</code>用于在 module 的符号表里查找同名函数，如果不存在则插入，存在则比对 prototype 并用旧的 prototype 替换之，返回<code>FunctionCallee</code></li>
<li>然后设置 printf 的一些属性，从上往下是：
<ul>
<li>printf 不会抛出异常，可以删掉异常处理代码</li>
<li>第一个参数添加属性<code>NoCapture</code>，即参数不会被任何函数内部的指针捕获，方便优化时别名分析</li>
<li>第一个参数填加属性<code>ReadOnly</code>，方便优化</li>
</ul>
</li>
</ul>
</li>
<li>step 2
<ul>
<li>创建全局变量<code>PrintfFormatStr</code>，用于保存 printf 的格式化字符串<code>PrintfFormatStr</code></li>
<li><code>getOrInsertGlobal</code>将全局变量<code>PrintfFormatStrVar</code>添加进 module 中，同样如果曾经声明过旧用旧定义替换，这里<code>PrintfFormatStrVar</code>的类型应该是一个 array</li>
<li><code>setInitializer</code>将变量<code>PrintfFormatStrVar</code>的初始值设置为<code>PrintfFormatStr</code></li>
</ul>
</li>
<li>step 3
<ul>
<li>遍历 module 里的 function</li>
<li>判断这个 function 是函数声明还是函数定义，如果是声明旧跳过了</li>
<li>然后创建一个 IR Builder，位置在 function 的第一个 basic block 的第一个插入点（返回第一个指令的迭代器）</li>
<li>随后创建一个内容是函数名的全局字符串变量</li>
<li>随后创建一个格式化字符串的局部变量<code>formatStr</code>，<code>Builder.CreatePointerCast</code>将 array 类型的<code>PrintfFormatStrVar</code>转换为<code>char *</code>类型以适应 printf 的定义</li>
<li>最后调用<code>Builder.CreateCall</code>创建一个 printf 的调用，并将是否已插桩标记为 True</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">InjectFuncCall</span><span class="o">::</span><span class="n">runOnModule</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">InsertedAtLeastOnePrintf</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">&amp;</span><span class="n">CTX</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">PointerType</span> <span class="o">*</span><span class="n">PrintfArgTy</span> <span class="o">=</span> <span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getInt8Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 1: Inject the declaration of printf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ----------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Create (or _get_ in cases where it&#39;s already available) the following
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// declaration in the IR module:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    declare i32 @printf(i8*, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// It corresponds to the following C declaration:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//    int printf(char *, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintfTy</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="n">PrintfArgTy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*IsVarArgs=*/</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">FunctionCallee</span> <span class="n">Printf</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">&#34;printf&#34;</span><span class="p">,</span> <span class="n">PrintfTy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Set attributes as per inferLibFuncAttributes in BuildLibCalls.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Function</span> <span class="o">*</span><span class="n">PrintfF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Printf</span><span class="p">.</span><span class="n">getCallee</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">setDoesNotThrow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">NoCapture</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 2: Inject a global variable that will hold the printf format string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">llvm</span><span class="o">::</span><span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStr</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ConstantDataArray</span><span class="o">::</span><span class="n">getString</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="n">CTX</span><span class="p">,</span> <span class="s">&#34;(llvm-tutor) Hello from: %s</span><span class="se">\n</span><span class="s">(llvm-tutor)   number of arguments: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">Constant</span> <span class="o">*</span><span class="n">PrintfFormatStrVar</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">		<span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="s">&#34;PrintfFormatStr&#34;</span><span class="p">,</span> <span class="n">PrintfFormatStr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">PrintfFormatStr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 3: For each function in the module, inject a call to printf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ----------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">F</span> <span class="p">:</span> <span class="n">M</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">isDeclaration</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Get an IR builder. Sets the insertion point to the top of the function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">getFirstInsertionPt</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Inject a global variable that contains the function name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="n">FuncName</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateGlobalStringPtr</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Printf requires i8*, but PrintfFormatStrVar is an array: [n x i8]. Add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// a cast: [n x i8] -&gt; i8*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">llvm</span><span class="o">::</span><span class="n">Value</span> <span class="o">*</span><span class="n">FormatStrPtr</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">			<span class="n">Builder</span><span class="p">.</span><span class="n">CreatePointerCast</span><span class="p">(</span><span class="n">PrintfFormatStrVar</span><span class="p">,</span> <span class="n">PrintfArgTy</span><span class="p">,</span> <span class="s">&#34;formatStr&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// The following is visible only if you pass -debug on the command line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// *and* you have an assert build.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Injecting call to printf inside &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">						<span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Finally, inject a call to printf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="n">Printf</span><span class="p">,</span> <span class="p">{</span><span class="n">FormatStrPtr</span><span class="p">,</span> <span class="n">FuncName</span><span class="p">,</span> <span class="n">Builder</span><span class="p">.</span><span class="n">getInt32</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">arg_size</span><span class="p">())});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">InsertedAtLeastOnePrintf</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">InsertedAtLeastOnePrintf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>以上就完成了一次简单的插桩（这么多类型和 API 谁记得住啊）</p>
<h2 id="staticcallcounter">StaticCallCounter</h2>
<h3 id="first-taste-3">First Taste</h3>
<p>所谓 Static Call 指的就是在编译期的调用，相反在运行时的调用就是 Dynamic Call，比如在循环里有函数调用，Static Call 就只会计数一次，而 Dynamic Call 的计数则取决于循环次数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">foo</span><span class="p">();</span>
</span></span></code></pre></div><p>用的还是之前的 bitcode，这里直接跳到 opt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libStaticCallCounter.so -passes<span class="o">=</span><span class="s2">&#34;print&lt;static-cc&gt;&#34;</span> -disable-output input_for_cc.bc
</span></span></code></pre></div><p>输出如下</p>
<pre tabindex="0"><code>=================================================
LLVM-TUTOR: static analysis results
=================================================
NAME                 #N DIRECT CALLS
-------------------------------------------------
foo                  3
bar                  2
fez                  1
-------------------------------------------------
</code></pre><h3 id="code-analysis-3">Code Analysis</h3>
<p>其实没什么好说的，Static Call Counter 的流程和前面的非常相像，这里简单分析下</p>
<p>首先注册 Printer 和 Counter</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">llvm</span><span class="o">::</span><span class="n">PassPluginLibraryInfo</span> <span class="n">getStaticCallCounterPluginInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">{</span><span class="n">LLVM_PLUGIN_API_VERSION</span><span class="p">,</span> <span class="s">&#34;static-cc&#34;</span><span class="p">,</span> <span class="n">LLVM_VERSION_STRING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">[](</span><span class="n">PassBuilder</span> <span class="o">&amp;</span><span class="n">PB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// #1 REGISTRATION FOR &#34;opt -passes=print&lt;static-cc&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">PB</span><span class="p">.</span><span class="n">registerPipelineParsingCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">					<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">ModulePassManager</span> <span class="o">&amp;</span><span class="n">MPM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">PassBuilder</span><span class="o">::</span><span class="n">PipelineElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&#34;print&lt;static-cc&gt;&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="n">MPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">StaticCallCounterPrinter</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">						<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="p">});</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// #2 REGISTRATION FOR &#34;MAM.getResult&lt;StaticCallCounter&gt;(Module)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">PB</span><span class="p">.</span><span class="n">registerAnalysisRegistrationCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">					<span class="p">[](</span><span class="n">ModuleAnalysisManager</span> <span class="o">&amp;</span><span class="n">MAM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">MAM</span><span class="p">.</span><span class="n">registerPass</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">StaticCallCounter</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">					<span class="p">});</span>
</span></span><span class="line"><span class="cl">			<span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>然后直接看 Counter</p>
<ul>
<li>其实就是遍历 module 里的 function 里的 Basic Block 里的指令</li>
<li>函数调用用<code>CallBase</code>类表示，尝试 cast 转换一下就知道指令是不是函数调用了</li>
<li><code>getCalledFunction()</code>方法获取被调用的函数</li>
<li>最后在哈希表里处理一下就结束了</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">StaticCallCounter</span><span class="o">::</span><span class="n">Result</span> <span class="n">StaticCallCounter</span><span class="o">::</span><span class="n">runOnModule</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">llvm</span><span class="o">::</span><span class="n">MapVector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">Res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Func</span> <span class="p">:</span> <span class="n">M</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">Func</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Ins</span> <span class="p">:</span> <span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// If this is a call instruction then CB will be not null.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">auto</span> <span class="o">*</span><span class="n">CB</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">CallBase</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ins</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">CB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// If CB is a direct function call then DirectInvoc will be not null.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">auto</span> <span class="n">DirectInvoc</span> <span class="o">=</span> <span class="n">CB</span><span class="o">-&gt;</span><span class="n">getCalledFunction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">DirectInvoc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// We have a direct function call - update the count for the function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// being called.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">auto</span> <span class="n">CallCount</span> <span class="o">=</span> <span class="n">Res</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">DirectInvoc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">Res</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">CallCount</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">CallCount</span> <span class="o">=</span> <span class="n">Res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">DirectInvoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">++</span><span class="n">CallCount</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StaticCallCounter</span><span class="o">::</span><span class="n">Result</span>
</span></span><span class="line"><span class="cl"><span class="n">StaticCallCounter</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ModuleAnalysisManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">runOnModule</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>至于函数指针这种能不能分析出来就不知道了</p>
<h2 id="dynamiccallcounter">DynamicCallCounter</h2>
<h3 id="first-taste-4">First Taste</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libDynamicCallCounter.so -passes<span class="o">=</span><span class="s2">&#34;dynamic-cc&#34;</span> input_for_cc.bc -o instrumented.bin
</span></span><span class="line"><span class="cl">lli-17 instrumented.bin
</span></span></code></pre></div><p>输出如下</p>
<pre tabindex="0"><code>=================================================
LLVM-TUTOR: dynamic analysis results
=================================================
NAME                 #N DIRECT CALLS
-------------------------------------------------
bar                  2
main                 1
foo                  13
fez                  1
</code></pre><p>可以发现 Dynamic Counter 比 Static Counter 给 foo 的统计多了循环里的部分，而且 main 也有了一次计数</p>
<h3 id="code-analysis-4">Code Analysis</h3>
<p>直接看主体部分<code>runOnModule</code>。代码比较长，这里分几步贴出</p>
<p>step 0 先建两个哈希表，一个用于保存计数，另一个用于保存函数名，最后获取 context</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">Instrumented</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Function name &lt;--&gt; IR variable that holds the call counter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="n">Constant</span> <span class="o">*&gt;</span> <span class="n">CallCounterMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Function name &lt;--&gt; IR variable that holds the function name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="n">Constant</span> <span class="o">*&gt;</span> <span class="n">FuncNameMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="o">&amp;</span><span class="n">CTX</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>
</span></span></code></pre></div><p>step 1</p>
<ul>
<li>开始遍历 module 内的每个函数（跳过函数声明）</li>
<li>在函数首部建一个 IR Builder，然后给函数建一个 string，调用<code>CreateGlobalCounter</code>创建用于计数的全局变量，并将函数名和计数器变量记录在 step 0 创建的哈希表<code>CallCounterMap</code>中</li>
<li>最后用 Builder 插入 load、add、store 指令，并将插桩 flag 置为真</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// STEP 1: For each function in the module, inject a call-counting code
</span></span></span><span class="line"><span class="cl"><span class="c1">// --------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">F</span> <span class="p">:</span> <span class="n">M</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">isDeclaration</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get an IR builder. Sets the insertion point to the top of the function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">getFirstInsertionPt</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Create a global variable to count the calls to this function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CounterName</span> <span class="o">=</span> <span class="s">&#34;CounterFor_&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Constant</span> <span class="o">*</span><span class="n">Var</span> <span class="o">=</span> <span class="n">CreateGlobalCounter</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">CounterName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">CallCounterMap</span><span class="p">[</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Create a global variable to hold the name of this function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">FuncName</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateGlobalStringPtr</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">FuncNameMap</span><span class="p">[</span><span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">FuncName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Inject instruction to increment the call count each time this function
</span></span></span><span class="line"><span class="cl"><span class="c1">// executes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LoadInst</span> <span class="o">*</span><span class="n">Load2</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">),</span> <span class="n">Var</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Value</span> <span class="o">*</span><span class="n">Inc2</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Builder</span><span class="p">.</span><span class="n">getInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Load2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Builder</span><span class="p">.</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">Inc2</span><span class="p">,</span> <span class="n">Var</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// The following is visible only if you pass -debug on the command line
</span></span></span><span class="line"><span class="cl"><span class="c1">// *and* you have an assert build.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Instrumented: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Instrumented</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Stop here if there are no function definitions in this module
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nb">false</span> <span class="o">==</span> <span class="n">Instrumented</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">Instrumented</span><span class="p">;</span>
</span></span></code></pre></div><p>step 2、step 3</p>
<ul>
<li>其实就是构造一个 printf 的原型并设置好相关属性，然后构造格式化字符串全局变量，此前讲述过</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// STEP 2: Inject the declaration of printf
</span></span></span><span class="line"><span class="cl"><span class="c1">// ----------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1">// Create (or _get_ in cases where it&#39;s already available) the following
</span></span></span><span class="line"><span class="cl"><span class="c1">// declaration in the IR module:
</span></span></span><span class="line"><span class="cl"><span class="c1">//    declare i32 @printf(i8*, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1">// It corresponds to the following C declaration:
</span></span></span><span class="line"><span class="cl"><span class="c1">//    int printf(char *, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">PointerType</span> <span class="o">*</span><span class="n">PrintfArgTy</span> <span class="o">=</span> <span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getInt8Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintfTy</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">),</span> <span class="n">PrintfArgTy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="cm">/*IsVarArgs=*/</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">FunctionCallee</span> <span class="n">Printf</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">&#34;printf&#34;</span><span class="p">,</span> <span class="n">PrintfTy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Set attributes as per inferLibFuncAttributes in BuildLibCalls.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Function</span> <span class="o">*</span><span class="n">PrintfF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Printf</span><span class="p">.</span><span class="n">getCallee</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">setDoesNotThrow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">NoCapture</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintfF</span><span class="o">-&gt;</span><span class="n">addParamAttr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Attribute</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// STEP 3: Inject a global variable that will hold the printf format string
</span></span></span><span class="line"><span class="cl"><span class="c1">// ------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">llvm</span><span class="o">::</span><span class="n">Constant</span> <span class="o">*</span><span class="n">ResultFormatStr</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">llvm</span><span class="o">::</span><span class="n">ConstantDataArray</span><span class="o">::</span><span class="n">getString</span><span class="p">(</span><span class="n">CTX</span><span class="p">,</span> <span class="s">&#34;%-20s %-10lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Constant</span> <span class="o">*</span><span class="n">ResultFormatStrVar</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="s">&#34;ResultFormatStrIR&#34;</span><span class="p">,</span> <span class="n">ResultFormatStr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResultFormatStrVar</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">ResultFormatStr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">out</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">out</span> <span class="o">+=</span> <span class="s">&#34;=================================================</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">out</span> <span class="o">+=</span> <span class="s">&#34;LLVM-TUTOR: dynamic analysis results</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">out</span> <span class="o">+=</span> <span class="s">&#34;=================================================</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">out</span> <span class="o">+=</span> <span class="s">&#34;NAME                 #N DIRECT CALLS</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">out</span> <span class="o">+=</span> <span class="s">&#34;-------------------------------------------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">llvm</span><span class="o">::</span><span class="n">Constant</span> <span class="o">*</span><span class="n">ResultHeaderStr</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">llvm</span><span class="o">::</span><span class="n">ConstantDataArray</span><span class="o">::</span><span class="n">getString</span><span class="p">(</span><span class="n">CTX</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Constant</span> <span class="o">*</span><span class="n">ResultHeaderStrVar</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">M</span><span class="p">.</span><span class="n">getOrInsertGlobal</span><span class="p">(</span><span class="s">&#34;ResultHeaderStrIR&#34;</span><span class="p">,</span> <span class="n">ResultHeaderStr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResultHeaderStrVar</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setInitializer</span><span class="p">(</span><span class="n">ResultHeaderStr</span><span class="p">);</span>
</span></span></code></pre></div><p>step 4、step 5</p>
<ul>
<li>统计的结果需要被输出出来，这里构造了一个函数<code>printf_wrapper</code>，函数会依次输出函数名和引用计数（不过代码是直接展开的，没有设置循环，不是很智能）</li>
<li>最后调用<code>appendToGlobalDtors</code>函数，将 printf_wrapper 添加到全局析构函数列表（在 ELF section <code>.fini_array</code>中，这是 ELF 的析构函数表，会被<code>__libc_csu_fini</code>调用），这样在程序正常退出时 printf_wrapper 就会被调用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// STEP 4: Define a printf wrapper that will print the results
</span></span></span><span class="line"><span class="cl"><span class="c1">// -----------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1">// Define `printf_wrapper` that will print the results stored in FuncNameMap
</span></span></span><span class="line"><span class="cl"><span class="c1">// and CallCounterMap.  It is equivalent to the following C++ function:
</span></span></span><span class="line"><span class="cl"><span class="c1">// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">//    void printf_wrapper() {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      for (auto &amp;item : Functions)
</span></span></span><span class="line"><span class="cl"><span class="c1">//        printf(&#34;llvm-tutor): Function %s was called %d times. \n&#34;,
</span></span></span><span class="line"><span class="cl"><span class="c1">//        item.name, item.count);
</span></span></span><span class="line"><span class="cl"><span class="c1">//    }
</span></span></span><span class="line"><span class="cl"><span class="c1">// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">// (item.name comes from FuncNameMap, item.count comes from
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallCounterMap)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">FunctionType</span> <span class="o">*</span><span class="n">PrintfWrapperTy</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">getVoidTy</span><span class="p">(</span><span class="n">CTX</span><span class="p">),</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">						<span class="cm">/*IsVarArgs=*/</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Function</span> <span class="o">*</span><span class="n">PrintfWrapperF</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="n">M</span><span class="p">.</span><span class="n">getOrInsertFunction</span><span class="p">(</span><span class="s">&#34;printf_wrapper&#34;</span><span class="p">,</span> <span class="n">PrintfWrapperTy</span><span class="p">).</span><span class="n">getCallee</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Create the entry basic block for printf_wrapper ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">llvm</span><span class="o">::</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">RetBlock</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">llvm</span><span class="o">::</span><span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">CTX</span><span class="p">,</span> <span class="s">&#34;enter&#34;</span><span class="p">,</span> <span class="n">PrintfWrapperF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">RetBlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... and start inserting calls to printf
</span></span></span><span class="line"><span class="cl"><span class="c1">// (printf requires i8*, so cast the input strings accordingly)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">llvm</span><span class="o">::</span><span class="n">Value</span> <span class="o">*</span><span class="n">ResultHeaderStrPtr</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">Builder</span><span class="p">.</span><span class="n">CreatePointerCast</span><span class="p">(</span><span class="n">ResultHeaderStrVar</span><span class="p">,</span> <span class="n">PrintfArgTy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">llvm</span><span class="o">::</span><span class="n">Value</span> <span class="o">*</span><span class="n">ResultFormatStrPtr</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="n">Builder</span><span class="p">.</span><span class="n">CreatePointerCast</span><span class="p">(</span><span class="n">ResultFormatStrVar</span><span class="p">,</span> <span class="n">PrintfArgTy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">Printf</span><span class="p">,</span> <span class="p">{</span><span class="n">ResultHeaderStrPtr</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">LoadInst</span> <span class="o">*</span><span class="n">LoadCounter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">item</span> <span class="p">:</span> <span class="n">CallCounterMap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">LoadCounter</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">CTX</span><span class="p">),</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// LoadCounter = Builder.CreateLoad(item.second);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="n">Printf</span><span class="p">,</span> <span class="p">{</span><span class="n">ResultFormatStrPtr</span><span class="p">,</span> <span class="n">FuncNameMap</span><span class="p">[</span><span class="n">item</span><span class="p">.</span><span class="n">first</span><span class="p">()],</span> <span class="n">LoadCounter</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Finally, insert return instruction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Builder</span><span class="p">.</span><span class="n">CreateRetVoid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// STEP 5: Call `printf_wrapper` at the very end of this module
</span></span></span><span class="line"><span class="cl"><span class="c1">// ------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">appendToGlobalDtors</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">PrintfWrapperF</span><span class="p">,</span> <span class="cm">/*Priority=*/</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></div><p>一开始我不太理解代码中所说的“将代码添加到 module 的末尾”的含义，于是将 bitcode 编译为汇编代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">llc-17 -filetype<span class="o">=</span>asm instrumented.bin -o instrumented.s
</span></span></code></pre></div><p>汇编代码的最后有这么一段，这段汇编的含义是：定义可写可分配的<code>.fini_array</code>段、然后用<code>NOP</code>对齐、最后在段内存储<code>printf_wrapper</code>的地址，也即我们前面分析的意思</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.section</span>	<span class="no">.fini_array.0</span><span class="p">,</span><span class="s">&#34;aw&#34;</span><span class="p">,</span><span class="na">@fini_array</span>
</span></span><span class="line"><span class="cl"><span class="na">.p2align</span>	<span class="mi">3</span><span class="p">,</span> <span class="mi">0x90</span>
</span></span><span class="line"><span class="cl"><span class="na">.quad</span>	<span class="no">printf_wrapper</span>
</span></span></code></pre></div><h2 id="mbasub">MBASub</h2>
<p>Mixed Boolean Arithmetic Transformations</p>
<h3 id="first-taste-5">First Taste</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -emit-llvm -S ../inputs/input_for_mba_sub.c -o input_for_sub.ll
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libMBASub.so -passes<span class="o">=</span><span class="s2">&#34;mba-sub&#34;</span> -S input_for_sub.ll -o out.ll
</span></span></code></pre></div><p>先来看看原来的 IR，还只是正常的 Sub 指令完成减法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%1</span><span class="p">)</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%30</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%28</span><span class="p">,</span> <span class="n">%29</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%33</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%31</span><span class="p">,</span> <span class="n">%32</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%36</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%34</span><span class="p">,</span> <span class="n">%35</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%36</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后看看后面的，现在减法已经混淆成这种形式：<code>a-b = (a+~b)+1</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@main</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="err">ptr</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%1</span><span class="p">)</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%30</span> <span class="p">=</span> <span class="k">xor</span> <span class="k">i32</span> <span class="n">%29</span><span class="p">,</span> <span class="m">-1</span>
</span></span><span class="line"><span class="cl">  <span class="n">%31</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%28</span><span class="p">,</span> <span class="n">%30</span>
</span></span><span class="line"><span class="cl">  <span class="n">%32</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%31</span><span class="p">,</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%35</span> <span class="p">=</span> <span class="k">xor</span> <span class="k">i32</span> <span class="n">%34</span><span class="p">,</span> <span class="m">-1</span>
</span></span><span class="line"><span class="cl">  <span class="n">%36</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%33</span><span class="p">,</span> <span class="n">%35</span>
</span></span><span class="line"><span class="cl">  <span class="n">%37</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%36</span><span class="p">,</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">%40</span> <span class="p">=</span> <span class="k">xor</span> <span class="k">i32</span> <span class="n">%39</span><span class="p">,</span> <span class="m">-1</span>
</span></span><span class="line"><span class="cl">  <span class="n">%41</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%38</span><span class="p">,</span> <span class="n">%40</span>
</span></span><span class="line"><span class="cl">  <span class="n">%42</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%41</span><span class="p">,</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%42</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="code-analysis-5">Code Analysis</h3>
<ul>
<li>遍历 Basic Block 里的每条指令，提取其中的所有 Binary Operator，并细化提取所有的 Sub 指令</li>
<li>然后将<code>a+b</code>转换为<code>(a+~b)+1</code>，<code>getOperand</code>函数可以提取 Binary Operator 的 LHS 和 RHS</li>
<li>最后调用<code>ReplaceInstWithInst</code>将原来的 Sub 指令替换为刚刚构造的指令</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">MBASub</span><span class="o">::</span><span class="n">runOnBasicBlock</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over all instructions in the block. Replacing instructions requires
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// iterators, hence a for-range loop wouldn&#39;t be suitable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Inst</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">IE</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">Inst</span> <span class="o">!=</span> <span class="n">IE</span><span class="p">;</span> <span class="o">++</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip non-binary (e.g. unary or compare) instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="o">*</span><span class="n">BinOp</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BinOp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">/// Skip instructions other than integer sub.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">!=</span> <span class="n">Instruction</span><span class="o">::</span><span class="n">Sub</span> <span class="o">||</span> <span class="o">!</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// A uniform API for creating instructions and inserting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// them into basic blocks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">BinOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Create an instruction representing (a + ~b) + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Instruction</span> <span class="o">*</span><span class="n">NewValue</span> <span class="o">=</span> <span class="n">BinaryOperator</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">							<span class="n">Builder</span><span class="p">.</span><span class="n">CreateNot</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">			<span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// The following is visible only if you pass -debug on the command line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// *and* you have an assert build.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">BinOp</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; -&gt; &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">NewValue</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Replace `(a - b)` (original instructions) with `(a + ~b) + 1`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// (the new instruction)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">NewValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Update the statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">++</span><span class="n">SubstCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="mbaadd">MBAAdd</h2>
<p>Mixed Boolean Arithmetic Transformations</p>
<h3 id="first-taste-6">First Taste</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -O1 -emit-llvm -S ../inputs/input_for_mba.c -o input_for_mba.ll
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libMBAAdd.so -passes<span class="o">=</span><span class="s2">&#34;mba-add&#34;</span> -S input_for_mba.ll -o out.ll
</span></span></code></pre></div><p>然后看看 IR 有何变化。可以看到普通的 Add 指令已经变成这种形式：<code>a + b = (((a ^ b) + 2 * (a &amp; b)) * 39 + 23) * 151 + 111</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">$ diff input_for_mba.ll out.ll
</span></span><span class="line"><span class="cl"><span class="gu">1c1
</span></span></span><span class="line"><span class="cl"><span class="gu"></span><span class="gd">- ; ModuleID = &#39;../inputs/input_for_mba.c&#39;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gs">---
</span></span></span><span class="line"><span class="cl"><span class="gs"></span><span class="gi">+ ; ModuleID = &#39;input_for_mba.ll&#39;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">8,11c8,32
</span></span></span><span class="line"><span class="cl"><span class="gu"></span><span class="gd">-   %5 = add i8 %1, %0
</span></span></span><span class="line"><span class="cl"><span class="gd">-   %6 = add i8 %5, %2
</span></span></span><span class="line"><span class="cl"><span class="gd">-   %7 = add i8 %6, %3
</span></span></span><span class="line"><span class="cl"><span class="gd">-   ret i8 %7
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gs">---
</span></span></span><span class="line"><span class="cl"><span class="gs"></span><span class="gi">+   %5 = and i8 %1, %0
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %6 = mul i8 2, %5
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %7 = xor i8 %1, %0
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %8 = add i8 %7, %6
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %9 = mul i8 39, %8
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %10 = add i8 23, %9
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %11 = mul i8 -105, %10
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %12 = add i8 111, %11
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %13 = and i8 %12, %2
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %14 = mul i8 2, %13
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %15 = xor i8 %12, %2
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %16 = add i8 %15, %14
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %17 = mul i8 39, %16
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %18 = add i8 23, %17
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %19 = mul i8 -105, %18
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %20 = add i8 111, %19
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %21 = and i8 %20, %3
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %22 = mul i8 2, %21
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %23 = xor i8 %20, %3
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %24 = add i8 %23, %22
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %25 = mul i8 39, %24
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %26 = add i8 23, %25
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %27 = mul i8 -105, %26
</span></span></span><span class="line"><span class="cl"><span class="gi">+   %28 = add i8 111, %27
</span></span></span><span class="line"><span class="cl"><span class="gi">+   ret i8 %28
</span></span></span></code></pre></div><h3 id="code-analysis-6">Code Analysis</h3>
<p>这里和 MBASub 逻辑是一致的，直接看代码即可理解。注意这种替换混淆只对 8 位整数有效，故需要判断 Binary Operator 操作的类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">MBAAdd</span><span class="o">::</span><span class="n">runOnBasicBlock</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over all instructions in the block. Replacing instructions requires
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// iterators, hence a for-range loop wouldn&#39;t be suitable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Inst</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">IE</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">Inst</span> <span class="o">!=</span> <span class="n">IE</span><span class="p">;</span> <span class="o">++</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip non-binary (e.g. unary or compare) instructions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="o">*</span><span class="n">BinOp</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BinOp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip instructions other than add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Instruction</span><span class="o">::</span><span class="n">Add</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip if the result is not 8-bit wide (this implies that the operands are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// also 8-bit wide)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">()</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">			<span class="o">!</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getIntegerBitWidth</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// A uniform API for creating instructions and inserting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// them into basic blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">BinOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Constants used in building the instruction for substitution
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="n">Val39</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">39</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">Val151</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">151</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">Val23</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">Val2</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">Val111</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">111</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Build an instruction representing `(((a ^ b) + 2 * (a &amp; b)) * 39 + 23) *
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 151 + 111`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Instruction</span> <span class="o">*</span><span class="n">NewInst</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// E = e5 + 111
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">BinaryOperator</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">				<span class="n">Val111</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// e5 = e4 * 151
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">					<span class="n">Val151</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// e4 = e2 + 23
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">						<span class="n">Val23</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="c1">// e3 = e2 * 39
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">							<span class="n">Val39</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="c1">// e2 = e0 + e1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="n">Builder</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">								<span class="c1">// e0 = a ^ b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="n">Builder</span><span class="p">.</span><span class="n">CreateXor</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">												<span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">								<span class="c1">// e1 = 2 * (a &amp; b)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">									<span class="n">Val2</span><span class="p">,</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAnd</span><span class="p">(</span><span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">															<span class="n">BinOp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">						<span class="p">)</span> <span class="c1">// e3 = e2 * 39
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="p">)</span> <span class="c1">// e4 = e2 + 23
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="p">)</span> <span class="c1">// e5 = e4 * 151
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">);</span> <span class="c1">// E = e5 + 111
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The following is visible only if you pass -debug on the command line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// *and* you have an assert build.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">BinOp</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; -&gt; &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">NewInst</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Replace `(a + b)` (original instructions) with `(((a ^ b) + 2 * (a &amp; b))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// * 39 + 23) * 151 + 111` (the new instruction)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">NewInst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Update the statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">++</span><span class="n">SubstCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="riv">RIV</h2>
<h3 id="first-taste-7">First Taste</h3>
<p>原 README 没怎么将 RIV 是什么，Google 也没查到解释，最后 GPT 读完源码后给了这么一个解释：</p>
<blockquote>
<p>RIV（Reachable Integer Values）的目标是为输入函数中的每个基本块创建一个可达整数值的列表。这个列表包含了从该基本块开始，可以通过控制流图（CFG）到达的所有整数值。&ldquo;可达&quot;的含义是，从一个基本块开始，通过控制流图（CFG）的边，可以到达另一个基本块。如果一个整数值在一个基本块中被定义（例如，通过一个指令），并且这个基本块可以从另一个基本块到达，那么我们就说这个整数值对于那个基本块是&quot;可达&quot;的。</p>
<p>RIV 的分析结果可以用于优化，例如常量传播和死代码消除。例如，如果一个基本块的 RIV 列表中没有一个特定的整数值，那么我们就知道在那个基本块中，没有任何代码可以引用那个整数值，因此我们可以安全地删除定义那个整数值的代码。</p>
</blockquote>
<p>emmm 看着挺有说服力就姑且相信它吧（）</p>
<p>源码长这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">123</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">987</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="mi">321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>运行一下 Pass</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -O1 -emit-llvm -S ../inputs/input_for_riv.c -o input_for_riv.ll
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libRIV.so -passes<span class="o">=</span><span class="s2">&#34;print&lt;riv&gt;&#34;</span> -disable-output input_for_riv.ll
</span></span></code></pre></div><p>原来的 IR 长这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">,</span> <span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%1</span><span class="p">,</span> <span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%2</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">123</span>
</span></span><span class="line"><span class="cl">  <span class="n">%5</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">sgt</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="k">i1</span> <span class="n">%5</span><span class="p">,</span> <span class="kt">label</span> <span class="n">%6</span><span class="p">,</span> <span class="kt">label</span> <span class="n">%17</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">6</span><span class="err">:</span>                                                <span class="c">; preds = %3
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="n">%7</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">  <span class="n">%8</span> <span class="p">=</span> <span class="k">sdiv</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl">  <span class="n">%9</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="n">%7</span><span class="p">,</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="k">i1</span> <span class="n">%9</span><span class="p">,</span> <span class="kt">label</span> <span class="n">%10</span><span class="p">,</span> <span class="kt">label</span> <span class="n">%14</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">10</span><span class="err">:</span>                                               <span class="c">; preds = %6
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="n">%11</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="n">%7</span><span class="p">,</span> <span class="m">-2</span>
</span></span><span class="line"><span class="cl">  <span class="n">%12</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="n">%11</span><span class="p">,</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl">  <span class="n">%13</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="n">%4</span><span class="p">,</span> <span class="n">%12</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="kt">label</span> <span class="n">%17</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">14</span><span class="err">:</span>                                               <span class="c">; preds = %6
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="n">%15</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%2</span><span class="p">,</span> <span class="m">987</span>
</span></span><span class="line"><span class="cl">  <span class="n">%16</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%15</span><span class="p">,</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="kt">label</span> <span class="n">%17</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">17</span><span class="err">:</span>                                               <span class="c">; preds = %3, %10, %14
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="n">%18</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="n">%13</span><span class="p">,</span> <span class="n">%10</span> <span class="p">],</span> <span class="p">[</span> <span class="n">%16</span><span class="p">,</span> <span class="n">%14</span> <span class="p">],</span> <span class="p">[</span> <span class="m">321</span><span class="p">,</span> <span class="n">%3</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="n">%18</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="p">=================================================</span>
</span></span><span class="line"><span class="cl"><span class="nl">LLVM-TUTOR:</span> <span class="err">RIV</span> <span class="err">analysis</span> <span class="err">results</span>
</span></span><span class="line"><span class="cl"><span class="p">=================================================</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="err">id</span>      <span class="err">Reachable</span> <span class="err">Ineger</span> <span class="err">Values</span>
</span></span><span class="line"><span class="cl"><span class="err">-------------------------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="n">%3</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%1</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="n">%6</span>
</span></span><span class="line"><span class="cl">               <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">123</span>
</span></span><span class="line"><span class="cl">               <span class="n">%5</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">sgt</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%1</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="n">%17</span>
</span></span><span class="line"><span class="cl">               <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">123</span>
</span></span><span class="line"><span class="cl">               <span class="n">%5</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">sgt</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%1</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="n">%10</span>
</span></span><span class="line"><span class="cl">               <span class="n">%7</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">               <span class="n">%8</span> <span class="p">=</span> <span class="k">sdiv</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl">               <span class="n">%9</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="n">%7</span><span class="p">,</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl">               <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">123</span>
</span></span><span class="line"><span class="cl">               <span class="n">%5</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">sgt</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%1</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl"><span class="err">BB</span> <span class="n">%14</span>
</span></span><span class="line"><span class="cl">               <span class="n">%7</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">               <span class="n">%8</span> <span class="p">=</span> <span class="k">sdiv</span> <span class="k">i32</span> <span class="n">%1</span><span class="p">,</span> <span class="n">%2</span>
</span></span><span class="line"><span class="cl">               <span class="n">%9</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="n">%7</span><span class="p">,</span> <span class="n">%8</span>
</span></span><span class="line"><span class="cl">               <span class="n">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">nsw</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">123</span>
</span></span><span class="line"><span class="cl">               <span class="n">%5</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">sgt</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%0</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%1</span>
</span></span><span class="line"><span class="cl">             <span class="k">i32</span> <span class="n">%2</span>
</span></span></code></pre></div><p>感觉还是不是很清晰，我的理解如下</p>
<ul>
<li>基本块<code>BB %3</code>中可达的只有参数中的<code>%0</code>、<code>%1</code>和<code>%2</code>
<ul>
<li><code>BB %3</code>的后继为<code>BB %6</code>和<code>BB %17</code></li>
</ul>
</li>
<li>而由于基本块<code>BB %6</code>是<code>BB %3</code>的后继，所以继承参数<code>%0</code>、<code>%1</code>和<code>%2</code>，以及<code>BB %3</code>中定义的<code>%4</code>和<code>%5</code>
<ul>
<li><code>BB %6</code>的后继为<code>BB %10</code>和<code>BB %14</code></li>
</ul>
</li>
<li>后面的基本块同样如此</li>
</ul>
<h3 id="code-analysis-7">Code Analysis</h3>
<ul>
<li>
<p>step 0</p>
<ul>
<li>
<p>定义了一个双端队列，用于后续遍历 Basic Block</p>
</li>
<li>
<p><code>NodeTy</code>是一个指向包含一个 Basic Block 的支配树节点的指针</p>
</li>
<li>
<blockquote>
<p>支配树（Dominator Tree）是一种在编译器优化和静态程序分析中常用的数据结构，它表示了程序的控制流图（Control Flow Graph，CFG）中的支配关系。</p>
<p>在控制流图中，一个节点 A 支配另一个节点 B，如果从入口节点到节点 B 的所有路径都必须经过节点 A。换句话说，如果我们从程序的入口开始执行，那么在每次到达 B 之前，我们都必须经过 A。</p>
<p>支配树是将这种支配关系表示为树形结构的一种方式。在支配树中，每个节点都支配它的所有子节点。这种结构使得查询一个节点是否支配另一个节点变得非常高效。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>step 1</p>
<ul>
<li>遍历 function 内部的所有 Basic Block，再遍历其内部的所有指令</li>
<li>将所有整数变量的定义加入<code>llvm::MapVector</code>类型的<code>DefinedValuesMap</code>中
<ul>
<li><code>llvm::MapVector</code>是一个通过将 Map 和 Vector 包装在一起实现一键多值存储的数据结构</li>
</ul>
</li>
</ul>
</li>
<li>
<p>step 2</p>
<ul>
<li>首先第一个循环遍历了 function 所在 module（<code>getParent</code>）内的全局变量，其中所有整数变量会被加入入口基本块的 RIV 集合哈希表<code>ResultMap</code>中</li>
<li>然后第二个循环遍历函数参数列表，并将整数形参加入入口基本块的 RIV 集合中</li>
</ul>
</li>
<li>
<p>step 3</p>
<ul>
<li>从入口基本块开始遍历 CFG，这里是通过向双端队列尾部 push 子基本块来完成遍历</li>
<li>从之前的<code>DefinedValuesMap</code>中获取本基本块内定义的整数变量</li>
<li>再从哈希表<code>ResultMap</code>中获取对于本基本块而言的全局变量</li>
<li>最后遍历子基本块，将本基本块的 RIV 添加到子基本块的 RIV 中，并将子基本块添加进要遍历的基本块队列中</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// DominatorTree node types used in RIV. One could use auto instead, but IMO
</span></span></span><span class="line"><span class="cl"><span class="c1">// being verbose makes it easier to follow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">NodeTy</span> <span class="o">=</span> <span class="n">DomTreeNodeBase</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">BasicBlock</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// A map that a basic block BB holds a set of pointers to values defined in BB.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">DefValMapTy</span> <span class="o">=</span> <span class="n">RIV</span><span class="o">::</span><span class="n">Result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RIV</span><span class="o">::</span><span class="n">Result</span> <span class="n">RIV</span><span class="o">::</span><span class="n">buildRIV</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="n">NodeTy</span> <span class="n">CFGRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Result</span> <span class="n">ResultMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initialise a double-ended queue that will be used to traverse all BBs in F
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">NodeTy</span><span class="o">&gt;</span> <span class="n">BBsToProcess</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">BBsToProcess</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CFGRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 1: For every basic block BB compute the set of integer values defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// in BB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">DefValMapTy</span> <span class="n">DefinedValuesMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="o">&amp;</span><span class="n">Values</span> <span class="o">=</span> <span class="n">DefinedValuesMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span><span class="nl">Inst</span> <span class="p">:</span> <span class="n">BB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="n">Values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 2: Compute the RIVs for the entry BB. This will include global
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// variables and input arguments.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="o">&amp;</span><span class="n">EntryBBValues</span> <span class="o">=</span> <span class="n">ResultMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">F</span><span class="p">.</span><span class="n">getEntryBlock</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Global</span> <span class="p">:</span> <span class="n">F</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">globals</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Global</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="n">EntryBBValues</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Global</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">Argument</span> <span class="o">&amp;</span><span class="nl">Arg</span> <span class="p">:</span> <span class="n">F</span><span class="p">.</span><span class="n">args</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isIntegerTy</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="n">EntryBBValues</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// STEP 3: Traverse the CFG for every BB in F calculate its RIVs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">BBsToProcess</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="o">*</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">BBsToProcess</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">BBsToProcess</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Get the values defined in Parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="o">&amp;</span><span class="n">ParentDefs</span> <span class="o">=</span> <span class="n">DefinedValuesMap</span><span class="p">[</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Get the RIV set of for Parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// (Since RIVMap is updated on every iteration, its contents are likely to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// be moved around when resizing. This means that we need a copy of it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// (i.e. a reference is not sufficient).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">llvm</span><span class="o">::</span><span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">Value</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">ParentRIVs</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">			<span class="n">ResultMap</span><span class="p">[</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Loop over all BBs that Parent dominates and update their RIV sets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">NodeTy</span> <span class="nl">Child</span> <span class="p">:</span> <span class="o">*</span><span class="n">Parent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">BBsToProcess</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">ChildBB</span> <span class="o">=</span> <span class="n">Child</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Add values defined in Parent to the current child&#39;s set of RIV
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">ResultMap</span><span class="p">[</span><span class="n">ChildBB</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">ParentDefs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ParentDefs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Add Parent&#39;s set of RIVs to the current child&#39;s RIV
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">ResultMap</span><span class="p">[</span><span class="n">ChildBB</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">ParentRIVs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ParentRIVs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ResultMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="duplicatebb">DuplicateBB</h2>
<h3 id="first-taste-8">First Taste</h3>
<p>这个 Pass 的功能似乎是将有 RIV 的基本块复制成两份并用 if-then-else 结构串起来</p>
<pre tabindex="0"><code>BEFORE:                     AFTER:
-------                     ------
                              [ if-then-else ]
             DuplicateBB           /  \
[ BB ]      ------------&gt;   [clone 1] [clone 2]
                                   \  /
                                 [ tail ]

LEGEND:
-------
[BB]           - the original basic block
[if-then-else] - a new basic block that contains the if-then-else statement (inserted by DuplicateBB)
[clone 1|2]    - two new basic blocks that are clones of BB (inserted by DuplicateBB)
[tail]         - the new basic block that merges [clone 1] and [clone 2] (inserted by DuplicateBB)
</code></pre><p>先跑起来看看</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -O1 -emit-llvm -S ../inputs/input_for_duplicate_bb.c -o input_for_duplicate_bb.ll
</span></span><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libRIV.so -load-pass-plugin ./lib/libDuplicateBB.so -passes<span class="o">=</span>duplicate-bb -S input_for_duplicate_bb.ll -o duplicate.ll
</span></span></code></pre></div><p>原来的 IR 只有一个最基本的 Basic Block</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">ret</span> <span class="k">i32</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>跑过 Pass 之后变成下面的样子了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">lt-if-then-else-0:</span>
</span></span><span class="line"><span class="cl">  <span class="n">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="k">i1</span> <span class="n">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%lt-clone-1-0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%lt-clone-2-0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">lt-clone-1-0:</span>                                     <span class="c">; preds = %lt-if-then-else-0
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%lt-tail-0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">lt-clone-2-0:</span>                                     <span class="c">; preds = %lt-if-then-else-0
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%lt-tail-0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">lt-tail-0:</span>                                        <span class="c">; preds = %lt-clone-2-0, %lt-clone-1-0
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="k">ret</span> <span class="k">i32</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>不知道啥作用，嗯</p>
<h3 id="code-analysis-8">Code Analysis</h3>
<p><code>run</code>主要是调用<code>findBBsToDuplicate</code>分析 RIV 的分析结果，然后调用<code>cloneBB</code>做基本块克隆</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">PreservedAnalyses</span> <span class="n">DuplicateBB</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">llvm</span><span class="o">::</span><span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="n">FAM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pRNG</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">pRNG</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">createRNG</span><span class="p">(</span><span class="s">&#34;duplicate-bb&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">BBToSingleRIVMap</span> <span class="n">Targets</span> <span class="o">=</span> <span class="n">findBBsToDuplicate</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">FAM</span><span class="p">.</span><span class="n">getResult</span><span class="o">&lt;</span><span class="n">RIV</span><span class="o">&gt;</span><span class="p">(</span><span class="n">F</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// This map is used to keep track of the new bindings. Otherwise, the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// information from RIV will become obsolete.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ValueToPhiMap</span> <span class="n">ReMapper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Duplicate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">BB_Ctx</span> <span class="p">:</span> <span class="n">Targets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cloneBB</span><span class="p">(</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BB_Ctx</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BB_Ctx</span><span class="p">),</span> <span class="n">ReMapper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">DuplicateBBCountStats</span> <span class="o">=</span> <span class="n">DuplicateBBCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">Targets</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">							<span class="o">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">none</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>先看<code>findBBsToDuplicate</code></p>
<ul>
<li>首先遍历函数内的 Basic Block，并跳过 landing pad 也就是用于表示异常处理的 Basic Block</li>
<li>然后获取此基本块的 RIV 分析结果</li>
<li>随后从 RIV 中随机选择一个值，若为全局变量则跳过</li>
<li>最后将这个变量的 RIV 迭代器和 Basic Block 指针放进哈希表并最终返回</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">DuplicateBB</span><span class="o">::</span><span class="n">BBToSingleRIVMap</span>
</span></span><span class="line"><span class="cl"><span class="n">DuplicateBB</span><span class="o">::</span><span class="n">findBBsToDuplicate</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="k">const</span> <span class="n">RIV</span><span class="o">::</span><span class="n">Result</span> <span class="o">&amp;</span><span class="n">RIVResult</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">BBToSingleRIVMap</span> <span class="n">BlocksToDuplicate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Basic blocks which are landing pads are used for handling exceptions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// That&#39;s out of scope of this pass.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">BB</span><span class="p">.</span><span class="n">isLandingPad</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Get the set of RIVs for this block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ReachableValues</span> <span class="o">=</span> <span class="n">RIVResult</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">size_t</span> <span class="n">ReachableValuesCount</span> <span class="o">=</span> <span class="n">ReachableValues</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Are there any RIVs for this BB? We need at least one to be able to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// duplicate this BB.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ReachableValuesCount</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;No context values for this BB</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Get a random context value from the RIV set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">auto</span> <span class="n">Iter</span> <span class="o">=</span> <span class="n">ReachableValues</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span> <span class="n">Dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ReachableValuesCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">Iter</span><span class="p">,</span> <span class="n">Dist</span><span class="p">(</span><span class="o">*</span><span class="n">pRNG</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalValue</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Iter</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Random context value is a global variable. &#34;</span>
</span></span><span class="line"><span class="cl">							<span class="o">&lt;&lt;</span> <span class="s">&#34;Skipping this BB</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Random context value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">Iter</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Store the binding between the current BB and the context variable that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// will be used for the `if-then-else` construct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">BlocksToDuplicate</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">,</span> <span class="o">*</span><span class="n">Iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">BlocksToDuplicate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后是<code>cloneBB</code></p>
<ul>
<li>首先找到函数的第一个非 phi 指令，phi 节点不能乱动</li>
<li>然后创建一个用于 if 的条件，调用的是<code>CreateIsNull</code>，生成的条件是 Basic Block 的 RIV 内的某个值
<ul>
<li>没搞懂这是要干啥</li>
</ul>
</li>
<li>然后调用<code>SplitBlockAndInsertIfThenElse</code>将当前 Basic Block 分割成 if-then-else 并隐式地创建一个收束块（后面的<code>Tail</code>调用<code>getSuccessor</code>获取 then 的后继，并 assert 它与 else的后继相同），并调用<code>setName</code>命名</li>
<li>然后遍历原始基本块（现在变成<code>Tail</code>了，<code>Tail</code>似乎会继承原基本块后续的内容）中的所有指令
<ul>
<li>跳过<code>Terminator</code>指令</li>
<li>分别为 then 和 else 克隆一份当前指令</li>
<li>然后往 then 和 else 插入克隆的指令</li>
<li>随后若指令类型不是 void ，那么新创建一个 phi 节点，并调用<code>addIncoming</code>将 then 和 else 插入 phi 节点
<ul>
<li>猜测：非 void 指令会产生返回值（可能是意味着基本块产生了一个新的 RIV），故做控制流拆分时这里将这些指令处理成 phi 节点来进行控制流同步</li>
<li>不过因为这里 then 和 else 是一样的，感觉没啥实际意义只是为了示例</li>
</ul>
</li>
<li>最后调用<code>ReplaceInstWithInst</code>将该指令替换成 phi 节点</li>
<li>最后的最后删除掉前面的非 void 节点</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DuplicateBB</span><span class="o">::</span><span class="n">cloneBB</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="n">BB</span><span class="p">,</span> <span class="n">Value</span> <span class="o">*</span><span class="n">ContextValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">ValueToPhiMap</span> <span class="o">&amp;</span><span class="n">ReMapper</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Don&#39;t duplicate Phi nodes - start right after them
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Instruction</span> <span class="o">*</span><span class="n">BBHead</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">getFirstNonPHI</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create the condition for &#39;if-then-else&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">BBHead</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Value</span> <span class="o">*</span><span class="n">Cond</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateIsNull</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="n">ReMapper</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">ContextValue</span><span class="p">)</span> <span class="o">?</span> <span class="n">ReMapper</span><span class="p">[</span><span class="n">ContextValue</span><span class="p">]</span> <span class="o">:</span> <span class="n">ContextValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create and insert the &#39;if-else&#39; blocks. At this point both blocks are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// trivial and contain only one terminator instruction branching to BB&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// tail, which contains all the instructions from BBHead onwards.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Instruction</span> <span class="o">*</span><span class="n">ThenTerm</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Instruction</span> <span class="o">*</span><span class="n">ElseTerm</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">SplitBlockAndInsertIfThenElse</span><span class="p">(</span><span class="n">Cond</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">BBHead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ThenTerm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ElseTerm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">BasicBlock</span> <span class="o">*</span><span class="n">Tail</span> <span class="o">=</span> <span class="n">ThenTerm</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">assert</span><span class="p">(</span><span class="n">Tail</span> <span class="o">==</span> <span class="n">ElseTerm</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;Inconsistent CFG&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Give the new basic blocks some meaningful names. This is not required, but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// makes the output easier to read.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">DuplicatedBBId</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">DuplicateBBCount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ThenTerm</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;lt-clone-1-&#34;</span> <span class="o">+</span> <span class="n">DuplicatedBBId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ElseTerm</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;lt-clone-2-&#34;</span> <span class="o">+</span> <span class="n">DuplicatedBBId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Tail</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;lt-tail-&#34;</span> <span class="o">+</span> <span class="n">DuplicatedBBId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ThenTerm</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSinglePredecessor</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;lt-if-then-else-&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">															<span class="n">DuplicatedBBId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Variables to keep track of the new bindings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ValueToValueMapTy</span> <span class="n">TailVMap</span><span class="p">,</span> <span class="n">ThenVMap</span><span class="p">,</span> <span class="n">ElseVMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// The list of instructions in Tail that don&#39;t produce any values and thus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// can be removed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Instruction</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">ToRemove</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Iterate through the original basic block and clone every instruction into
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the &#39;if-then&#39; and &#39;else&#39; branches. Update the bindings/uses on the fly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// (through ThenVMap, ElseVMap, TailVMap). At this stage, all instructions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// apart from PHI nodes, are stored in Tail.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">IIT</span> <span class="o">=</span> <span class="n">Tail</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">IE</span> <span class="o">=</span> <span class="n">Tail</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">IIT</span> <span class="o">!=</span> <span class="n">IE</span><span class="p">;</span> <span class="o">++</span><span class="n">IIT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Instruction</span> <span class="o">&amp;</span><span class="n">Instr</span> <span class="o">=</span> <span class="o">*</span><span class="n">IIT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">PHINode</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;Phi nodes have already been filtered out&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip terminators - duplicating them wouldn&#39;t make sense unless we want
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// to delete Tail completely.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">Instr</span><span class="p">.</span><span class="n">isTerminator</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">RemapInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">,</span> <span class="n">TailVMap</span><span class="p">,</span> <span class="n">RF_IgnoreMissingLocals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Clone the instructions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Instruction</span> <span class="o">*</span><span class="n">ThenClone</span> <span class="o">=</span> <span class="n">Instr</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span> <span class="o">*</span><span class="n">ElseClone</span> <span class="o">=</span> <span class="n">Instr</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Operands of ThenClone still hold references to the original BB.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Update/remap them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">RemapInstruction</span><span class="p">(</span><span class="n">ThenClone</span><span class="p">,</span> <span class="n">ThenVMap</span><span class="p">,</span> <span class="n">RF_IgnoreMissingLocals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">ThenClone</span><span class="o">-&gt;</span><span class="n">insertBefore</span><span class="p">(</span><span class="n">ThenTerm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">ThenVMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ThenClone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Operands of ElseClone still hold references to the original BB.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Update/remap them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">RemapInstruction</span><span class="p">(</span><span class="n">ElseClone</span><span class="p">,</span> <span class="n">ElseVMap</span><span class="p">,</span> <span class="n">RF_IgnoreMissingLocals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">ElseClone</span><span class="o">-&gt;</span><span class="n">insertBefore</span><span class="p">(</span><span class="n">ElseTerm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">ElseVMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ElseClone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Instructions that don&#39;t produce values can be safely removed from Tail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">ThenClone</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isVoidTy</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">ToRemove</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Instruction that produce a value should not require a slot in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// TAIL *but* they can be used from the context, so just always
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// generate a PHI, and let further optimization do the cleaning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">PHINode</span> <span class="o">*</span><span class="n">Phi</span> <span class="o">=</span> <span class="n">PHINode</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">ThenClone</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">Phi</span><span class="o">-&gt;</span><span class="n">addIncoming</span><span class="p">(</span><span class="n">ThenClone</span><span class="p">,</span> <span class="n">ThenTerm</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">		<span class="n">Phi</span><span class="o">-&gt;</span><span class="n">addIncoming</span><span class="p">(</span><span class="n">ElseClone</span><span class="p">,</span> <span class="n">ElseTerm</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">		<span class="n">TailVMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">]</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">ReMapper</span><span class="p">[</span><span class="o">&amp;</span><span class="n">Instr</span><span class="p">]</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Instructions are modified as we go, use the iterator version of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// ReplaceInstWithInst.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="n">Tail</span><span class="p">,</span> <span class="n">IIT</span><span class="p">,</span> <span class="n">Phi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Purge instructions that don&#39;t produce any value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="nl">I</span> <span class="p">:</span> <span class="n">ToRemove</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">I</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">DuplicateBBCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>好怪，还是没看懂它想干什么</p>
<h2 id="mergebb">MergeBB</h2>
<h3 id="first-taste-9">First Taste</h3>
<p>这个 Pass 会将之前那个 Pass 改造的控制流还原回去（怪不得之前那个看起来没啥用）</p>
<pre tabindex="0"><code>BEFORE:                     AFTER DuplicateBB:                 AFTER MergeBB:
-------                     ------------------                 --------------
                              [ if-then-else ]                 [ if-then-else* ]
             DuplicateBB           /  \               MergeBB         |
[ BB ]      ------------&gt;   [clone 1] [clone 2]      --------&gt;    [ clone ]
                                   \  /                               |
                                 [ tail ]                         [ tail* ]

LEGEND:
-------
[BB]           - the original basic block
[if-then-else] - a new basic block that contains the if-then-else statement (**DuplicateBB**)
[clone 1|2]    - two new basic blocks that are clones of BB (**DuplicateBB**)
[tail]         - the new basic block that merges [clone 1] and [clone 2] (**DuplicateBB**)
[clone]        - [clone 1] and [clone 2] after merging, this block should be very similar to [BB] (**MergeBB**)
[label*]       - [label] after being updated by **MergeBB**
</code></pre><p>文档给的命令好像有问题，用回下面的就好了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libMergeBB.so -passes<span class="o">=</span>merge-bb -S duplicate.ll -o merge.ll
</span></span></code></pre></div><p>原来被拆开的 IR 变成下面的样子了，可以看到其实基本块还是没全部合并回一个而且 if 结构还在，但 then 和 else 被合二为一了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="k">define</span> <span class="err">dso_local</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="err">no</span><span class="k">undef</span> <span class="n">%0</span><span class="p">)</span> <span class="k">local_unnamed_addr</span> <span class="vg">#0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">lt-if-then-else-0:</span>
</span></span><span class="line"><span class="cl">  <span class="n">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="n">%0</span><span class="p">,</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">br</span> <span class="k">i1</span> <span class="n">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%lt-clone-2-0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%lt-clone-2-0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">lt-clone-2-0:</span>                                     <span class="c">; preds = %lt-if-then-else-0, %lt-if-then-else-0
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%lt-tail-0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">lt-tail-0:</span>                                        <span class="c">; preds = %lt-clone-2-0
</span></span></span><span class="line"><span class="cl"><span class="c"></span>  <span class="k">ret</span> <span class="k">i32</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>还能再玩点花的，直接一次性将 RIV、Duplicate 和 Merge 三个 Pass 一起运行，注意<code>-passes</code>参数的顺序就是 Pass 依次运行的顺序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">opt-17 -load-pass-plugin ./lib/libRIV.so -load-pass-plugin ./lib/libDuplicateBB.so -load-pass-plugin ./lib/libMergeBB.so -passes<span class="o">=</span>d
</span></span><span class="line"><span class="cl">uplicate-bb,merge-bb -S input_for_duplicate_bb.ll -o merge_after_duplicate.ll
</span></span></code></pre></div><p>生成出来的 IR 跟上面是一样的</p>
<h3 id="code-analysis-9">Code Analysis</h3>
<p><code>run</code>首先对 function 的每个 Basic Block 调用<code>mergeDuplicatedBlock</code>并生成一个<code>DeleteList</code>，然后调用<code>DeleteDeadBlock</code>消除产生的死代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">PreservedAnalyses</span> <span class="n">MergeBB</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="n">llvm</span><span class="o">::</span><span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">DeleteList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">Func</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Changed</span> <span class="o">|=</span> <span class="n">mergeDuplicatedBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">,</span> <span class="n">DeleteList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">DeleteList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">DeleteDeadBlock</span><span class="p">(</span><span class="n">BB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">Changed</span> <span class="o">?</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">none</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="o">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>先看看<code>mergeDuplicatedBlock</code></p>
<ul>
<li>首先要跳过入口块，并检查 Basic Block<code>BB1</code>的最后一条指令（<code>getTerminator</code>）是否是条件分支（<code>isUnconditional</code>），如果不是也要跳过，并且还要遍历 Basic Block 的前驱判断它们的最后一条指令是不是分支或 Switch 指令，如果不是也要跳过</li>
<li>然后获取<code>BB1</code>的后继<code>BBSucc</code>，检查<code>BBSucc</code>的第一条指令和第二条指令是否是 phi 指令，如果两条指令都是这里也不做处理（否则代码会很繁琐，作为 Tutor 还是简洁为要），用 RIV 的测试代码测试发现也确实如此</li>
<li>书接上文，若<code>BBSucc</code>的第一条指令是 phi 指令，那么获取<code>BB1</code>在这个 phi 函数里对应的变量的第一条指令（即创建指令）<code>InInstBB1</code></li>
<li>接下来遍历<code>BBSucc</code>的所有前驱<code>BB2</code>（不包含<code>BB1</code>）
<ul>
<li>对<code>BB2</code>做和<code>BB1</code>同样的检查</li>
<li>检查<code>BB2</code>与<code>BB1</code>对 phi 函数的输入值是否相同以及是否是在它们中被定义的，若两者不符其一则跳过
<ul>
<li>猜测：如果输入值不是在 phi 的前驱定义的，那么 then 和 else 就不是 Duplicate 生成的，这里就直接不合并了</li>
</ul>
</li>
<li>随后调用<code>canMergeInstructions</code>检查<code>BB2</code>和<code>BB1</code>的指令是否相同，不同就不能合并</li>
<li>最后若是能合并的那么记录<code>BB1</code>和<code>BB2</code>，调用<code>updateBranchTargets</code>更新并返回</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">MergeBB</span><span class="o">::</span><span class="n">mergeDuplicatedBlock</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BB1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">DeleteList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Do not optimize the entry block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">BB1</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">BB1</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEntryBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Only merge CFG edges of unconditional branch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">BranchInst</span> <span class="o">*</span><span class="n">BB1Term</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BranchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BB1</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BB1Term</span> <span class="o">&amp;&amp;</span> <span class="n">BB1Term</span><span class="o">-&gt;</span><span class="n">isUnconditional</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Do not optimize non-branch and non-switch CFG edges (to keep things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// relatively simple)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="nl">B</span> <span class="p">:</span> <span class="n">predecessors</span><span class="p">(</span><span class="n">BB1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">BranchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">())</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">			<span class="n">isa</span><span class="o">&lt;</span><span class="n">SwitchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">())))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BBSucc</span> <span class="o">=</span> <span class="n">BB1Term</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span> <span class="o">=</span> <span class="n">BBSucc</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">PHINode</span> <span class="o">*</span><span class="n">PN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">PHINode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">II</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Value</span> <span class="o">*</span><span class="n">InValBB1</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Instruction</span> <span class="o">*</span><span class="n">InInstBB1</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">BBSucc</span><span class="o">-&gt;</span><span class="n">getFirstNonPHI</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">!=</span> <span class="n">PN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Do not optimize if multiple PHI instructions exist in the successor (to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// keep things relatively simple)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">II</span> <span class="o">!=</span> <span class="n">BBSucc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">PHINode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">II</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">InValBB1</span> <span class="o">=</span> <span class="n">PN</span><span class="o">-&gt;</span><span class="n">getIncomingValueForBlock</span><span class="p">(</span><span class="n">BB1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">InInstBB1</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="n">InValBB1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="n">BB1NumInst</span> <span class="o">=</span> <span class="n">getNumNonDbgInstrInBB</span><span class="p">(</span><span class="n">BB1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="nl">BB2</span> <span class="p">:</span> <span class="n">predecessors</span><span class="p">(</span><span class="n">BBSucc</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Do not optimize the entry block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">BB2</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">BB2</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEntryBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Only merge CFG edges of unconditional branch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">BranchInst</span> <span class="o">*</span><span class="n">BB2Term</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BranchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BB2</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BB2Term</span> <span class="o">&amp;&amp;</span> <span class="n">BB2Term</span><span class="o">-&gt;</span><span class="n">isUnconditional</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Do not optimize non-branch and non-switch CFG edges (to keep things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// relatively simple)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="nl">B</span> <span class="p">:</span> <span class="n">predecessors</span><span class="p">(</span><span class="n">BB2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">BranchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">())</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="n">isa</span><span class="o">&lt;</span><span class="n">SwitchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">())))</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip basic blocks that have already been marked for merging
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">DeleteList</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">!=</span> <span class="n">DeleteList</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">BB2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Make sure that BB2 != BB1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">BB2</span> <span class="o">==</span> <span class="n">BB1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// BB1 and BB2 are definitely different if the number of instructions is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// not identical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">BB1NumInst</span> <span class="o">!=</span> <span class="n">getNumNonDbgInstrInBB</span><span class="p">(</span><span class="n">BB2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Control flow can be merged if incoming values to the PHI node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// at the successor are same values or both defined in the BBs to merge.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// For the latter case, canMergeInstructions executes further analysis.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">!=</span> <span class="n">PN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Value</span> <span class="o">*</span><span class="n">InValBB2</span> <span class="o">=</span> <span class="n">PN</span><span class="o">-&gt;</span><span class="n">getIncomingValueForBlock</span><span class="p">(</span><span class="n">BB2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">Instruction</span> <span class="o">*</span><span class="n">InInstBB2</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="n">InValBB2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kt">bool</span> <span class="n">areValuesSimilar</span> <span class="o">=</span> <span class="p">(</span><span class="n">InValBB1</span> <span class="o">==</span> <span class="n">InValBB2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="kt">bool</span> <span class="n">bothValuesDefinedInParent</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">			<span class="p">((</span><span class="n">InInstBB1</span> <span class="o">&amp;&amp;</span> <span class="n">InInstBB1</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="n">BB1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="p">(</span><span class="n">InInstBB2</span> <span class="o">&amp;&amp;</span> <span class="n">InInstBB2</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="n">BB2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">areValuesSimilar</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bothValuesDefinedInParent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Finally, check that all instructions in BB1 and BB2 are identical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">LockstepReverseIterator</span> <span class="nf">LRI</span><span class="p">(</span><span class="n">BB1</span><span class="p">,</span> <span class="n">BB2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="p">(</span><span class="n">LRI</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">canMergeInstructions</span><span class="p">(</span><span class="o">*</span><span class="n">LRI</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">--</span><span class="n">LRI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Valid iterator  means that a mismatch was found in middle of BB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">LRI</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// It is safe to de-duplicate - do so.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">unsigned</span> <span class="n">UpdatedTargets</span> <span class="o">=</span> <span class="n">updateBranchTargets</span><span class="p">(</span><span class="n">BB1</span><span class="p">,</span> <span class="n">BB2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">assert</span><span class="p">(</span><span class="n">UpdatedTargets</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;No branch target was updated&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">OverallNumOfUpdatedBranchTargets</span> <span class="o">+=</span> <span class="n">UpdatedTargets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">DeleteList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">BB1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">NumDedupBBs</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>前面调用的<code>updateBranchTargets</code>、<code>canMergeInstructions</code>和其调用的<code>canRemoveInst</code></p>
<ul>
<li>其实就是检查 Operator、操作数数量、操作数是否相同</li>
<li><code>canRemoveInst</code>检查指令的唯一使用者（即目的操作数）是否在同一个 Basic Block（不知道什么用意）或是否被后继的 phi 使用（符合 Duplicate 的逻辑），如果二者满足其一则说明指令可删除</li>
<li><code>updateBranchTargets</code>首先调用<code>predecessors</code>获取所有指向要删除的基本块的前驱基本块，然后迭代更新这些前驱基本块的终结指令指向保留的 Basic Block，这样可以将要删除的 Basic Block 从 CFG 中孤立，最后消除死代码的时候可以被消除掉</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">MergeBB</span><span class="o">::</span><span class="n">canRemoveInst</span><span class="p">(</span><span class="k">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">assert</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">hasOneUse</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;Inst needs to have exactly one use&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">*</span><span class="n">PNUse</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">PHINode</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">user_begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">*</span><span class="n">Succ</span> <span class="o">=</span> <span class="n">Inst</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">*</span><span class="n">User</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">user_begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">SameParentBB</span> <span class="o">=</span> <span class="p">(</span><span class="n">User</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="n">Inst</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">UsedInPhi</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNUse</span> <span class="o">&amp;&amp;</span> <span class="n">PNUse</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="n">Succ</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">						<span class="n">PNUse</span><span class="o">-&gt;</span><span class="n">getIncomingValueForBlock</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">())</span> <span class="o">==</span> <span class="n">Inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">UsedInPhi</span> <span class="o">||</span> <span class="n">SameParentBB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">MergeBB</span><span class="o">::</span><span class="n">canMergeInstructions</span><span class="p">(</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Instruction</span> <span class="o">*&gt;</span> <span class="n">Insts</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">Inst1</span> <span class="o">=</span> <span class="n">Insts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">Instruction</span> <span class="o">*</span><span class="n">Inst2</span> <span class="o">=</span> <span class="n">Insts</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Inst1</span><span class="o">-&gt;</span><span class="n">isSameOperationAs</span><span class="p">(</span><span class="n">Inst2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Each instruction must have exactly zero or one use.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">bool</span> <span class="n">HasUse</span> <span class="o">=</span> <span class="o">!</span><span class="n">Inst1</span><span class="o">-&gt;</span><span class="n">user_empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="nl">I</span> <span class="p">:</span> <span class="n">Insts</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">HasUse</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">hasOneUse</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HasUse</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">user_empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Not all instructions that have one use can be merged. Make sure that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// instructions that have one use can be safely deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">HasUse</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">canRemoveInst</span><span class="p">(</span><span class="n">Inst1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">canRemoveInst</span><span class="p">(</span><span class="n">Inst2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Make sure that Inst1 and Inst2 have identical operands.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">assert</span><span class="p">(</span><span class="n">Inst2</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">==</span> <span class="n">Inst1</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">NumOpnds</span> <span class="o">=</span> <span class="n">Inst1</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">OpndIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">OpndIdx</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">OpndIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Inst2</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpndIdx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Inst1</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpndIdx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="n">MergeBB</span><span class="o">::</span><span class="n">updateBranchTargets</span><span class="p">(</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BBToErase</span><span class="p">,</span> <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BBToRetain</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">BBToUpdate</span><span class="p">(</span><span class="n">predecessors</span><span class="p">(</span><span class="n">BBToErase</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;DEDUP BB: merging duplicated blocks (&#34;</span>
</span></span><span class="line"><span class="cl">						<span class="o">&lt;&lt;</span> <span class="n">BBToErase</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; into &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">BBToRetain</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">						<span class="o">&lt;&lt;</span> <span class="s">&#34;)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="n">UpdatedTargetsCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="nl">BB0</span> <span class="p">:</span> <span class="n">BBToUpdate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The terminator is either a branch (conditional or unconditional) or a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// switch statement. One of its targets should be BBToErase. Replace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// that target with BBToRetain.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Instruction</span> <span class="o">*</span><span class="n">Term</span> <span class="o">=</span> <span class="n">BB0</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">OpIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NumOpnds</span> <span class="o">=</span> <span class="n">Term</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">OpIdx</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">OpIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">Term</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpIdx</span><span class="p">)</span> <span class="o">==</span> <span class="n">BBToErase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Term</span><span class="o">-&gt;</span><span class="n">setOperand</span><span class="p">(</span><span class="n">OpIdx</span><span class="p">,</span> <span class="n">BBToRetain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">UpdatedTargetsCount</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">UpdatedTargetsCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="findfcmpeq">FindFCmpEq</h2>
<h3 id="first-taste-10">First Taste</h3>
<p>文档说明有些许问题，按文档运行会发现没输出没报错，后来看 IR 发现 Clang 在 -O0 下处理每个函数时都会带 optnone，给 opt 加参数<code>--debug-pass-manager</code>观察到这会导致 Pass 会跳过函数不进行优化，而开 -O1 虽然能运行 Pass ，但又会将部分代码消除掉影响观感，最后加上<code>-Xclang -disable-O0-optnone</code>后就能正常输出了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -Xclang -disable-O0-optnone -emit-llvm -S -c ../inputs/input_for_fcmp_eq.c -o input_for_fcmp_eq.ll
</span></span><span class="line"><span class="cl">opt-17 --load-pass-plugin ./lib/libFindFCmpEq.so -passes<span class="o">=</span><span class="s2">&#34;print&lt;find-fcmp-eq&gt;&#34;</span> -disable-output input_for_fcmp_eq.ll
</span></span></code></pre></div><p>输出也和文档的描述有所不同，估计是太久没改了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="err">Floating-point</span> <span class="err">equality</span> <span class="err">comparisons</span> <span class="err">in</span> <span class="nl">&#34;sqrt_impl&#34;:</span>
</span></span><span class="line"><span class="cl">  <span class="n">%11</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">oeq</span> <span class="kt">double</span> <span class="n">%9</span><span class="p">,</span> <span class="n">%10</span>
</span></span><span class="line"><span class="cl"><span class="err">Floating-point</span> <span class="err">equality</span> <span class="err">comparisons</span> <span class="err">in</span> <span class="nl">&#34;main&#34;:</span>
</span></span><span class="line"><span class="cl">  <span class="n">%9</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">oeq</span> <span class="kt">double</span> <span class="n">%8</span><span class="p">,</span> <span class="m">1.000000e+00</span>
</span></span><span class="line"><span class="cl">  <span class="n">%13</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">oeq</span> <span class="kt">double</span> <span class="n">%11</span><span class="p">,</span> <span class="n">%12</span>
</span></span><span class="line"><span class="cl">  <span class="n">%19</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">oeq</span> <span class="kt">double</span> <span class="n">%17</span><span class="p">,</span> <span class="n">%18</span>
</span></span></code></pre></div><h3 id="code-analysis-10">Code Analysis</h3>
<p>主体其实是下面这个<code>run</code>，<code>FCmpInst</code>类重载的<code>isEquality</code>方法判定该浮点指令是否是 equal 指令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">FindFCmpEq</span><span class="o">::</span><span class="n">Result</span> <span class="n">FindFCmpEq</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Result</span> <span class="n">Comparisons</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span><span class="nl">Inst</span> <span class="p">:</span> <span class="n">instructions</span><span class="p">(</span><span class="n">Func</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We&#39;re only looking for &#39;fcmp&#39; instructions here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="n">FCmp</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">FCmpInst</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We&#39;ve found an &#39;fcmp&#39; instruction; we need to make sure it&#39;s an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// equality comparison.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">isEquality</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Comparisons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FCmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Comparisons</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>就这么短，没了（）</p>
<h2 id="convertfcmpeq">ConvertFCmpEq</h2>
<h3 id="first-taste-11">First Taste</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">clang-17 -Xclang -disable-O0-optnone -emit-llvm -S -c ../inputs/input_for_fcmp_eq.c -o input_for_fcmp_eq.ll
</span></span><span class="line"><span class="cl">opt-17 --load-pass-plugin ./lib/libFindFCmpEq.so --load-pass-plugin ./lib/libConvertFCmpEq.so -passes<span class="o">=</span>convert-fcmp-eq -S input_for_fcmp_eq.ll -o fcmp_eq_after_conversion.ll
</span></span></code></pre></div><p>运行后，所有<code>fcmp oeq</code>指令都被替换为<code>fcmp olt</code>指令，什么意思呢？看下面的 IR</p>
<ul>
<li>
<p>原来的 IR</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="n">%11</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">oeq</span> <span class="kt">double</span> <span class="n">%9</span><span class="p">,</span> <span class="n">%10</span>
</span></span></code></pre></div></li>
<li>
<p>现在的 IR</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-llvm" data-lang="llvm"><span class="line"><span class="cl"><span class="n">%11</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="n">%9</span><span class="p">,</span> <span class="n">%10</span>
</span></span><span class="line"><span class="cl"><span class="n">%12</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span> <span class="n">%11</span> <span class="k">to</span> <span class="k">i64</span>
</span></span><span class="line"><span class="cl"><span class="n">%13</span> <span class="p">=</span> <span class="k">and</span> <span class="k">i64</span> <span class="n">%12</span><span class="p">,</span> <span class="m">9223372036854775807</span>
</span></span><span class="line"><span class="cl"><span class="n">%14</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i64</span> <span class="n">%13</span> <span class="k">to</span> <span class="kt">double</span>
</span></span><span class="line"><span class="cl"><span class="n">%15</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">olt</span> <span class="kt">double</span> <span class="n">%14</span><span class="p">,</span> <span class="m">0x3CB0000000000000</span>
</span></span></code></pre></div></li>
</ul>
<p>其实就是将<code>a == b</code>改变成了<code>|a - b| &lt;= ε</code>，即将浮点数的绝对相等变成了绝对误差小于<code>ε</code>则认为相等，这里取的误差值<code>0x3CB0000000000000</code>转为双精度浮点数后值为$2^{-52}$（经验证还远没到 double 的精度下限）</p>
<h3 id="code-analysis-11">Code Analysis</h3>
<p><code>run</code>函数内调用了前面的<code>FindFcmpEq</code>，并对结果进行操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">PreservedAnalyses</span> <span class="n">ConvertFCmpEq</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">FunctionAnalysisManager</span> <span class="o">&amp;</span><span class="n">FAM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="o">&amp;</span><span class="n">Comparisons</span> <span class="o">=</span> <span class="n">FAM</span><span class="p">.</span><span class="n">getResult</span><span class="o">&lt;</span><span class="n">FindFCmpEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Modified</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="n">Func</span><span class="p">,</span> <span class="n">Comparisons</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Modified</span> <span class="o">?</span> <span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">none</span><span class="p">()</span> <span class="o">:</span> <span class="n">PreservedAnalyses</span><span class="o">::</span><span class="n">all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">ConvertFCmpEq</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">const</span> <span class="n">FindFCmpEq</span><span class="o">::</span><span class="n">Result</span> <span class="o">&amp;</span><span class="n">Comparisons</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">Modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Functions marked explicitly &#39;optnone&#39; should be ignored since we shouldn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// be changing anything in them anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">Func</span><span class="p">.</span><span class="n">hasFnAttribute</span><span class="p">(</span><span class="n">Attribute</span><span class="o">::</span><span class="n">OptimizeNone</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Ignoring optnone-marked function </span><span class="se">\&#34;</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Func</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">						<span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\&#34;\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">Modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">FCmpInst</span> <span class="o">*</span><span class="nl">FCmp</span> <span class="p">:</span> <span class="n">Comparisons</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">convertFCmpEqInstruction</span><span class="p">(</span><span class="n">FCmp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">++</span><span class="n">FCmpEqConversionCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">Modified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">Modified</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后是<code>convertFCmpEqInstruction</code></p>
<ul>
<li>首先获取左右操作数备用</li>
<li>然后用一个 lambda 将<code>oeq</code>、<code>ueq</code>、<code>one</code>、<code>une</code>做一些对应的替换预备
<ul>
<li><code>o</code>和<code>u</code>的区别在于<code>o</code>的操作数不能是无穷和<code>NaN</code>而<code>u</code>可以</li>
</ul>
</li>
<li>随后准备好要用的对象，比如 module、context、类型、位掩码、<code>ε</code>等</li>
<li>最后建好要替换的 IR Builder，调用<code>setPredicate</code>和<code>setOperand</code>替换指令、设置左右操作数。替换流程如下
<ul>
<li>首先左右操作数相减</li>
<li>然后将差值从 double <code>bitcast</code>转换到 i64，因为浮点数不支持按位与</li>
<li>然后将转换后的差值按位与<code>0x7fffffffffffffff</code>将符号位清零获得绝对值</li>
<li>按位与完的结果重新<code>bitcast</code>回 double</li>
<li>最后用前面第二步中得到的替换用的指令，将<code>ε</code>与结果进行比较，即得结果</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">FCmpInst</span> <span class="o">*</span><span class="nf">convertFCmpEqInstruction</span><span class="p">(</span><span class="n">FCmpInst</span> <span class="o">*</span><span class="n">FCmp</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">assert</span><span class="p">(</span><span class="n">FCmp</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;The given fcmp instruction is null&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">isEquality</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We&#39;re only interested in equality-based comparisons, so return null if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// this comparison isn&#39;t equality-based.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">Value</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Value</span> <span class="o">*</span><span class="n">RHS</span> <span class="o">=</span> <span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Determine the new floating-point comparison predicate based on the current
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span> <span class="n">CmpPred</span> <span class="o">=</span> <span class="p">[</span><span class="n">FCmp</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">(</span><span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">getPredicate</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="nl">FCMP_OEQ</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="n">FCMP_OLT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="nl">FCMP_UEQ</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="n">FCMP_ULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="nl">FCMP_ONE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="n">FCMP_OGE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="nl">FCMP_UNE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="o">::</span><span class="n">FCMP_UGE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&#34;Unsupported fcmp predicate&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create the objects and values needed to perform the equality comparison
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// conversion.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Module</span> <span class="o">*</span><span class="n">M</span> <span class="o">=</span> <span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">getModule</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">assert</span><span class="p">(</span><span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;The given fcmp instruction does not belong to a module&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Ctx</span> <span class="o">=</span> <span class="n">M</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">IntegerType</span> <span class="o">*</span><span class="n">I64Ty</span> <span class="o">=</span> <span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Ctx</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Type</span> <span class="o">*</span><span class="n">DoubleTy</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="n">Ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Define the sign-mask and double-precision machine epsilon constants.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ConstantInt</span> <span class="o">*</span><span class="n">SignMask</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">I64Ty</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// The machine epsilon value for IEEE 754 double-precision values is 2 ^ -52
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// or (b / 2) * b ^ -(p - 1) where b (base) = 2 and p (precision) = 53.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">APInt</span> <span class="n">EpsilonBits</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mh">0x3CB0000000000000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Constant</span> <span class="o">*</span><span class="n">EpsilonValue</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">		<span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">DoubleTy</span><span class="p">,</span> <span class="n">EpsilonBits</span><span class="p">.</span><span class="n">bitsToDouble</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create an IRBuilder with an insertion point set to the given fcmp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">FCmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Create the subtraction, casting, absolute value, and new comparison
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// instructions one at a time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// %0 = fsub double %a, %b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="o">*</span><span class="n">FSubInst</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateFSub</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// %1 = bitcast double %0 to i64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="o">*</span><span class="n">CastToI64</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateBitCast</span><span class="p">(</span><span class="n">FSubInst</span><span class="p">,</span> <span class="n">I64Ty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// %2 = and i64 %1, 0x7fffffffffffffff
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="o">*</span><span class="n">AbsValue</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateAnd</span><span class="p">(</span><span class="n">CastToI64</span><span class="p">,</span> <span class="n">SignMask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// %3 = bitcast i64 %2 to double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="o">*</span><span class="n">CastToDouble</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateBitCast</span><span class="p">(</span><span class="n">AbsValue</span><span class="p">,</span> <span class="n">DoubleTy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// %4 = fcmp &lt;olt/ult/oge/uge&gt; double %3, 0x3cb0000000000000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Rather than creating a new instruction, we&#39;ll just change the predicate and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// operands of the existing fcmp instruction to match what we want.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">setPredicate</span><span class="p">(</span><span class="n">CmpPred</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">setOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">CastToDouble</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">FCmp</span><span class="o">-&gt;</span><span class="n">setOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">EpsilonValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">FCmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="tips">Tips</h2>
<ul>
<li>新的 PM 规定 Transformation Pass 继承自<code>PassInfoMixin</code>，而 Analysis Pass 继承自<code>AnalysisInfoMixin</code></li>
<li>之前我们做的都是 Dynamic Plugin，也就是动态加载的 .so 库，如果想做成静态的就得将 Pass 放进 LLVM Project 的<code>llvm</code>目录下，然后只用指定<code>--passes</code>参数就可以使用了</li>
<li>LLVM 还自带了很多 Pass，不过涉及优化算法大多很复杂，这个 Tutor 也给了一些认为比较适合新人入手的 Pass 和对应的测试文件
<ul>
<li>dce：死代码消除</li>
<li>memcpyopt：针对<code>memcpy</code>的优化，比如用<code>memset</code>替换</li>
<li>reassociate：调换运算表达式（比如交换律、结合律）的顺序以供进一步优化</li>
<li>always-inline：内联那些<code>alwaysinline</code>修饰的函数</li>
<li>loop-deletion：删除未使用的循环</li>
<li>licm：<a href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion">Loop-Invariant Code Motion</a>，循环不变代码外提</li>
<li>slp：<a href="https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer">Superword-level parallelism vectorisation</a>，大概是将可以向量并行化的操作做并行化（SIMD？）</li>
</ul>
</li>
</ul>

            </div>
        </article>





<br>
<script src="https://utteranc.es/client.js"
        repo="ASUKA39/asuka39.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script></main>
</div>
<footer class="footer">
    

    
    
</footer><a href="#" title="Go to top" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    




    
    
        
    

    
    
        
    



    
    <script async src="http://localhost:1313/js/main.js" ></script>

    

</body>
</html>
