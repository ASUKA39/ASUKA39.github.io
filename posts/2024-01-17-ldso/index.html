<!DOCTYPE html>
<html lang="en-gb"><head><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">ld-linux.so 动态链接器加载流程浅析 | a39&#39;s blog</title>
<meta property="og:title" content="ld-linux.so 动态链接器加载流程浅析 | a39&#39;s blog" />
<meta name="twitter:title" content="ld-linux.so 动态链接器加载流程浅析 | a39&#39;s blog" />
<meta itemprop="name" content="ld-linux.so 动态链接器加载流程浅析 | a39&#39;s blog" />
<meta name="application-name" content="ld-linux.so 动态链接器加载流程浅析 | a39&#39;s blog" />
<meta property="og:site_name" content="Awesome hugo blog" />

<meta name="description" content="ld-linux.so 动态链接器加载流程浅析">
<meta itemprop="description" content="ld-linux.so 动态链接器加载流程浅析" />
<meta property="og:description" content="ld-linux.so 动态链接器加载流程浅析" />
<meta name="twitter:description" content="ld-linux.so 动态链接器加载流程浅析" />

<meta property="og:locale" content="en-gb" />
<meta name="language" content="en-gb" />

  <link rel="alternate" hreflang="en-gb" href="https://asuka39.github.io/posts/2024-01-17-ldso/" title="English" />



  <meta itemprop="image" content="https://asuka39.github.io/" />
  <meta property="og:image" content="https://asuka39.github.io/" />
  <meta name="twitter:image" content="https://asuka39.github.io/" />
  <meta name="twitter:image:src" content="https://asuka39.github.io/" />




    
    
    

    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content=2024-01-17T00:00:00Z />
    <meta property="article:published_time" content=2024-01-17T00:00:00Z />

    
    <meta property="og:article:author" content="A39" />
    <meta property="article:author" content="A39" />
    <meta name="author" content="A39" />
    

    

    <script defer type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "ld-linux.so 动态链接器加载流程浅析",
        "author": {
        "@type": "Person",
        "name": ""
        },
        "datePublished": "2024-01-17",
        "description": "ld-linux.so 动态链接器加载流程浅析",
        "wordCount":  10162 ,
        "mainEntityOfPage": "True",
        "dateModified": "2024-01-17",
        "image": {
        "@type": "imageObject",
        "url": ""
        },
        "publisher": {
        "@type": "Organization",
        "name": "a39\u0027s blog"
        }
    }
    </script>


<meta name="generator" content="Hugo 0.124.1">

    

    <link rel="canonical" href="https://asuka39.github.io/posts/2024-01-17-ldso/">
    <link href="/style.min.5029572b12b24c4a875edd2f222bf10b3ff50b930fbfeb59c2602dc9eefff111.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon.ico">
    <link rel="mask-icon" href="/icons/favicon.ico">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="https://asuka39.github.io/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    <meta name="google-site-verification" content="OBu2RkZZmMk9xXDviEo5asuAjsd_8wa5j_4Ii17jFEU" />

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    
    </head>
<body data-theme = "dark" class="notransition">

<script src="/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js" integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="https://asuka39.github.io/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title>Home</title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        Home
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/posts/">
                        Posts
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/about/">
                        About
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/friends/">
                        Friends
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">ld-linux.so 动态链接器加载流程浅析</h1>
                
                
                <div class="post-meta">
                    <time datetime="2024-01-17T00:00:00&#43;00:00" itemprop="datePublished"> 17 Jan 2024 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b>Table of Contents</b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#ldso-加载">ld.so 加载</a></li>
    <li><a href="#参考">参考</a></li>
    <li><a href="#调用栈">调用栈</a></li>
    <li><a href="#相关函数">相关函数</a>
      <ul>
        <li><a href="#_startrtld_start">_start（RTLD_START）</a></li>
        <li><a href="#_dl_start">_dl_start</a>
          <ul>
            <li><a href="#_dl_start_final">_dl_start_final</a></li>
            <li><a href="#_dl_main上半部分">_dl_main（上半部分）</a></li>
            <li><a href="#_dl_main下半部分">_dl_main（下半部分）</a></li>
          </ul>
        </li>
        <li><a href="#_dl_init">_dl_init</a></li>
        <li><a href="#_dl_fini">_dl_fini</a></li>
      </ul>
    </li>
    <li><a href="#ldso-延迟绑定">ld.so 延迟绑定</a></li>
    <li><a href="#延迟绑定机制">延迟绑定机制</a></li>
    <li><a href="#相关函数-1">相关函数</a>
      <ul>
        <li><a href="#_dl_runtime_resolve">_dl_runtime_resolve</a></li>
        <li><a href="#_dl_fixup">_dl_fixup</a></li>
      </ul>
    </li>
    <li><a href="#结构体">结构体</a>
      <ul>
        <li><a href="#ehdrphdr">Ehdr、Phdr</a></li>
        <li><a href="#link_map">link_map</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <h1 id="ld-linuxso-动态链接器加载流程浅析">ld-linux.so 动态链接器加载流程浅析</h1>
<h2 id="ldso-加载">ld.so 加载</h2>
<p>本节讲解 ld.so 刚运行时的加载解析行为</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.csdn.net/conansonic/article/details/54896433">dl_main源码分析（一）</a></li>
<li><a href="https://blog.csdn.net/conansonic/article/details/55536469">dl_main源码分析（二）</a></li>
<li><a href="https://blog.csdn.net/conansonic/article/details/54236335">_dl_start源码分析</a></li>
<li><a href="https://blog.csdn.net/SweeNeil/article/details/83744843">Linux动态库加载函数dlopen源码梳理(一)</a></li>
<li><a href="https://blog.csdn.net/SweeNeil/article/details/83749186">Linux动态库加载函数dlopen源码梳理(二)</a></li>
<li><a href="https://blog.csdn.net/passenger12234/article/details/123806611?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123806611-blog-117436297.235^v40^pc_relevant_3m_sort_dl_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3">动态链接4 程序员的自我修养第八章笔记</a></li>
<li>《程序员的自我修养——链接、装载与库》</li>
</ul>
<h2 id="调用栈">调用栈</h2>
<p>调用栈大致如下，下面只介绍其中一部分较为重要的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">RTLD_START</span><span class="p">()</span>       <span class="p">(</span><span class="nx">sysdeps</span><span class="o">/</span><span class="nx">x86_64</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">machine</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_start</span><span class="p">()</span>         <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">rtld</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">elf_machine_load_addr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">elf_get_dynamic_info</span><span class="p">()</span>          
</span></span><span class="line"><span class="cl">    <span class="nf">ELF_DYNAMIC_RELOCATE</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dynamic</span><span class="o">-</span><span class="nx">link</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">elf_machine_runtime_setup</span><span class="p">()</span>    <span class="p">(</span><span class="nx">sysdeps</span><span class="o">/</span><span class="nx">x86_64</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">machine</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_ELF_DYNAMIC_DO_RELOC</span><span class="p">()</span>      <span class="p">(</span><span class="nx">sysdeps</span><span class="o">/</span><span class="nx">x86_64</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">machine</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">elf_dynamic_do_rel</span><span class="p">()</span>    <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">do</span><span class="o">-</span><span class="nx">rel</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_start_final</span><span class="p">()</span>         <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">rtld</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_sysdep_start</span><span class="p">()</span>      <span class="p">(</span><span class="nx">sysdeps</span><span class="o">/</span><span class="nx">generic</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">sysdeps</span><span class="p">.</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_main</span><span class="p">()</span>        <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">rtld</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">process_envvars</span><span class="p">()</span>     <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">rtld</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">elf_get_dynamic_info</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_setup_hash</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="p">.</span><span class="nx">dl</span><span class="o">-</span><span class="nx">lookup</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_new_object</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">object</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_map_object</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">load</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_map_object_from_fd</span><span class="p">()</span>    <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">load</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="nf">add_name_to_object</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">load</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="nf">_dl_new_object</span><span class="p">()</span>          <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">object</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">map_segment</span><span class="p">()</span>      
</span></span><span class="line"><span class="cl">        <span class="nx">ELF_</span><span class="p">{</span><span class="nx">PREFERED</span><span class="p">,</span><span class="nx">FIXED</span><span class="p">}</span><span class="nf">_ADDRESS</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">        <span class="nf">mprotect</span><span class="p">()</span>      
</span></span><span class="line"><span class="cl">        <span class="nf">munmap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_setup_hash</span><span class="p">()</span>      <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">lookup</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_map_object_deps</span><span class="p">()</span> <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">deps</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">preload</span><span class="p">()</span>    
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_lookup_symbol</span><span class="p">()</span>   <span class="p">(</span><span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">lookup</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">do_lookup</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_relocate_object</span><span class="p">()</span> <span class="p">(</span><span class="nx">loop</span> <span class="nx">in</span> <span class="nx">elf</span><span class="o">/</span><span class="nx">dl</span><span class="o">-</span><span class="nx">reloc</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_start</span><span class="p">()</span>            <span class="p">(</span><span class="nx">main</span> <span class="nx">binary</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="相关函数">相关函数</h2>
<h3 id="_startrtld_start">_start（RTLD_START）</h3>
<p>ld.so 的主程序文件在<code>/elf/rtld.c</code>，其中的<code>_start</code>是由<code>/sysdeps/x86_64/dl-machine.h</code>中所定义的<code>RTLD_START</code>宏实现的内联汇编</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="cm">/* Initial entry point code for the dynamic linker.
</span></span></span><span class="line"><span class="cl"><span class="cm">   The C function `_dl_start&#39; is the real entry point;
</span></span></span><span class="line"><span class="cl"><span class="cm">   its return value is the user program&#39;s entry point.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#define RTLD_START asm (&#34;\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="na">.text</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="na">.align</span> <span class="mi">16</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="na">.globl</span> <span class="no">_start</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="na">.globl</span> <span class="no">_dl_start_user</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="nl">_start:</span><span class="err">\</span><span class="nf">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rdi</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="nf">call</span> <span class="no">_dl_start</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="nl">_dl_start_user:</span><span class="err">\</span><span class="nf">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Save the user entry point address in %r12.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%r12</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Read the original argument count.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdx</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1"># argc -&gt; rsi\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rsi</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Save %rsp value in %r13.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%r13</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># And align stack for the _dl_init call. \n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">andq</span> <span class="no">$-16</span><span class="p">,</span> <span class="nv">%rsp</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># _dl_loaded -&gt; rdi\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="no">_rtld_local</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># env -&gt; rcx\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">leaq</span> <span class="mi">16</span><span class="p">(</span><span class="nv">%r13</span><span class="p">,</span><span class="nv">%rdx</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="nv">%rcx</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># argv -&gt; rdx\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">leaq</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%r13</span><span class="p">),</span> <span class="nv">%rdx</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Clear %rbp to mark outermost frame obviously even for constructors.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">xorl</span> <span class="nv">%ebp</span><span class="p">,</span> <span class="nv">%ebp</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Call the function to run the initializers.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">call</span> <span class="no">_dl_init</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Pass our finalizer function to the user in %rdx, as per ELF ABI.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">leaq</span> <span class="no">_dl_fini</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdx</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># And make sure %rsp points to argc stored on the stack.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%r13</span><span class="p">,</span> <span class="nv">%rsp</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Jump to the user&#39;s entry point.\n\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">jmp</span> <span class="p">*</span><span class="nv">%r12</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="na">.previous</span><span class="err">\</span><span class="no">n</span><span class="err">\</span>
</span></span><span class="line"><span class="cl"><span class="err">&#34;)</span><span class="c1">;
</span></span></span></code></pre></div><ul>
<li><code>_start</code>跳转到<code>_dl_start</code>函数，正式启动 ld.so</li>
<li>保存<code>_dl_start</code>的返回值：用户程序入口点（<code>rax</code>）</li>
<li>从栈中读取参数和环境变量，在栈上设置参数后调用<code>_dl_init</code>进行初始化</li>
<li>保存析构函数<code>_dl_fini</code>的地址，并调整栈指针</li>
<li>最后跳转到用户程序入口点</li>
</ul>
<h3 id="_dl_start">_dl_start</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"># define bootstrap_map GL(dl_rtld_map)
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"># define bootstrap_map info.l
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><ul>
<li>定义后面使用的 <code>bootstrap_map</code> 结构体为 <code>dl_start_final_info</code> 结构体类型，详见下文</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">__attribute_used__</span>
</span></span><span class="line"><span class="cl"><span class="c1">// __attribute_used__ 是 GCC 的特殊属性，表示这个函数是被使用的，避免编译器产生未使用函数的警告
</span></span></span><span class="line"><span class="cl"><span class="c1">// ElfW(Addr) 是一个 ELF 文件地址的宏，可以根据目标平台选择合适的字长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">_dl_start</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">rtld_timer_start</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">struct</span> <span class="n">dl_start_final_info</span> <span class="n">info</span><span class="p">;</span>  <span class="c1">// 结构体 dl_start_final_info 包含一个 link_map 和一个计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 启动一个计时器，并可能初始化 info 结构体中的计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">rtld_timer_start</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><ul>
<li>一些初始化操作</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="cm">/* Partly clean the `bootstrap_map&#39; structure up.  Don&#39;t use
</span></span></span><span class="line"><span class="cl"><span class="cm">   `memset&#39; since it might not be built in or inlined and we cannot
</span></span></span><span class="line"><span class="cl"><span class="cm">   make function calls at this point.  Use &#39;__builtin_memset&#39; if we
</span></span></span><span class="line"><span class="cl"><span class="cm">   know it is available.  We do not have to clear the memory if we
</span></span></span><span class="line"><span class="cl"><span class="cm">   do not have to use the temporary bootstrap_map.  Global variables
</span></span></span><span class="line"><span class="cl"><span class="cm">   are initialized to zero by default.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 清理部分‘bootstrap_map’结构体。不要使用‘memset’，因为它可能不是内置或内联的，
</span></span></span><span class="line"><span class="cl"><span class="cm">  此时我们不能进行函数调用。如果我们知道‘__builtin_memset’可用，
</span></span></span><span class="line"><span class="cl"><span class="cm">  请使用它。如果我们不必使用临时的 bootstrap_map，则不必清除内存。默认情况下，
</span></span></span><span class="line"><span class="cl"><span class="cm">  全局变量初始化为零。*/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"># ifdef HAVE_BUILTIN_MEMSET
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">__builtin_memset</span> <span class="p">(</span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="cp"># else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* bootstrap_map 是动态链接器在这个过程中使用的一个关键数据结构。它表示的是
</span></span></span><span class="line"><span class="cl"><span class="cm">  动态链接器自身在进程地址空间中的映射。这个映射包含了动态链接器的代码和数据，以及动态链接器
</span></span></span><span class="line"><span class="cl"><span class="cm">  需要用来解析符号和重定位的各种表格
</span></span></span><span class="line"><span class="cl"><span class="cm">  在动态链接器的代码中，bootstrap_map 通常被用来查找和解析动态链接器自身的符号，
</span></span></span><span class="line"><span class="cl"><span class="cm">  以及设置其他库的依赖关系。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cnt</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 清零 bootstrap_map.l_info，该结构体用于存储加载动态库的相关信息   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp"># endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><ul>
<li>这里主要清理部分 <code>bootstrap_map</code> 结构体，这个结构体主要记载了动态链接器自身在进程地址空间中的映射，包含了动态链接器的代码和数据，以及动态链接器需要用来解析符号和重定位的各种字段</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Figure out the run-time load address of the dynamic linker itself.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过 elf_machine_load_address 函数获取动态链接器在运行时的加载地址，这个地址是 ld.so 在内存中的起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_addr</span> <span class="o">=</span> <span class="nf">elf_machine_load_address</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Read our own dynamic section and fill in the info array.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算动态段的地址，读取自身的动态段信息，并填充 bootstrap_map 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1">// bootstrap_map.l_ld 存储了动态段的地址，通过 elf_machine_dynamic 计算得到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_ld</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_addr</span> <span class="o">+</span> <span class="nf">elf_machine_dynamic</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// bootstrap_map.l_ld_readonly 被设置为 DL_RO_DYN_SECTION，表示动态段的只读部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_ld_readonly</span> <span class="o">=</span> <span class="n">DL_RO_DYN_SECTION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// elf_get_dynamic_info 函数读取 ld.so 自身的动态段信息，并填充到 bootstrap_map 结构体中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">elf_get_dynamic_info</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bootstrap_map</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>这里主要是 ld.so 的完成自举部分，因为 ld.so 自己是一个解释器程序的同时也是一个动态链接库，所以必须完成自举</li>
<li>首先通过找到自己的 GOT 表，进而定位 dynamic 段，再进一步定位到自己的重定位表和符号表，然后得到自己的重定位入口，完成重定位后才算是自举完成</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 如果 l_addr 不为零或者 DT_GNU_PRELINKED 不存在于动态信息中，执行动态重定位。
</span></span></span><span class="line"><span class="cl"><span class="cm">重定位是将 ld.so 本身进行位置调整，以便进行正常的函数调用和数据访问 */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_addr</span> <span class="o">||</span> <span class="o">!</span> <span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_info</span><span class="p">[</span><span class="nf">VALIDX</span><span class="p">(</span><span class="n">DT_GNU_PRELINKED</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Relocate ourselves so we can do normal function calls and
</span></span></span><span class="line"><span class="cl"><span class="cm">  data access using the global offset table.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 重定位自己，这样就可以使用 GOT 表进行正常的函数调用和数据访问 */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 函数定义在 dynamic-link.h，第一个参数一个参数，表示动态链接器的映射信息，包括动态库的加载地址、动态段信息等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ELF_DYNAMIC_RELOCATE</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bootstrap_map</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// bootstrap_map.l_relocated 被设置为 1，表示 ld.so 已经完成了重定位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">bootstrap_map</span><span class="p">.</span><span class="n">l_relocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Please note that we don&#39;t allow profiling of this object and
</span></span></span><span class="line"><span class="cl"><span class="cm">  therefore need not test whether we have to allocate the array
</span></span></span><span class="line"><span class="cl"><span class="cm">  for the relocation results (as done in dl-reloc.c).  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Now life is sane; we can call functions and access global data.
</span></span></span><span class="line"><span class="cl"><span class="cm">  Set up to use the operating system facilities, and find out from
</span></span></span><span class="line"><span class="cl"><span class="cm">  the operating system&#39;s program loader where to find the program
</span></span></span><span class="line"><span class="cl"><span class="cm">  header table in core.  Put the rest of _dl_start into a separate
</span></span></span><span class="line"><span class="cl"><span class="cm">  function, that way the compiler cannot put accesses to the GOT
</span></span></span><span class="line"><span class="cl"><span class="cm">  before ELF_DYNAMIC_RELOCATE.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 现在变得轻松了；我们可以调用函数并访问全局数据。
</span></span></span><span class="line"><span class="cl"><span class="cm">设置使用操作系统的功能，并从操作系统的程序加载器中获取在核心中找到程序头表的位置。
</span></span></span><span class="line"><span class="cl"><span class="cm">将 _dl_start 的其余部分放入一个单独的函数中，这样编译器就不能在 ELF_DYNAMIC_RELOCATE 
</span></span></span><span class="line"><span class="cl"><span class="cm">之前将对 GOT（全局偏移表）的访问放入其中。 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化与动态内存分配相关的函数，其实就是设置了几个函数指针，比如 __minimal_malloc、__minimal_free 等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">__rtld_malloc_init_stubs</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Do not use an initializer for these members because it would
</span></span></span><span class="line"><span class="cl"><span class="cm">  intefere with __rtld_static_init.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将全局变量 dl_find_object 指向 _dl_find_object 函数，这是一个查找动态库的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">GLRO</span> <span class="p">(</span><span class="n">dl_find_object</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_dl_find_object</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>这里 ld.so 完成自举（Bootstrap）</li>
<li>ld.so 完成自举后就可以随意调用函数、访问全局变量了。在此之前甚至不能随意调用 ld.so 自己的函数，这是因为 ld.so 是以 PIC 模式编译的，也即程序内部的调用也要经过 PLT/GOT 来实现位置无关代码，所以不自举就没法使用任何函数和全局变量</li>
<li>注意这里 libc 还未被映射进内存，所以 ld.so 需要自己实现一套最基本的堆内存操作函数，<code>__rtld_malloc_init_stubs </code>就负责设置相关的函数指针</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">entry</span> <span class="o">=</span> <span class="nf">_dl_start_final</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cm">/* 调用 _dl_start_final 函数，该函数负责完成一些后续的初始化工作，
</span></span></span><span class="line"><span class="cl"><span class="cm">    并返回程序的入口地址 entry */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _dl_start_final 函数的定义在本文件的最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">entry</span> <span class="o">=</span> <span class="nf">_dl_start_final</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef ELF_MACHINE_START_ADDRESS
</span></span></span><span class="line"><span class="cl"><span class="cp"># define ELF_MACHINE_START_ADDRESS(map, start) (start)
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="c1">// 返回程序入口地址，通过宏 ELF_MACHINE_START_ADDRESS 可能对地址进行修正
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 返回值，也即入口地址会被返回到 _start ，然后被保存在 r12 寄存器中，_start 结束后 jmp 到 r12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">ELF_MACHINE_START_ADDRESS</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>最后，调用<code>_dl_start_final</code>后返回要运行的程序的入口地址（用宏来解析<code>_dl_start_final</code>的返回值），返回值（<code>rax</code>）会在<code>_start</code>中被保存到 <code>r12</code> 中，最后直接<code>jmp r12</code>进入程序入口点</li>
</ul>
<h4 id="_dl_start_final">_dl_start_final</h4>
<p>上面的<code>_dl_start</code>在最后调用了这个函数，这个函数算是<code>_dl_start</code>的后半部分，这里对其进行解释</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* This is the second half of _dl_start (below).  It can be inlined safely
</span></span></span><span class="line"><span class="cl"><span class="cm">   under DONT_USE_BOOTSTRAP_MAP, where it is careful not to make any GOT
</span></span></span><span class="line"><span class="cl"><span class="cm">   references.  When the tools don&#39;t permit us to avoid using a GOT entry
</span></span></span><span class="line"><span class="cl"><span class="cm">   for _dl_rtld_global (no attribute_hidden support), we must make sure
</span></span></span><span class="line"><span class="cl"><span class="cm">   this function is not inlined (see below).  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 这是_dl_start的后半部分(如下所示)。它可以在don_use_bootstrap_map下安全地内联，
</span></span></span><span class="line"><span class="cl"><span class="cm">  其中要注意不进行任何GOT表引用。当工具不允许我们避免使用GOT条目
</span></span></span><span class="line"><span class="cl"><span class="cm">  for_dl_rtld_global(不支持ATTRIBUTE_HIDDED)时，我们必须确保该函数没有内联(见下)。*/</span>
</span></span></code></pre></div><ul>
<li>似乎暂时还不能通过 GOT 表来调用函数，暂时不知道具体原因</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">always_inline</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_start_final</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_start_final</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dl_start_final_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">start_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If it hasn&#39;t happen yet record the startup time.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果还没有发生，记录启动时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">rtld_timer_start</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if !defined DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// 将 info-&gt;start_time 设置为 start_time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">RTLD_TIMING_SET</span> <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Transfer data about ourselves to the permanent link_map structure.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将自身的数据传输到永久的 link_map 结构中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">l_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_ld</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">l_ld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_ld_readonly</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">l_ld_readonly</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memcpy</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">l_info</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">sizeof</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_mach</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">l_mach</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_relocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">_dl_setup_hash</span> <span class="p">(</span><span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// _dl_rtld_map 就是动态链接器自身的 link_map 结构，它是一个全局变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_real</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_map_start</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="n">_begin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_map_end</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="n">_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_text_end</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="n">_etext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Copy the TLS related data if necessary.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef DONT_USE_BOOTSTRAP_MAP
</span></span></span><span class="line"><span class="cl"><span class="cp"># if NO_TLS_OFFSET != 0
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_tls_offset</span> <span class="o">=</span> <span class="n">NO_TLS_OFFSET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp"># endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><ul>
<li>函数的开始初始化<code>link_map</code>结构体<code>dl_rtld_map</code>，其对应 ld.so 本身的信息</li>
<li><code>link_map</code> 结构体用于记录所有要动态链接的文件的相关信息，以链表形式串联，<code>main_map</code> 是链表头，用于记录应用程序的链接信息</li>
<li><code>link_map</code> 结构体非常大，具体定义放在了文末</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="cm">/* Initialize the stack end variable.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化栈顶指针为当前栈帧的栈底地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">__libc_stack_end</span> <span class="o">=</span> <span class="nf">__builtin_frame_address</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Call the OS-dependent function to set up life so we can do things like
</span></span></span><span class="line"><span class="cl"><span class="cm">    file access.  It will call `dl_main&#39; (below) to do all the real work
</span></span></span><span class="line"><span class="cl"><span class="cm">    of the dynamic linker, and then unwind our frame and run the user
</span></span></span><span class="line"><span class="cl"><span class="cm">    entry point on the same stack we entered on.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 调用与操作系统相关的函数以建立生命周期，这样我们就可以执行文件访问等操作。
</span></span></span><span class="line"><span class="cl"><span class="cm">  该函数将调用下面的 `dl_main` 函数来执行动态链接器的所有真正工作，
</span></span></span><span class="line"><span class="cl"><span class="cm">  然后解开我们的栈帧并在我们进入的同一栈上运行用户入口点。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">start_addr</span> <span class="o">=</span> <span class="nf">_dl_sysdep_start</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dl_main</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_debug_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DL_DEBUG_STATISTICS</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RTLD_TIMING_VAR</span> <span class="p">(</span><span class="n">rtld_total_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">rtld_timer_stop</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rtld_total_time</span><span class="p">,</span> <span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_statistics</span> <span class="p">(</span><span class="nf">RTLD_TIMING_REF</span><span class="p">(</span><span class="n">rtld_total_time</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">start_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>然后是一些栈的调整，最后调用了 <code>_dl_main</code> 函数</li>
<li>返回值就是要启动的应用程序的入口点，返回给<code>dl_start</code>，最终在<code>_start</code>被调用</li>
</ul>
<h4 id="_dl_main上半部分">_dl_main（上半部分）</h4>
<p><code>_dl_main</code>函数是 ld.so 的主要功能部分，会完成动态库引用解析、管理、映射等工作。这个函数有一千多行，调用栈也很深，所以这里会尽量分段挑重点进行介绍</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">dl_main</span><span class="p">(</span><span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">phdr</span><span class="p">,</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Word</span><span class="p">)</span> <span class="n">phnum</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span> <span class="n">user_entry</span><span class="p">,</span> <span class="nf">ElfW</span><span class="p">(</span><span class="kt">auxv_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">auxv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">main_map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">prelinked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">rtld_is_main</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">tcbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">dl_main_state</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">dl_main_state_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">__tls_pre_init_tp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if !PTHREAD_IN_LIBC
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* The explicit initialization here is cheaper than processing the reloc
</span></span></span><span class="line"><span class="cl"><span class="cm">    in the _rtld_local definition&#39;s initializer.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这里的初始化比在 _rtld_local 定义的初始化器中处理重定位要便宜得多。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_make_stack_executable_hook</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_dl_make_stack_executable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Process the environment variable which control the behaviour.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 处理控制行为的环境变量。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">process_envvars</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span> <span class="c1">// 会设置 GLRO(dl_debug_mask) 的值，用于控制调试信息的输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef HAVE_INLINED_SYSCALLS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Set up a flag which tells we are just starting.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 设置一个标志，告诉我们刚刚开始。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">_dl_starting_up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><ul>
<li>首先是一些声明和初始化</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ld_so_name</span> <span class="o">=</span> <span class="n">_dl_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">user_entry</span> <span class="o">==</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span><span class="n">ENTRY_POINT</span><span class="p">)</span> <span class="c1">// 如果入口地址是 _start，那么说明 ld.so 自己作为独立的程序运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Ho ho.  We are not the program interpreter!  We are the program
</span></span></span><span class="line"><span class="cl"><span class="cm">  itself!  This means someone ran ld.so as a command.  Well, that
</span></span></span><span class="line"><span class="cl"><span class="cm">  might be convenient to do sometimes.  We support it by
</span></span></span><span class="line"><span class="cl"><span class="cm">  interpreting the args like this:
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">  ld.so PROGRAM ARGS...
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">  The first argument is the name of a file containing an ELF
</span></span></span><span class="line"><span class="cl"><span class="cm">  executable we will load and run with the following arguments.
</span></span></span><span class="line"><span class="cl"><span class="cm">  To simplify life here, PROGRAM is searched for using the
</span></span></span><span class="line"><span class="cl"><span class="cm">  normal rules for shared objects, rather than $PATH or anything
</span></span></span><span class="line"><span class="cl"><span class="cm">  like that.  We just load it and use its entry point; we don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="cm">  pay attention to its PT_INTERP command (we are the interpreter
</span></span></span><span class="line"><span class="cl"><span class="cm">  ourselves).  This is an easy way to test a new ld.so before
</span></span></span><span class="line"><span class="cl"><span class="cm">  installing it.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 现在的情况下我们不是程序解释器，我们本身就是一个程序，这意味着可以将 ld.so 是作为一个命令独立运行。
</span></span></span><span class="line"><span class="cl"><span class="cm">  这可能有时很方便。我们通过以下方式解释参数来支持它：ld.so 程序 ARGS...
</span></span></span><span class="line"><span class="cl"><span class="cm">  第一个参数是包含我们将使用以下参数加载和运行的 ELF 可执行文件的文件的名称。
</span></span></span><span class="line"><span class="cl"><span class="cm">  为了简化这里的活动，程序使用共享对象的正常规则进行搜索，而不是 $PATH 或类似的任何内容。
</span></span></span><span class="line"><span class="cl"><span class="cm">  我们只是加载它并使用它的入口点；我们不注意它的 PT_INTERP 命令（我们自己是解释器）。
</span></span></span><span class="line"><span class="cl"><span class="cm">  这是在安装它之前测试新的 ld.so 的简单方法。 */</span>
</span></span><span class="line"><span class="cl"><span class="n">rtld_is_main</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">argv0</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Note the place where the dynamic linker actually came from.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 注意动态链接器实际来自的位置。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_name</span> <span class="o">=</span> <span class="n">rtld_progname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">_dl_argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 解析命令行参数（ld.so 作为单独的程序独立运行）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span> <span class="p">...</span>
</span></span></code></pre></div><ul>
<li>如果程序的入口点等于 ld.so 的入口点，那么说明 ld.so 是作为一个程序独立运行的</li>
<li>前面提到过，ld.so 不仅是一个程序解释器、一个动态链接库，它本身其实也是一个可以独立执行的命令文件，这里主要是关于独立执行的部分，我们无需关心</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">else</span> <span class="c1">// ld.so 作为解释器运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Create a link_map for the executable itself.
</span></span></span><span class="line"><span class="cl"><span class="cm">    This will be what dlopen on &#34;&#34; returns.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 为可执行文件本身创建一个 link_map。这将是 dlopen (“”）返回的内容。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">main_map</span> <span class="o">=</span> <span class="nf">_dl_new_object</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">lt_executable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="c1">// 创建可执行文件的 link_map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">__RTLD_OPENEXEC</span><span class="p">,</span> <span class="n">LM_ID_BASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">assert</span><span class="p">(</span><span class="n">main_map</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_phdr</span> <span class="o">=</span> <span class="n">phdr</span><span class="p">;</span>      <span class="c1">// 设置程序头表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_phnum</span> <span class="o">=</span> <span class="n">phnum</span><span class="p">;</span>      <span class="c1">// 设置程序头表的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">user_entry</span><span class="p">;</span>  <span class="c1">// 设置入口地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Even though the link map is not yet fully initialized we can add
</span></span></span><span class="line"><span class="cl"><span class="cm">    it to the map list since there are no possible users running yet.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 即使 link map 还没有完全初始化，我们也可以将其添加到 map 列表中，因为还没有可能运行的用户。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_add_to_namespace_list</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="n">LM_ID_BASE</span><span class="p">);</span> <span class="c1">// 将可执行文件的 link_map 添加到全局链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="n">main_map</span> <span class="o">==</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* At this point we are in a bit of trouble.  We would have to
</span></span></span><span class="line"><span class="cl"><span class="cm">    fill in the values for l_dev and l_ino.  But in general we
</span></span></span><span class="line"><span class="cl"><span class="cm">    do not know where the file is.  We also do not handle AT_EXECFD
</span></span></span><span class="line"><span class="cl"><span class="cm">    even if it would be passed up.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    We leave the values here defined to 0.  This is normally no
</span></span></span><span class="line"><span class="cl"><span class="cm">    problem as the program code itself is normally no shared
</span></span></span><span class="line"><span class="cl"><span class="cm">    object and therefore cannot be loaded dynamically.  Nothing
</span></span></span><span class="line"><span class="cl"><span class="cm">    prevent the use of dynamic binaries and in these situations
</span></span></span><span class="line"><span class="cl"><span class="cm">    we might get problems.  We might not be able to find out
</span></span></span><span class="line"><span class="cl"><span class="cm">    whether the object is already loaded.  But since there is no
</span></span></span><span class="line"><span class="cl"><span class="cm">    easy way out and because the dynamic binary must also not
</span></span></span><span class="line"><span class="cl"><span class="cm">    have an SONAME we ignore this program for now.  If it becomes
</span></span></span><span class="line"><span class="cl"><span class="cm">    a problem we can force people using SONAMEs.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 在这一点上，我们有点麻烦。我们必须填写 l_dev 和 l_ino 的值。但是一般来说，我们不知道文件在哪里。
</span></span></span><span class="line"><span class="cl"><span class="cm">    我们也不处理 AT_EXECFD，即使它会被传递。我们在这里定义的值为 0。通常这不是问题，因为程序代码本身通常不是共享对象，
</span></span></span><span class="line"><span class="cl"><span class="cm">    因此不能动态加载。没有什么可以阻止使用动态二进制文件，在这些情况下，我们可能会遇到问题。
</span></span></span><span class="line"><span class="cl"><span class="cm">    我们可能无法找出对象是否已加载。但是，由于没有简单的方法，而且动态二进制文件也不能有 SONAME，因此我们暂时忽略此程序。
</span></span></span><span class="line"><span class="cl"><span class="cm">    如果它成为问题，我们可以强制使用 SONAME 的人。 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* We delay initializing the path structure until we got the dynamic
</span></span></span><span class="line"><span class="cl"><span class="cm">    information for the program.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 我们延迟初始化路径结构，直到我们获得程序的动态信息。 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>现在是 ld.so 作为一个程序解释器运行的情况</li>
<li>这里初始化了 <code>link_map</code> 类型的 <code>main_map</code>，记载要加载的应用程序的动态链接信息，然后链接进 <code>link_map</code> 链表中</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">has_interp</span> <span class="o">=</span> <span class="nf">rtld_setup_main_map</span><span class="p">(</span><span class="n">main_map</span><span class="p">);</span> <span class="c1">// 设置可执行文件的 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* If the current libname is different from the SONAME, add the
</span></span></span><span class="line"><span class="cl"><span class="cm">  latter as well.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果当前 libname 与 SONAME 不同，则也将后者添加。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>  <span class="c1">// 如果 ld.so 的 map 的 DT_SONAME 段不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">strcmp</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">D_PTR</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">    <span class="n">l_info</span><span class="p">[</span><span class="n">DT_STRTAB</span><span class="p">])</span> <span class="o">+</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">// 如果 ld.so 的 map 的 DT_SONAME 段的值与 DT_STRTAB 段的值不相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">struct</span> <span class="n">libname_list</span> <span class="n">newname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">newname</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">D_PTR</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">),</span> <span class="n">l_info</span><span class="p">[</span><span class="n">DT_STRTAB</span><span class="p">])</span> <span class="o">+</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">newname</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">newname</span><span class="p">.</span><span class="n">dont_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">assert</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* The ld.so must be relocated since otherwise loading audit modules
</span></span></span><span class="line"><span class="cl"><span class="cm">  will fail since they reuse the very same ld.so.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ld.so 必须被重定位，否则加载审计模块将失败，因为它们重用了同一个 ld.so。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">assert</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_relocated</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><code>DT_SONAME</code>记录了动态库的名字，如果依赖的动态库没有<code>SONAME</code>，那么记录的名字指的是命令行指定的路径</li>
<li>而如果对应的动态库有<code>DT_SONAME</code>项，那么该动态库对应的<code>DT_NEEDED</code>的条目记录的是该动态库的<code>SONAME</code>
<ul>
<li>链接器参数<code>-soname</code>可以用于指定动态库的<code>SONAME</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtld_is_main</span><span class="p">)</span>  <span class="c1">// 如果 ld.so 不是作为独立的程序运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Extract the contents of the dynamic section for easy access.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 提取动态段的内容以便于访问。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">elf_get_dynamic_info</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If the main map is libc.so, update the base namespace to
</span></span></span><span class="line"><span class="cl"><span class="cm">    refer to this map.  If libc.so is loaded later, this happens
</span></span></span><span class="line"><span class="cl"><span class="cm">    in _dl_map_object_from_fd.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果主 map 是 libc.so，则更新基本命名空间以引用此 map。
</span></span></span><span class="line"><span class="cl"><span class="cm">    如果稍后加载 libc.so，则会在 _dl_map_object_from_fd 中发生。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nf">strcmp</span><span class="p">(((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">D_PTR</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="n">l_info</span><span class="p">[</span><span class="n">DT_STRTAB</span><span class="p">])</span> <span class="o">+</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span><span class="p">),</span> <span class="n">LIBC_SO</span><span class="p">)</span>  <span class="c1">// LIBC_SO 即 libc.so.6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1">// 如果要加载的共享对象是 libc.so.6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">libc_map</span> <span class="o">=</span> <span class="n">main_map</span><span class="p">;</span> <span class="c1">// 设置 libc.so 的 map 为 main_map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Set up our cache of pointers into the hash table.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 设置指向哈希表的指针的缓存。 */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 哈希表是用来存储库中的符号的，这里设置指向哈希表的指针的缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">_dl_setup_hash</span><span class="p">(</span><span class="n">main_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>接着开始解析和映射工作，首先看要映射的是不是 glibc，如果是就将 libc 的 <code>link_map</code> 作为 <code>main_map</code>（前面是应用程序的作为 <code>main_map</code>），并获取 hash 节的信息</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">rtld_mode_verify</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* We were called just to verify that this is a dynamic
</span></span></span><span class="line"><span class="cl"><span class="cm">    executable using us as the program interpreter.  Exit with an
</span></span></span><span class="line"><span class="cl"><span class="cm">    error if we were not able to load the binary or no interpreter
</span></span></span><span class="line"><span class="cl"><span class="cm">    is specified (i.e., this is no dynamically linked binary.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们被调用只是为了验证这是一个使用我们作为程序解释器的动态可执行文件。
</span></span></span><span class="line"><span class="cl"><span class="cm">    如果我们无法加载二进制文件或未指定解释器（即，这不是动态链接的二进制文件），则退出错误。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_ld</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 没有 PT_DYNAMIC 段，即没有动态段，说明不是动态链接的二进制文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* We allow here some platform specific code.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们允许这里有一些特定于平台的代码。 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef DISTINGUISH_LIB_VERSIONS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">DISTINGUISH_LIB_VERSIONS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">_exit</span><span class="p">(</span><span class="n">has_interp</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">**</span><span class="n">first_preload</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Set up the data structures for the system-supplied DSO early,
</span></span></span><span class="line"><span class="cl"><span class="cm">    so they can influence _dl_init_paths.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 尽早为系统提供的 DSO 设置数据结构，以便它们可以影响 _dl_init_paths。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">setup_vdso</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_preload</span><span class="p">);</span> <span class="c1">// 设置 vDSO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* With vDSO setup we can initialize the function pointers.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 有了 vDSO 设置，我们可以初始化函数指针。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">setup_vdso_pointers</span><span class="p">();</span>
</span></span></code></pre></div><ul>
<li>这部分应该还是作为独立程序运行的部分，用来验证一个文件是否是动态链接库，下面还有一些关于 vDSO 相关的初始设置，这里我们不关心</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Initialize the data structures for the search paths for shared
</span></span></span><span class="line"><span class="cl"><span class="cm">  objects.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 初始化共享对象搜索路径的数据结构。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">call_init_paths</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>  <span class="c1">// 封装了 _dl_init_paths 函数，用于初始化搜索路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Initialize _r_debug_extended.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 初始化 _r_debug_extended。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">r_debug</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nf">_dl_debug_initialize</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_addr</span><span class="p">,</span> <span class="n">LM_ID_BASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_state</span> <span class="o">=</span> <span class="n">RT_CONSISTENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Put the link_map for ourselves on the chain so it can be found by
</span></span></span><span class="line"><span class="cl"><span class="cm">  name.  Note that at this point the global chain of link maps contains
</span></span></span><span class="line"><span class="cl"><span class="cm">  exactly one element, which is pointed to by dl_loaded.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 将我们自己的 link_map 放在链上，以便可以通过名称找到它。
</span></span></span><span class="line"><span class="cl"><span class="cm">  请注意，此时 link map 的全局链仅包含一个元素，该元素由 dl_loaded 指向。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* If not invoked directly, the dynamic linker shared object file was
</span></span></span><span class="line"><span class="cl"><span class="cm">  found by the PT_INTERP name.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 如果没有直接调用，则动态链接器共享对象文件是通过 PT_INTERP 名称找到的。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">lt_library</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">);</span>    <span class="c1">// 将 ld.so 的 map 放到可执行文件的 map 的后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span> <span class="o">=</span> <span class="n">main_map</span><span class="p">;</span>    <span class="c1">// 设置 ld.so 的 map 的前驱为可执行文件的 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">_ns_nloaded</span><span class="p">;</span>    <span class="c1">// 增加全局命名空间的加载的共享对象的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_load_adds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* If LD_USE_LOAD_BIAS env variable has not been seen, default
</span></span></span><span class="line"><span class="cl"><span class="cm">  to not using bias for non-prelinked PIEs and libraries
</span></span></span><span class="line"><span class="cl"><span class="cm">  and using it for executables or prelinked PIEs or libraries.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 如果没有看到 LD_USE_LOAD_BIAS 环境变量，则默认不使用偏差来加载非预链接的 PIE 和库，
</span></span></span><span class="line"><span class="cl"><span class="cm">  并使用它来加载可执行文件或预链接的 PIE 或库。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_use_load_bias</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_use_load_bias</span><span class="p">)</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Starting from binutils-2.23, the linker will define the magic symbol
</span></span></span><span class="line"><span class="cl"><span class="cm">  __ehdr_start to point to our own ELF header if it is visible in a
</span></span></span><span class="line"><span class="cl"><span class="cm">  segment that also includes the phdrs.  If that&#39;s not available, we use
</span></span></span><span class="line"><span class="cl"><span class="cm">  the old method that assumes the beginning of the file is part of the
</span></span></span><span class="line"><span class="cl"><span class="cm">  lowest-addressed PT_LOAD segment.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 从 binutils-2.23 开始，如果在包含 phdrs 的段中可见，则链接器将定义魔术符号 __ehdr_start 指向我们自己的 ELF 标头。
</span></span></span><span class="line"><span class="cl"><span class="cm">  如果不可用，则使用假设文件开头是最低地址 PT_LOAD 段的一部分的旧方法。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Ehdr</span><span class="p">)</span> <span class="n">__ehdr_start</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="nf">visibility</span><span class="p">(</span><span class="s">&#34;hidden&#34;</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Set up the program header information for the dynamic linker
</span></span></span><span class="line"><span class="cl"><span class="cm">  itself.  It is needed in the dl_iterate_phdr callbacks.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 为动态链接器本身设置程序头信息。它在 dl_iterate_phdr 回调中需要。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Ehdr</span><span class="p">)</span> <span class="o">*</span><span class="n">rtld_ehdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__ehdr_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="n">rtld_ehdr</span><span class="o">-&gt;</span><span class="n">e_ehsize</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">rtld_ehdr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="n">rtld_ehdr</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)</span> <span class="o">*</span><span class="n">rtld_phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rtld_ehdr</span> <span class="o">+</span> <span class="n">rtld_ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_phdr</span> <span class="o">=</span> <span class="n">rtld_phdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_phnum</span> <span class="o">=</span> <span class="n">rtld_ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* PT_GNU_RELRO is usually the last phdr.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* PT_GNU_RELRO 通常是最后一个 phdr。 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">rtld_ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">rtld_phdr</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_GNU_RELRO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_relro_addr</span> <span class="o">=</span> <span class="n">rtld_phdr</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">p_vaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_relro_size</span> <span class="o">=</span> <span class="n">rtld_phdr</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">p_memsz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Add the dynamic linker to the TLS list if it also uses TLS.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 如果动态链接器也使用 TLS，则将其添加到 TLS 列表中。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_tls_blocksize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Assign a module ID.  Do this before loading any audit modules.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 分配一个模块 ID。在加载任何审计模块之前执行此操作。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_assign_tls_modid</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">audit_list_add_dynamic_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">.</span><span class="n">audit_list</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span> <span class="n">DT_AUDIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">audit_list_add_dynamic_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">.</span><span class="n">audit_list</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span> <span class="n">DT_DEPAUDIT</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>首先调用<code>call_init_paths</code>，其封装了<code>_dl_init_paths</code>函数，用于初始化动态链接库的搜索路径数据结构</li>
<li>然后，如果 ld.so 作为程序解释器运行（那么此前<code>GL(dl_rtld_map).l_name</code>并未被设置，以此来判断），此时设置<code>l_name</code>为 ELF 程序的<code>PT_INTERP</code>段给出的 ld.so 的路径，也即<code>l_libname-&gt;name</code></li>
<li>接下来将应用程序对应的 <code>link_map</code>（即 <code>main_map</code>）插入到<code>GL(dl_rtld_map)</code>在链表中的位置之前，然后递增<code>link_namespaces</code>的<code>ns_nloaded</code>和<code>dl_load_adds</code>，表示增加链表中 <code>link_map</code> 的个数</li>
<li>再往下获取 ld.so 的 ELF 头<code>rtld_ehdr</code>和 Segment 头<code>rtld_phdr</code>，将其设置到<code>GL(dl_rtld_map)</code>中，这里的<code>l_map_start</code>是在前面的<code>dl_start_final</code>函数中设置为 <code>_begin</code>，而 <code>_begin</code> 在重定位后指向 ELF 的文件头地址</li>
<li>然后找到 ld.so 中类型为<code>PT_GNU_RELRO</code>的 Segment 头，将其信息设置到<code>dl_rtld_map</code>中，该信息和只读段有关</li>
<li>剩下则是 TLS 和审计相关，这里不关心</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* We have two ways to specify objects to preload: via environment
</span></span></span><span class="line"><span class="cl"><span class="cm">  variable and via the file /etc/ld.so.preload.  The latter can also
</span></span></span><span class="line"><span class="cl"><span class="cm">  be used when security is enabled.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 我们有两种方法可以指定要预加载的对象：通过环境变量和通过文件 /etc/ld.so.preload。
</span></span></span><span class="line"><span class="cl"><span class="cm">  当启用安全性时，也可以使用后者。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="o">*</span><span class="n">first_preload</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">link_map</span> <span class="o">**</span><span class="n">preloads</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npreloads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">preloadlist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="c1">// 如果有预加载的库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">npreloads</span> <span class="o">+=</span> <span class="nf">handle_preload_list</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">preloadlist</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span> <span class="c1">// 加载预加载的库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="s">&#34;LD_PRELOAD&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_accum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">preloadarg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="c1">// 如果有预加载的库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">npreloads</span> <span class="o">+=</span> <span class="nf">handle_preload_list</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">preloadarg</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;--preload&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_accum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>首先查看是否有<code>LD_PRELOAD</code>字段（作为程序解释器时）或<code>--preload</code>命令行参数（作为命令程序时），有的话则说明需要预加载一些动态链接库，于是调用<code>handle_preload_list</code>解析要加载的库，最后在<code>handle_preload_list</code>里会调用<code>do_preload</code>完成预加载
<ul>
<li><code>do_preload</code>的调用栈最后会调用<code>_dl_map_object</code>完成动态链接库的装载，具体会在后面进行分析</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* There usually is no ld.so.preload file, it should only be used
</span></span></span><span class="line"><span class="cl"><span class="cm">  for emergencies and testing.  So the open call etc should usually
</span></span></span><span class="line"><span class="cl"><span class="cm">  fail.  Using access() on a non-existing file is faster than using
</span></span></span><span class="line"><span class="cl"><span class="cm">  open().  So we do this first.  If it succeeds we do almost twice
</span></span></span><span class="line"><span class="cl"><span class="cm">  the work but this does not matter, since it is not for production
</span></span></span><span class="line"><span class="cl"><span class="cm">  use.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 通常没有 ld.so.preload 文件，它应该仅用于紧急情况和测试。因此，打开调用等通常会失败。
</span></span></span><span class="line"><span class="cl"><span class="cm">  在不存在的文件上使用 access() 比使用 open() 更快。所以我们首先这样做。如果成功，我们将做几乎两倍的工作，
</span></span></span><span class="line"><span class="cl"><span class="cm">  但这并不重要，因为它不是用于生产使用。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">preload_file</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;/etc/ld.so.preload&#34;</span><span class="p">;</span> <span class="c1">// 预加载的库的文件路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">__access</span><span class="p">(</span><span class="n">preload_file</span><span class="p">,</span> <span class="n">R_OK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Read the contents of the file.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 读取文件的内容。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">file</span> <span class="o">=</span> <span class="nf">_dl_sysdep_read_whole_file</span><span class="p">(</span><span class="n">preload_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">);</span> <span class="c1">// 读取文件的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">file</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Parse the file.  It contains names of libraries to be loaded,
</span></span></span><span class="line"><span class="cl"><span class="cm">      separated by white spaces or `:&#39;.  It may also contain
</span></span></span><span class="line"><span class="cl"><span class="cm">      comments introduced by `#&#39;.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 解析文件。它包含要加载的库的名称，由空格或 `:` 分隔。它还可以包含由 `#` 引入的注释。 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">problem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">runp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">rest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Eliminate comments.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 消除注释。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">runp</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rest</span> <span class="o">=</span> <span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">rest</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span> <span class="o">=</span> <span class="nf">memchr</span><span class="p">(</span><span class="n">runp</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span><span class="p">,</span> <span class="n">rest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">comment</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">rest</span> <span class="o">-=</span> <span class="n">comment</span> <span class="o">-</span> <span class="n">runp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">comment</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">rest</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*++</span><span class="n">comment</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* We have one problematic case: if we have a name at the end of
</span></span></span><span class="line"><span class="cl"><span class="cm">      the file without a trailing terminating characters, we cannot
</span></span></span><span class="line"><span class="cl"><span class="cm">      place the \0.  Handle the case separately.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们有一个有问题的情况：如果我们在文件末尾有一个没有尾随终止字符的名称，我们无法放置 \0。
</span></span></span><span class="line"><span class="cl"><span class="cm">      单独处理该情况。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">file_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="p">[</span><span class="n">file_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="p">[</span><span class="n">file_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="p">[</span><span class="n">file_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">problem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">[</span><span class="n">file_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="n">problem</span> <span class="o">&gt;</span> <span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">problem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="n">problem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">problem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">problem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">problem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">problem</span> <span class="o">&gt;</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">problem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">problem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">file</span><span class="p">[</span><span class="n">file_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">!=</span> <span class="n">problem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">runp</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="nf">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runp</span><span class="p">,</span> <span class="s">&#34;: </span><span class="se">\t\n</span><span class="s">&#34;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>    <span class="c1">// 取出 LD_PRELOAD 中的路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">npreloads</span> <span class="o">+=</span> <span class="nf">do_preload</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span> <span class="n">preload_file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">problem</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">strndupa</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">file_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">problem</span> <span class="o">-</span> <span class="n">file</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">npreloads</span> <span class="o">+=</span> <span class="nf">do_preload</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">main_map</span><span class="p">,</span> <span class="n">preload_file</span><span class="p">);</span>  <span class="c1">// 装载指定的共享库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">rtld_timer_accum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* We don&#39;t need the file anymore.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们不再需要该文件。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__munmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">file_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>首先调用<code>_dl_sysdep_read_whole_file</code>会打开文件、读取文件信息，并映射文件到内存中，这里目标是<code>/etc/ld.so.preload</code>
<ul>
<li>这个函数会用<code>open64</code>系统调用打开文件，用<code>fstat64</code>读取文件信息（文件大小），然后用<code>mmap</code>系统调用将其映射到内存中（第一个参数是 NULL，即让内核自动选择映射的起始地址），最后关闭 <code>fd</code>，返回 <code>mmap</code> 的指针</li>
</ul>
</li>
<li><code>preloadlist</code>由环境变量<code>LD_PRELOAD</code>指定，由此前的函数<code>process_envvars</code>赋值。接下来复制一份<code>LD_PRELOAD</code>的值到 <code>list</code> 中，然后循环调用<code>strsep</code>，根据分隔符<code>:</code>取出<code>LD_PRELOAD</code>中指定的各个路径</li>
<li>通过<code>do_preload</code>函数装载指定路径<code>p</code>的共享库，<code>npreloads</code>变量最后记录了提前装载的共享库个数
<ul>
<li><code>do_preload</code>里的调用链为：<code>_dl_catch_error</code>-&gt;<code>map_doit</code>-&gt;<code>_dl_map_object</code>，前两个函数都是错误处理、函数封装之类，最后的<code>_dl_map_object</code>才是真正负责装载动态链接库的函数</li>
</ul>
</li>
<li>最后完成一切后调用<code>munmap</code>系统调用解除文件的映射</li>
</ul>
<h5 id="_dl_map_object">_dl_map_object</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Map in the shared object file NAME.  */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从文件中加载共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_map_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">loader</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>    <span class="c1">// loader为main_map，name为共享对象名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trace_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Lmid_t</span> <span class="n">nsid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">origname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">realname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">name_copy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">filebuf</span> <span class="n">fb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">assert</span><span class="p">(</span><span class="n">nsid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">assert</span><span class="p">(</span><span class="n">nsid</span> <span class="o">&lt;</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_nns</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Look for this name among those already loaded.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 查找已经加载的共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">nsid</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_next</span><span class="p">)</span> <span class="c1">// 遍历已经加载的共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* If the requested name matches the soname of a loaded object,
</span></span></span><span class="line"><span class="cl"><span class="cm">    use that object.  Elide this check for names that have not
</span></span></span><span class="line"><span class="cl"><span class="cm">    yet been opened.  */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果请求的名称与已加载对象的soname匹配，则使用该对象。对于尚未打开的名称，省略此检查。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_faked</span> <span class="o">|</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_removed</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">_dl_name_match_p</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">soname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_likely</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_soname_added</span><span class="p">)</span> <span class="o">||</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 如果l_soname_added为1或者l_info[DT_SONAME]为NULL，意思是已经加载过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">soname</span> <span class="o">=</span> <span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nf">D_PTR</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l_info</span><span class="p">[</span><span class="n">DT_STRTAB</span><span class="p">])</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_SONAME</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span><span class="p">);</span> <span class="c1">// 获取soname
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">soname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef __arm__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#34;ld-linux.so.3&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">soname</span><span class="p">,</span> <span class="s">&#34;ld-linux-armhf.so.3&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>          <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* We have a match on a new name -- cache it.  */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 我们在新名称上有一个匹配——缓存它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">add_name_to_object</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// 将name添加到l的名称列表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_soname_added</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">// 设置l_soname_added为1，表示已经加载过了，如果再次遇到那么在上面的if中会跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* We have a match.  */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Display information if we are debugging.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果我们正在调试，则显示信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Give the auditing libraries a chance to change the name before we
</span></span></span><span class="line"><span class="cl"><span class="cm">     try anything.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 在我们尝试任何事情之前，让审计库有机会更改名称。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Will be true if we found a DSO which is of the other ELF class.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果我们找到了另一个ELF类的DSO，则为真。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* DSO是动态共享对象，ELF是可执行和可链接格式 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">found_other_class</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 如果name中不包含/，说明name是一个文件名，而不是路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Search for NAME in several places.  */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在几个地方搜索NAME。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">namelen</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_debug_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DL_DEBUG_LIBS</span><span class="p">))</span> <span class="c1">// 如果是调试模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">_dl_debug_printf</span><span class="p">(</span><span class="s">&#34;find library=%s [%lu]; searching</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nsid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* When the object has the RUNPATH information we don&#39;t use any
</span></span></span><span class="line"><span class="cl"><span class="cm">    RPATHs.  */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当对象具有RUNPATH信息时，我们不使用任何RPATH。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">loader</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">loader</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_RUNPATH</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 如果loader为NULL或者loader的DT_RUNPATH为NULL（DT_RUNPATH是一个动态数组，包含了搜索路径，这个数组是以NULL结尾的）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* This is the executable&#39;s map (if there is one).  Make sure that
</span></span></span><span class="line"><span class="cl"><span class="cm">         we do not look at it twice.  */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 这是可执行文件的映射（如果有的话）。确保我们不会看两次。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">main_map</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">;</span> <span class="c1">// 获取基本命名空间的已加载的共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">bool</span> <span class="n">did_main_map</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>                    <span class="c1">// 标记是否已经加载过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* First try the DT_RPATH of the dependent object that caused NAME
</span></span></span><span class="line"><span class="cl"><span class="cm">         to be loaded.  Then that object&#39;s dependent, and on up.  */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 首先尝试导致加载NAME的依赖对象的DT_RPATH。然后是该对象的依赖对象，以此类推。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">loader</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_loader</span><span class="p">)</span>             <span class="c1">// 遍历loader的依赖对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">cache_rpath</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_rpath_dirs</span><span class="p">,</span> <span class="n">DT_RPATH</span><span class="p">,</span> <span class="s">&#34;RPATH&#34;</span><span class="p">))</span> <span class="c1">// 如果l的DT_RPATH不为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">fd</span> <span class="o">=</span> <span class="nf">open_path</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="c1">// 尝试打开name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_rpath_dirs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="o">&amp;</span><span class="n">realname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fb</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">LA_SER_RUNPATH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="o">&amp;</span><span class="n">found_other_class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">did_main_map</span> <span class="o">|=</span> <span class="n">l</span> <span class="o">==</span> <span class="n">main_map</span><span class="p">;</span> <span class="c1">// 标记是否已经加载过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* If dynamically linked, try the DT_RPATH of the executable
</span></span></span><span class="line"><span class="cl"><span class="cm">         itself.  NB: we do this for lookups in any namespace.  */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果动态链接，请尝试可执行文件本身的DT_RPATH。注意：我们对任何命名空间中的查找都这样做。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">did_main_map</span>  <span class="c1">// 如果还没有加载过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">&amp;&amp;</span> <span class="n">main_map</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">lt_loaded</span> <span class="c1">// 如果main_map不为NULL且main_map的类型不为lt_loaded，意思是main_map还没有加载过，main_map是可执行文件，而不是共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">&amp;&amp;</span> <span class="nf">cache_rpath</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_rpath_dirs</span><span class="p">,</span> <span class="n">DT_RPATH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;RPATH&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="nf">open_path</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="c1">// 尝试打开name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="o">&amp;</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_rpath_dirs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="o">&amp;</span><span class="n">realname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fb</span><span class="p">,</span> <span class="n">loader</span> <span class="o">?:</span> <span class="n">main_map</span><span class="p">,</span> <span class="n">LA_SER_RUNPATH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="o">&amp;</span><span class="n">found_other_class</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><code>_dl_map_object</code>函数就是正式开始根据动态链接库名<code>name</code>查找并加载动态链接库了</li>
<li><code>dl_map_object</code>函数首先循环遍历，检查将要加载的共享库是否已经加载进内存中，也即存在于全局链表<code>dl_ns</code>中
<ul>
<li>循环内部先检查已经加载的共享库对应的 <code>link_map</code> 结构的<code>l_faked</code>和<code>l_removed</code>变量，如果被置位，则继续循环，否则通过<code>_dl_name_match_p</code> 函数查找已经加载的共享库中是否包含了路径 <code>name</code>，如果包含了，直接返回了加载的共享库对应的 <code>link_map</code></li>
<li>然后比较查找的路径 <code>name</code> 是否和某个共享库的 <code>soname</code> 相等，如果相等，则将该 <code>soname</code> 插入到对应共享库 <code>link_map</code> 结构的 <code>l_libname</code> 链表中，并返回对应的 <code>link_map</code> 结构，否则继续循环，直到遍历完所有已经加载的共享库
<ul>
<li><code>soname</code> 是考虑兼容方便为动态链接库起的简短名称，使用 readelf 工具可以查看</li>
</ul>
</li>
</ul>
</li>
<li>退出循环则说明路径 <code>name</code> 对应的共享库还未被加载过，此时就要根据该路径将共享库加载到内存中
<ul>
<li>首先判断路径 <code>name</code> 是否只包含了共享库名，不包含路径信息，即该路径不包含<code>\</code></li>
<li>如果 <code>name</code> 只包含了共享库名，那么首先检查执行该函数的共享库对应的 dynamic 段中，<code>RUNPATH</code>位置上是否为空，如果为空则只需要检查<code>RPATH</code>对应的信息（<code>RUNPATH</code>优先级更高）</li>
</ul>
</li>
<li>此时首先遍历执行该操作的共享库以及其父共享库
<ul>
<li>通过<code>cache_rpath</code>函数从字符串表中提取 dynamic 段的<code>DT_RPATH</code>对应的搜索路径，并保存到对应 <code>link_map</code> 结构，也即 <code>loader</code> 的 <code>l_rpath_dirs</code> 变量中</li>
<li>紧接着通过<code>open_path</code>函数在刚刚得到的搜索路径<code>l_rpath_dirs</code>下查找并打开共享库 <code>name</code>，如果成功打开了文件，返回文件描述符 <code>fd</code>，并将共享库的完整路径保存在<code>realname</code>，文件内容保存在缓冲区<code>fb</code>中
<ul>
<li><code>open_path</code>函数会根据路径信息打开共享库文件</li>
<li>首先会遍历共享库的搜索目录，也即已经加载的共享库对应的 <code>link_map</code> 结构中的<code>l_rpath_dirs</code></li>
<li>然后通过<code>__mempcpy</code>函数复制每个共享库的搜索目录名到 <code>buf</code> 中</li>
<li>接下来遍历 <code>capstr</code> 数组中的所有值，数组大小为<code>ncapstr</code>，该数组的值和计算机硬件有关</li>
<li>取得 <code>capstr</code> 数组中的值后，就将其值追加到 <code>buf</code> 之后，再追加共享库名 <code>name</code>，至此 <code>buf</code> 中就保存了共享库的完整路径</li>
<li>然后通过<code>open_verify</code>函数根据刚刚得到的共享库路径 <code>buf</code> 打开共享库，获得文件描述符 <code>fd</code>，并将文件中的内容拷贝到 <code>fb</code>
<ul>
<li><code>open_verify</code>函数除了打开文件，另一个功能就是验证该文件是否为 ELF 格式的文件</li>
</ul>
</li>
<li>如果成功打开了文件，就拷贝完整的共享库路径 <code>buf</code>到传入的地址 <code>realname</code> 中，并返回文件标识 <code>fd</code></li>
</ul>
</li>
<li>如果根据参数找不到共享库 <code>name</code>，就从应用程序对应的 <code>link_map</code>（即 <code>main_map</code>）中再查找一次。<code>did_main_map</code>用于标识参数 <code>loader</code> 和全局的 <code>main_map</code> 是否为同一个 <code>link_map</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* The path may contain dynamic string tokens.  */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 路径可能包含动态字符串令牌。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">realname</span> <span class="o">=</span> <span class="p">(</span><span class="n">loader</span>
</span></span><span class="line"><span class="cl">            <span class="o">?</span> <span class="nf">expand_dynamic_string_token</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">:</span> <span class="nf">__strdup</span><span class="p">(</span><span class="n">name</span><span class="p">));</span> <span class="c1">// 如果loader不为NULL，那么尝试将name中的动态字符串令牌替换为实际的值，如果loader为NULL，那么直接复制name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">realname</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">fd</span> <span class="o">=</span> <span class="nf">open_verify</span><span class="p">(</span><span class="n">realname</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fb</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">loader</span> <span class="o">?:</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">nsid</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="o">&amp;</span><span class="n">found_other_class</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">realname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">stack_end</span> <span class="o">=</span> <span class="n">__libc_stack_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">_dl_map_object_from_fd</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">origname</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fb</span><span class="p">,</span> <span class="n">realname</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">type</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack_end</span><span class="p">,</span> <span class="n">nsid</span><span class="p">);</span> <span class="c1">// 根据fd将共享对象加载到内存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>后面的逻辑与前面类似，同样是按不同的优先级解析和加载动态链接库，代码比较长，这里不全部贴出</li>
<li>如果前面没有找到共享库文件，这里的代码继续在别的搜索路径下查找，首先找<code>LD_LIBRARY_PATH</code>，然后轮到 dynamic 段中获取<code>DT_RUNPATH</code>对应的搜索路径，在然后到<code>ld.so.cache</code>文件中匹配，最后就在系统的默认路径<code>system_dirs</code>下查找</li>
<li>最后的 else 对应前面看 <code>name</code> 里有没有<code>\</code>的判断，如果有就表示 <code>name</code> 包含了路径信息，对 <code>name</code> 一番操作后直接调用<code>open_verify</code>，这个函数会打开并验证文件是否为 ELF 文件</li>
<li>最后调用<code>_dl_map_object_from_fd</code>函数，处理打开的动态链接库<code>fd</code>，并将存放了文件内容的缓冲区<code>fb</code>映射进内存</li>
</ul>
<h6 id="_dl_map_object_from_fd">_dl_map_object_from_fd</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Map in the shared object NAME, actually located in REALNAME, and already
</span></span></span><span class="line"><span class="cl"><span class="cm">   opened on FD.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 将共享对象NAME映射到内存中，实际上位于REALNAME，已经打开在FD上 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef EXTERNAL_MAP_FROM_FD
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_map_object_from_fd</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">origname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="k">struct</span> <span class="n">filebuf</span> <span class="o">*</span><span class="n">fbp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">realname</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">loader</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="kt">void</span> <span class="o">**</span><span class="n">stack_endp</span><span class="p">,</span> <span class="n">Lmid_t</span> <span class="n">nsid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Ehdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">header</span><span class="p">;</span> <span class="c1">// Ehdr ELF文件头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">phdr</span><span class="p">;</span>   <span class="c1">// Phdr ELF程序头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">ph</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">maplength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Initialize to keep the compiler happy.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 初始化，编译时少点warning */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">errval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_debug</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nf">_dl_debug_update</span><span class="p">(</span><span class="n">nsid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">make_consistent</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Get file information.  To match the kernel behavior, do not fill
</span></span></span><span class="line"><span class="cl"><span class="cm">     in this information for the executable in case of an explicit
</span></span></span><span class="line"><span class="cl"><span class="cm">     loader invocation.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 获取文件信息。为了匹配内核行为，在显式加载器调用的情况下不要为可执行文件填写此信息。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_file_id</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">__RTLD_OPENEXEC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">nsid</span> <span class="o">==</span> <span class="n">LM_ID_BASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>  <span class="c1">// 获取文件信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">_dl_get_file_id</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;cannot stat shared object&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nl">lose_errno</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">errval</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nl">lose</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* The file might already be closed.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 文件可能已经关闭了 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">__close_nocancel</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">_dl_unmap_segments</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_origin</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_origin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">dont_free</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_libname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phdr_allocated</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phdr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">free</span><span class="p">(</span><span class="n">realname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">make_consistent</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_state</span> <span class="o">=</span> <span class="n">RT_CONSISTENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">_dl_debug_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LIBC_PROBE</span><span class="p">(</span><span class="n">map_failed</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nsid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_signal_error</span><span class="p">(</span><span class="n">errval</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">errstring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Look again to see if the real name matched another already loaded.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 再次查看真实名称是否与另一个已加载的名称匹配。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">nsid</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">;</span> <span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_removed</span> <span class="o">&amp;&amp;</span> <span class="nf">_dl_file_id_match_p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_file_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* The object is already loaded.
</span></span></span><span class="line"><span class="cl"><span class="cm">           Just bump its reference count and return it.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 对象已经加载。只需增加其引用计数并返回它。 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">__close_nocancel</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* If the name is not in the list of names for this object add
</span></span></span><span class="line"><span class="cl"><span class="cm">           it.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果名称不在此对象的名称列表中，请将其添加。 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">realname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add_name_to_object</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* When loading into a namespace other than the base one we must
</span></span></span><span class="line"><span class="cl"><span class="cm">     avoid loading ld.so since there can only be one copy.  Ever.  */</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">RTLD_NOLOAD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* We are not supposed to load the object unless it is already
</span></span></span><span class="line"><span class="cl"><span class="cm">     loaded.  So return now.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们不应该加载对象，除非它已经加载。所以现在返回。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">realname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__close_nocancel</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Print debugging message.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 打印调试消息。 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* This is the ELF header.  We read it in `open_verify&#39;.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这是ELF头。我们在“open_verify”中读取它。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fbp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>    <span class="c1">// 设置文件头，buf 中存有整个文件，所以起始位置就是 ELF header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Enter the new object in the list of loaded objects.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 将新对象输入到已加载对象的列表中。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">l</span> <span class="o">=</span> <span class="nf">_dl_new_object</span><span class="p">(</span><span class="n">realname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">l_type</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nsid</span><span class="p">);</span>     <span class="c1">// 创建新的link_map结构体，承载新加载的共享对象的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nl">fail_new</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;cannot create shared object descriptor&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">lose_errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Extract the remaining details we need from the ELF header
</span></span></span><span class="line"><span class="cl"><span class="cm">     and then read in the program header table.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 从ELF头中提取我们需要的其余细节，然后读取程序头表。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_entry</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span> <span class="c1">// 入口地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">type</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_type</span><span class="p">;</span>      <span class="c1">// 文件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phnum</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span> <span class="c1">// 程序头表中的条目数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">maplength</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">));</span>   <span class="c1">// maplength为程序头表的大小，即程序头表中的条目数 * 每个条目的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phoff</span> <span class="o">+</span> <span class="n">maplength</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">fbp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="c1">// 如果程序头表的偏移量 + 程序头表的大小 &lt;= 文件长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">fbp</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>   <span class="c1">// 则程序头表在文件中的位置为文件的起始地址 + 程序头表的偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">phdr</span> <span class="o">=</span> <span class="nf">alloca</span><span class="p">(</span><span class="n">maplength</span><span class="p">);</span> <span class="c1">// 否则，分配maplength大小的空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="nf">__pread64_nocancel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">phdr</span><span class="p">,</span> <span class="n">maplength</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">)</span> <span class="o">!=</span> <span class="n">maplength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;cannot read file data&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">lose_errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* On most platforms presume that PT_GNU_STACK is absent and the stack is
</span></span></span><span class="line"><span class="cl"><span class="cm">   * executable.  Other platforms default to a nonexecutable stack and don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="cm">   * need PT_GNU_STACK to do so.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 在大多数平台上，假设PT_GNU_STACK不存在，堆栈是可执行的。其他平台默认为不可执行的堆栈，不需要PT_GNU_STACK来执行此操作。 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint_fast16_t</span> <span class="n">stack_flags</span> <span class="o">=</span> <span class="n">DEFAULT_STACK_PERMS</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>首先根据 <code>fd</code> 获取文件的详细信息</li>
<li>接下来再次遍历确认所有已经加载到内存中的共享库对应的结构 <code>link_map</code>，如果刚刚读出的信息和该 <code>link_map</code> 中的对应字段相等，则表示该动态链接库已经加载到内存中了，此时直接返回其 <code>link_map</code> 结构<code>l</code>即可</li>
<li>再往下将前面打开的文件内容<code>buf</code>赋值给文件头指针<code>header</code>，因为前面是通过<code>open_verify</code>函数打开并验证共享库文件，还将文件内容拷贝进了<code>buf</code>，因此此时<code>header</code>指向的位置就是<code>buf</code>中的 ELF 文件头</li>
<li>接下来通过<code>_dl_new_object</code>函数为刚刚打开的共享库创建对应的 <code>link_map</code> 结构，注意这里传入的参数<code>realname</code>为共享库的完整路径，<code>name</code>为共享库名，<code>loader</code>为 <code>main_map</code>（即应用程序自身对应的 <code>link_map</code> 结构）</li>
<li>创建完 <code>link_map</code> 结构体后，设置入口点<code>l_entry</code>、文件类型<code>e_type</code>（重定位文件、可执行文件、共享文件）、程序头的个数<code>l_phnum</code>，计算用来保存所有程序头的内存需要分配的大小<code>maplength</code>
<ul>
<li>如果缓存足够大，则只要移动缓存中的指针就行了，否则需要<code>seek</code>文件指针，重新读取数据到新分配的缓存中</li>
<li>无论哪种情况，最终的 Segment 头的起始地址指针保存在变量<code>phdr</code>中</li>
</ul>
</li>
<li>最后设置栈内存的属性<code>stack_flags</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Scan the program header table, collecting its load commands.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 扫描程序头表，收集其加载命令。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">loadcmd</span> <span class="n">loadcmds</span><span class="p">[</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phnum</span><span class="p">];</span> <span class="c1">// loadcmds为加载命令数组，大小为程序头表中的条目数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">nloadcmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// 加载命令的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">has_holes</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>         <span class="c1">// 是否有空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">empty_dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>       <span class="c1">// empty_dynamic为true表示动态段为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">p_align_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// 最大对齐值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* The struct is initialized to zero so this is not necessary:
</span></span></span><span class="line"><span class="cl"><span class="cm">  l-&gt;l_ld = 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">  l-&gt;l_phdr = 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">  l-&gt;l_addr = 0; */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">ph</span> <span class="o">=</span> <span class="n">phdr</span><span class="p">;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">phdr</span><span class="p">[</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phnum</span><span class="p">];</span> <span class="o">++</span><span class="n">ph</span><span class="p">)</span> <span class="c1">// 遍历程序头表，ph为程序头表中的每个条目，每个条目记载了一个段的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* These entries tell us where to find things once the file&#39;s
</span></span></span><span class="line"><span class="cl"><span class="cm">         segments are mapped in.  We record the addresses it says
</span></span></span><span class="line"><span class="cl"><span class="cm">         verbatim, and later correct for the run-time load address.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 这些条目告诉我们在文件段映射后在哪里找到这些条目。我们记录它说的地址，稍后根据运行时加载地址进行更正。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_DYNAMIC</span><span class="p">:</span> <span class="c1">// 若段类型为动态段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">empty_dynamic</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* Usually separate debuginfo.  */</span> <span class="c1">// 通常是单独的debuginfo。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Debuginfo only files from &#34;objcopy --only-keep-debug&#34;
</span></span></span><span class="line"><span class="cl"><span class="cm">        contain a PT_DYNAMIC segment with p_filesz == 0.  Skip
</span></span></span><span class="line"><span class="cl"><span class="cm">        such a segment to avoid a crash later.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 仅包含“objcopy --only-keep-debug”中的debuginfo的文件包含
</span></span></span><span class="line"><span class="cl"><span class="cm">        具有p_filesz == 0的PT_DYNAMIC段。跳过这样的段以避免以后崩溃。 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_ld</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_ldnum</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_ld_readonly</span> <span class="o">=</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_W</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_PHDR</span><span class="p">:</span> <span class="c1">// 若段类型为程序头表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_phdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_LOAD</span><span class="p">:</span> <span class="c1">// 若段类型为加载段，加载段用于在内存和文件中根据p_align对齐各段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="cm">/* A load command tells us to map in part of the file.
</span></span></span><span class="line"><span class="cl"><span class="cm">         We record the load commands and process them all later.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 加载命令告诉我们映射文件的一部分。我们记录加载命令并稍后处理它们。 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(((</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;ELF load command address/offset not page-aligned&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="n">loadcmd</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loadcmds</span><span class="p">[</span><span class="n">nloadcmds</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span> <span class="o">=</span> <span class="nf">ALIGN_DOWN</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">,</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">));</span>       <span class="c1">// mapstart为段在内存中的起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span> <span class="o">=</span> <span class="nf">ALIGN_UP</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">,</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">));</span> <span class="c1">// mapend为段在内存中的结束地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">dataend</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">;</span>               <span class="c1">// dataend为段在内存中的结束地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">allocend</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">;</span>               <span class="c1">// allocend为段在内存中的结束地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="cm">/* Remember the maximum p_align.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 记住最大p_align。 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">powerof2</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_align</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_align</span> <span class="o">&gt;</span> <span class="n">p_align_max</span><span class="p">)</span> <span class="c1">// 判断p_align是否是2的幂，且大于p_align_max。p_align用于在内存和文件中根据该值对齐各段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p_align_max</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_align</span><span class="p">;</span>  <span class="c1">// 如果是2的幂，且大于p_align_max，则将p_align_max赋值为ph-&gt;p_align
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="c1">// 每个段的p_align都不一样，但是p_align_max是所有段中p_align的最大值，只需要对齐p_align_max即可满足所有段的对齐要求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapoff</span> <span class="o">=</span> <span class="nf">ALIGN_DOWN</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* Determine whether there is a gap between the last segment
</span></span></span><span class="line"><span class="cl"><span class="cm">         and this one.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 确定最后一个段和这个段之间是否有间隙。 */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 间隙是由于段的p_align不一样，导致段之间的空间不够对齐，因此需要填充空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">nloadcmds</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">mapend</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span><span class="p">)</span> <span class="c1">// 若有多个段，且前一个段的结束地址 != 当前段的开始地址，说明中间存在空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">has_holes</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                <span class="c1">// 若有空洞，则has_holes为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Optimize a common case.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 优化常见情况。 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if (PF_R | PF_W | PF_X) == 7 &amp;&amp; (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="p">(</span><span class="n">PF_TO_PROT</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PF_R</span> <span class="o">|</span> <span class="n">PF_W</span> <span class="o">|</span> <span class="n">PF_X</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_R</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_READ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_W</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_X</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_TLS</span><span class="p">:</span> <span class="c1">// 若段类型为TLS段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">...</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_GNU_STACK</span><span class="p">:</span> <span class="c1">// 若段类型为GNU_STACK段，该段用于设置栈的权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">stack_flags</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">PT_GNU_RELRO</span><span class="p">:</span> <span class="c1">// 若段类型为GNU_RELRO段，该段用于只读重定位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_relro_addr</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_relro_size</span> <span class="o">=</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">nloadcmds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* This only happens for a bogus object that will be caught with
</span></span></span><span class="line"><span class="cl"><span class="cm">       another error below.  But we don&#39;t want to go through the
</span></span></span><span class="line"><span class="cl"><span class="cm">       calculations below using NLOADCMDS - 1.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 这只发生在一个错误的对象上，该对象将在下面的另一个错误中被捕获。但是我们不想使用NLOADCMDS - 1进行下面的计算。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;object file has no loadable segments&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Align all PT_LOAD segments to the maximum p_align.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 将所有PT_LOAD段对齐到最大p_align。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloadcmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">loadcmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mapalign</span> <span class="o">=</span> <span class="n">p_align_max</span><span class="p">;</span> <span class="c1">// 对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* dlopen of an executable is not valid because it is not possible
</span></span></span><span class="line"><span class="cl"><span class="cm">     to perform proper relocations, handle static TLS, or run the
</span></span></span><span class="line"><span class="cl"><span class="cm">     ELF constructors.  For PIE, the check needs the dynamic
</span></span></span><span class="line"><span class="cl"><span class="cm">     section, so there is another check below.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 对可执行文件的dlopen无效，因为不可能执行正确的重定位，处理静态TLS或运行ELF构造函数。
</span></span></span><span class="line"><span class="cl"><span class="cm">    对于PIE，检查需要动态节，因此下面还有另一个检查。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ET_DYN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">__RTLD_OPENEXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* This object is loaded at a fixed address.  This must never
</span></span></span><span class="line"><span class="cl"><span class="cm">       happen for objects loaded with dlopen.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 此对象以固定地址加载。这对于使用dlopen加载的对象绝不能发生。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;cannot dynamically load executable&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* This check recognizes most separate debuginfo files.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 此检查识别大多数单独的调试信息文件。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_ld</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">)</span> <span class="o">||</span> <span class="n">empty_dynamic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">errstring</span> <span class="o">=</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;object file has no dynamic section&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Length of the sections to be loaded.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 要加载的段的长度。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">maplength</span> <span class="o">=</span> <span class="n">loadcmds</span><span class="p">[</span><span class="n">nloadcmds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">allocend</span> <span class="o">-</span> <span class="n">loadcmds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mapstart</span><span class="p">;</span> <span class="c1">// maplength = 最后一个段的结束地址 - 第一个段的开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Now process the load commands and map segments into memory.
</span></span></span><span class="line"><span class="cl"><span class="cm">     This is responsible for filling in:
</span></span></span><span class="line"><span class="cl"><span class="cm">     l_map_start, l_map_end, l_addr, l_contiguous, l_text_end, l_phdr
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 现在处理加载命令并将段映射到内存中。这负责填写：
</span></span></span><span class="line"><span class="cl"><span class="cm">  l_map_start，l_map_end，l_addr，l_contiguous，l_text_end，l_phdr */</span>
</span></span><span class="line"><span class="cl">  <span class="n">errstring</span> <span class="o">=</span> <span class="nf">_dl_map_segments</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">loadcmds</span><span class="p">,</span> <span class="n">nloadcmds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">maplength</span><span class="p">,</span> <span class="n">has_holes</span><span class="p">,</span> <span class="n">loader</span><span class="p">);</span> <span class="c1">// 映射段到内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">errstring</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>          <span class="c1">// 若映射失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Mappings can be in an inconsistent state: avoid unmap.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 映射可能处于不一致的状态：避免取消映射。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 将l_map_start和l_map_end置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>               <span class="c1">// 失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>前面我们获得了指向 Segment 头的<code>phdr</code>指针，接下来就从<code>phdr</code>开始遍历动态链接库的每个 Segment
<ul>
<li>如果 Segment 的类型为<code>PT_DYNAMIC</code>，则设置<code>l_ld</code>为 dynamic 段的装载地址（注意这里都不是实际的装载地址），设置<code>l_ldnum</code>为 dynamic 段中项的个数</li>
<li>如果 Segment 的类型为<code>PT_PHDR</code>，则设置 Segment 头的起始地址<code>l_phdr</code></li>
<li>如果 Segment 的类型为<code>PT_LOAD</code>，则设置<code>mapstart</code>、<code>mapend</code>为该 Segment 的装载起始地址和结束地址，注意这里执行了对齐操作，<code>dataend</code>为文件映像的结束地址，<code>allocend</code>为内存映像的结束地址，<code>mapoff</code>为文件起始地址。最后设置该 Segment 的权限<code>prot</code>。如果当前段的起始地址<code>mapstart</code>和前一个段的结束地址不相等，则两个段不连续，设置<code>has_holes</code>为<code>true</code>，后面需要设置空洞部分的权限</li>
<li>接下来省略的代码处理<code>PT_TLS</code>、<code>PT_GNU_STACK</code>和<code>PT_GNU_RELRO</code></li>
</ul>
</li>
<li><code>maplength</code>为所有类型为<code>PT_LOAD</code>的 Segment 占用的内存大小</li>
<li>最后调用<code>_dl_map_segments</code>函数，计算将要<code>mmap</code>的起始地址<code>mappref</code>，然后通过<code>mmap</code>系统调用将共享库文件中的内容加载的内存中，下面会对这个函数进行分析</li>
</ul>
<h6 id="_dl_map_segments--_dl_map_segment">_dl_map_segments &amp; _dl_map_segment</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Map a segment and align it properly.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 映射一个段并对齐它。 */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 在_dl_map_segments中调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_map_segment</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">loadcmd</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">mappref</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="k">const</span> <span class="kt">size_t</span> <span class="n">maplength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_likely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mapalign</span> <span class="o">&lt;=</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)))</span>   <span class="c1">// 如果段对齐 &lt;= 页大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span><span class="nf">__mmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mappref</span><span class="p">,</span> <span class="n">maplength</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">,</span>  <span class="c1">// 调用mmap系统调用将段映射到内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">MAP_COPY</span> <span class="o">|</span> <span class="n">MAP_FILE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapoff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If the segment alignment &gt; the page size, allocate enough space to
</span></span></span><span class="line"><span class="cl"><span class="cm">    ensure that the segment can be properly aligned.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果段对齐 &gt; 页大小，则分配足够的空间以确保段可以正确对齐。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">maplen</span> <span class="o">=</span> <span class="p">(</span><span class="n">maplength</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapalign</span> <span class="c1">// 如果maplength &gt;= mapalign，maplen = maplength，否则maplen = maplength + mapalign
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="o">?</span> <span class="p">(</span><span class="n">maplength</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapalign</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapalign</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">map_start</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span><span class="nf">__mmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mappref</span><span class="p">,</span> <span class="n">maplen</span><span class="p">,</span>  <span class="c1">// 调用mmap系统调用将段映射到内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">PROT_NONE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_start</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">map_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">map_start_aligned</span> <span class="o">=</span> <span class="nf">ALIGN_UP</span><span class="p">(</span><span class="n">map_start</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapalign</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">map_start_aligned</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span><span class="nf">__mmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_start_aligned</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">maplength</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">MAP_COPY</span> <span class="o">|</span> <span class="n">MAP_FILE</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">fd</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapoff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_start_aligned</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_start</span><span class="p">,</span> <span class="n">maplen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Unmap the unused regions.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 取消映射未使用的区域。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">map_start_aligned</span> <span class="o">-</span> <span class="n">map_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_start</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">map_end</span> <span class="o">=</span> <span class="n">map_start_aligned</span> <span class="o">+</span> <span class="n">maplength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">map_end</span> <span class="o">=</span> <span class="nf">ALIGN_UP</span><span class="p">(</span><span class="n">map_end</span><span class="p">,</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">delta</span> <span class="o">=</span> <span class="n">map_start</span> <span class="o">+</span> <span class="n">maplen</span> <span class="o">-</span> <span class="n">map_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map_end</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">map_start_aligned</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* This implementation assumes (as does the corresponding implementation
</span></span></span><span class="line"><span class="cl"><span class="cm">   of _dl_unmap_segments, in dl-unmap-segments.h) that shared objects
</span></span></span><span class="line"><span class="cl"><span class="cm">   are always laid out with all segments contiguous (or with gaps
</span></span></span><span class="line"><span class="cl"><span class="cm">   between them small enough that it&#39;s preferable to reserve all whole
</span></span></span><span class="line"><span class="cl"><span class="cm">   pages inside the gaps with PROT_NONE mappings rather than permitting
</span></span></span><span class="line"><span class="cl"><span class="cm">   other use of those parts of the address space).  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 此实现假定（与 dl-unmap-segments.h 中的 _dl_unmap_segments 的相应实现一样），
</span></span></span><span class="line"><span class="cl"><span class="cm">   共享对象总是以所有段连续的方式布局（或者在它们之间的间隙足够小，以至于最好保留间隙内
</span></span></span><span class="line"><span class="cl"><span class="cm">   所有整页的 PROT_NONE 映射，而不是允许地址空间的这些部分的其他用途）。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_map_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Ehdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>  <span class="c1">// ELF头部、共享库类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">const</span> <span class="k">struct</span> <span class="n">loadcmd</span> <span class="n">loadcmds</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">nloadcmds</span><span class="p">,</span> <span class="c1">// 加载命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">const</span> <span class="kt">size_t</span> <span class="n">maplength</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_holes</span><span class="p">,</span>  <span class="c1">// 映射长度、是否有空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">loader</span><span class="p">)</span>  <span class="c1">// 需要加载的动态库的link_map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">struct</span> <span class="n">loadcmd</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">loadcmds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_likely</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">))</span>   <span class="c1">// 如果是动态库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* This is a position-independent shared object.  We can let the
</span></span></span><span class="line"><span class="cl"><span class="cm">    kernel map it anywhere it likes, but we must have space for all
</span></span></span><span class="line"><span class="cl"><span class="cm">    the segments in their specified positions relative to the first.
</span></span></span><span class="line"><span class="cl"><span class="cm">    So we map the first segment without MAP_FIXED, but with its
</span></span></span><span class="line"><span class="cl"><span class="cm">    extent increased to cover all the segments.  Then we remove
</span></span></span><span class="line"><span class="cl"><span class="cm">    access from excess portion, and there is known sufficient space
</span></span></span><span class="line"><span class="cl"><span class="cm">    there to remap from the later segments.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    As a refinement, sometimes we have an address that we would
</span></span></span><span class="line"><span class="cl"><span class="cm">    prefer to map such objects at; but this is only a preference,
</span></span></span><span class="line"><span class="cl"><span class="cm">    the OS can do whatever it likes. */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 这是一个位置无关的共享对象。我们可以让内核将其映射到任何位置，但是我们必须为所有段
</span></span></span><span class="line"><span class="cl"><span class="cm">    在其相对于第一个段的指定位置上保留空间。因此，我们将第一个段映射到一个没有
</span></span></span><span class="line"><span class="cl"><span class="cm">    MAP_FIXED 的地址，但是其范围扩展到覆盖所有段。然后我们从多余的部分删除访问权限，
</span></span></span><span class="line"><span class="cl"><span class="cm">    并且已知在那里有足够的空间从后面的段重新映射。
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    作为一个细节，有时我们有一个地址，我们希望在这个地址上映射这样的对象；但是这只是
</span></span></span><span class="line"><span class="cl"><span class="cm">    一个偏好，操作系统可以做任何它想做的事情。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">mappref</span>  <span class="c1">// 计算出的映射的首选地址（绝对地址）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">=</span> <span class="p">(</span><span class="nf">ELF_PREFERRED_ADDRESS</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">maplength</span><span class="p">,</span>   <span class="c1">// 除非在powerPC平台，ELF_PREFERRED_ADDRESS都返回第三个参数，一般情况下计算结果是NULL，到mmap时还是让内核决定加载地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span> <span class="o">&amp;</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_use_load_bias</span><span class="p">))</span> <span class="o">-</span>  <span class="c1">// 是否使用加载偏移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">MAP_BASE_ADDR</span><span class="p">(</span><span class="n">l</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Remember which part of the address space this object uses.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 记录该对象使用的地址空间的哪一部分。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">=</span> <span class="nf">_dl_map_segment</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mappref</span><span class="p">,</span> <span class="n">maplength</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span> <span class="c1">// 调用_dl_map_segment映射段到内存，返回映射的首地址到l_map_start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">))</span>  <span class="c1">// 映射失败与否
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">DL_MAP_SEGMENTS_ERROR_MAP_SEGMENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_end</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">+</span> <span class="n">maplength</span><span class="p">;</span> <span class="c1">// 记录映射的结束地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span><span class="p">;</span>  <span class="c1">// 记录映射的起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">has_holes</span><span class="p">)</span> <span class="c1">// 如果映射空间存在空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Change protection on the excess portion to disallow all access;
</span></span></span><span class="line"><span class="cl"><span class="cm">      the portions we do not remap later will be inaccessible as if
</span></span></span><span class="line"><span class="cl"><span class="cm">      unallocated.  Then jump into the normal segment-mapping loop to
</span></span></span><span class="line"><span class="cl"><span class="cm">      handle the portion of the segment past the end of the file
</span></span></span><span class="line"><span class="cl"><span class="cm">      mapping.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 将多余部分的保护更改为禁止所有访问；我们稍后不重新映射的部分将无法访问，就像未分配一样。
</span></span></span><span class="line"><span class="cl"><span class="cm">      然后跳转到正常的段映射循环中，以处理超出文件映射结束的段的部分。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">loadcmds</span><span class="p">[</span><span class="n">nloadcmds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">mapstart</span> <span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">              <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">N_</span><span class="p">(</span><span class="s">&#34;ELF load command address/offset not page-aligned&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">__mprotect</span><span class="p">((</span><span class="kt">caddr_t</span><span class="p">)(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span><span class="p">),</span> <span class="c1">// 使用mprotect系统调用将空洞更改为禁止访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">loadcmds</span><span class="p">[</span><span class="n">nloadcmds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">mapstart</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">PROT_NONE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">DL_MAP_SEGMENTS_ERROR_MPROTECT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_contiguous</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 表示映射是连续的，没有空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">postmap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Remember which part of the address space this object uses.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 记录该对象使用的地址空间的哪一部分。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span><span class="p">;</span>  <span class="c1">// 记录映射的起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_end</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_map_start</span> <span class="o">+</span> <span class="n">maplength</span><span class="p">;</span>  <span class="c1">// 记录映射的结束地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_contiguous</span> <span class="o">=</span> <span class="o">!</span><span class="n">has_holes</span><span class="p">;</span>        <span class="c1">// 记录映射是否连续（是否存在空洞）
</span></span></span></code></pre></div><ul>
<li><code>_dl_map_segments</code>调用了<code>_dl_map_segment</code>，所以这里依照<code>_dl_map_segments</code>的流程讲解</li>
<li>首先计算将要<code>mmap</code>的起始地址<code>mappref</code>，然后通过<code>_dl_map_segment</code>调用<code>mmap</code>将共享库文件中的内容加载的内存中，最后返回实际内存中的起始地址<code>l_map_start</code>
<ul>
<li>只要不是 PowerPC 平台，<code>mappref</code>默认就是 0（NULL），其在随后<code>mmap</code>的时候作为第一个参数，所以最终还是由内核来决定这第一个 Segment 的起始映射地址</li>
<li>这里只装载了共享库文件的第一个<code>PT_LOAD</code>类型的 Segment，但是分配了足够的空间，后面会通过循环在这段空间上继续<code>mmap</code>，为剩余的<code>PT_LOAD</code>类型的 Segment 分配空间</li>
</ul>
</li>
<li>然后再计算内存中装载的程序段的结束地址<code>l_map_end</code>和整个 ELF 文件的装载地址<code>l_addr</code>（这是一个虚拟的值，用于后面计算偏移，实际只是装载了类型为<code>PT_LOAD</code>类型的 Segment）</li>
<li>如果存在不连续的 Segment（也即<code>has_holes</code>为真），则要把第一个 Segment 的结束地址到最后一个 Segment 的起始地址这部分的内存属性设置为<code>PROT_NONE</code>，也即不允许进行内存访问</li>
<li>最后跳到<code>postmap</code>处继续执行，<code>postmap</code>在 while 循环内部，执行完后会重新跳到循环开始处执行循环语句</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">loadcmds</span><span class="p">[</span><span class="n">nloadcmds</span><span class="p">])</span> <span class="c1">// 遍历加载命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Map the segment contents from the file.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 从文件映射段内容。 */</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">__mmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span><span class="p">),</span> <span class="c1">// 调用mmap系统调用将段映射到内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapend</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">MAP_FIXED</span> <span class="o">|</span> <span class="n">MAP_COPY</span> <span class="o">|</span> <span class="n">MAP_FILE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">fd</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapoff</span><span class="p">)</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">DL_MAP_SEGMENTS_ERROR_MAP_SEGMENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nl">postmap</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_postprocess_loadcmd</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 调用_dl_postprocess_loadcmd处理加载命令，设置权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">allocend</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dataend</span><span class="p">)</span> <span class="c1">// 如果段的分配结束地址大于数据结束地址，表示这里为 bss 段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Extra zero pages should appear at the end of this segment,
</span></span></span><span class="line"><span class="cl"><span class="cm">        after the data mapped from the file.   */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 零页应该出现在该段的末尾，在从文件映射的数据之后。 */</span>
</span></span><span class="line"><span class="cl">      <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">zero</span><span class="p">,</span> <span class="n">zeroend</span><span class="p">,</span> <span class="n">zeropage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">zero</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dataend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">zeroend</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">allocend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">zeropage</span> <span class="o">=</span> <span class="p">((</span><span class="n">zero</span> <span class="o">+</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">zeroend</span> <span class="o">&lt;</span> <span class="n">zeropage</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* All the extra data is in the last page of the segment.
</span></span></span><span class="line"><span class="cl"><span class="cm">        We can just zero it.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 所有额外的数据都在段的最后一页中。我们可以将其置零。 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">zeropage</span> <span class="o">=</span> <span class="n">zeroend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">zeropage</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Zero the final part of the last page of the segment.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 将段的最后一页的最后一部分置零。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Dag nab it.  */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">__mprotect</span><span class="p">((</span><span class="kt">caddr_t</span><span class="p">)(</span><span class="n">zero</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 使用mprotect系统调用将空洞更改为禁止访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">return</span> <span class="n">DL_MAP_SEGMENTS_ERROR_MPROTECT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">zero</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">zeropage</span> <span class="o">-</span> <span class="n">zero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">__mprotect</span><span class="p">((</span><span class="kt">caddr_t</span><span class="p">)(</span><span class="n">zero</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="c1">// 使用mprotect系统调用将空洞更改为禁止访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">zeroend</span> <span class="o">&gt;</span> <span class="n">zeropage</span><span class="p">)</span> <span class="c1">// 如果段的分配结束地址大于数据结束地址，如果是表示中间存在空洞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Map the remaining zero pages in from the zero fill FD.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 从零填充 FD 中映射剩余的零页。 */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">caddr_t</span> <span class="n">mapat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mapat</span> <span class="o">=</span> <span class="nf">__mmap</span><span class="p">((</span><span class="kt">caddr_t</span><span class="p">)</span><span class="n">zeropage</span><span class="p">,</span> <span class="n">zeroend</span> <span class="o">-</span> <span class="n">zeropage</span><span class="p">,</span> <span class="c1">// 调用mmap系统调用将空洞映射到内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">c</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">,</span> <span class="n">MAP_ANON</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">mapat</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">DL_MAP_SEGMENTS_ERROR_MAP_ZERO_FILL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Notify ELF_PREFERRED_ADDRESS that we have to load this one
</span></span></span><span class="line"><span class="cl"><span class="cm">    fixed.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 通知 ELF_PREFERRED_ADDRESS 我们必须固定加载这个。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ELF_FIXED_ADDRESS</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mapstart</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>前面提到，<code>postmap</code>在 while 循环内部，也就是说<code>postmap</code>部分执行完后会跳到循环开始处，而循环刚开始处就有一段<code>mmap</code>来映射 Segment
<ul>
<li><code>mmap</code>的<code>MAP_FIXED</code>参数表示建立映射的起始地址必须是<code>l-&gt;l_addr + c-&gt;mapstart</code></li>
</ul>
</li>
<li><code>_dl_postprocess_loadcmd</code>会识别标志位，若为<code>PROT_EXEC</code>（即可执行），则可以断定该 Segment 为 text 段，设置 text 段的结束地址<code>l_text_end</code></li>
<li>然后，如果<code>allocend</code>大于<code>dataend</code>，即 ELF 文件的<code>filesz</code>小于<code>memsz</code>，则判断<code>dataend</code>到<code>allocend</code>这段区域为 bss 段，因此下面要初始化该段，将该段对应的内存清 0</li>
<li>接下来设置 <code>zero</code> 为 bss 段的起始地址，<code>zeroend</code> 为 bss 段的结束地址，<code>zeropage</code> 为 zero 的值向上取整
<ul>
<li>如果<code>zeroend</code>小于<code>zeropage</code>，则 bss 段的起始地址和结束地址在同一个页面内，此时只要将<code>zero</code>至<code>zeroend</code>这段内存清 0 就行了。但是如果这段内存没有写权限<code>PROT_WRITE</code>（因为前面很可能将这段内存的权限设置为<code>PROT_NONE</code>），则要通过<code>mprotect</code>为这部分内存添加写权限，然后通过<code>memset</code>函数将这段内存清 0，完成后再调用一次<code>mprotect</code>函数恢复这段内存的原始权限</li>
<li>如果<code>zeroend</code>大于<code>zeropage</code>，则<code>zeropage</code>至<code>zeroend</code>还没有分配虚拟内存，此时继续通过<code>mmap</code>分配虚拟内存。注意前面<code>mmap</code>函数创建的都是文件映射，此时的标志位<code>MAP_ANON</code>，即创建匿名映射，因为<code>zeropage</code>至<code>zeroend</code>这段内存对应 bss 段，而 bss 段不真正存在于 ELF 文件中，只是被加载时通过<code>filesz</code>和<code>memsz</code>的差来决定其大小</li>
<li>最后，如果<code>l_ld</code>为 0，而 ELF 类型为<code>ET_DYN</code>，则说明该共享库没有 dynamic 段，此时发生错误，否则将<code>l_ld</code>重定位，即加上前面计算的 ELF 文件的实际装载地址<code>l_addr</code></li>
</ul>
</li>
</ul>
<h4 id="_dl_main下半部分">_dl_main（下半部分）</h4>
<p>回到<code>_dl_main</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">first_preload</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="c1">// 如果有预加载的库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Set up PRELOADS with a vector of the preloaded libraries.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 使用预加载的库的向量设置 PRELOADS。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">first_preload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">preloads</span> <span class="o">=</span> <span class="nf">__alloca</span><span class="p">(</span><span class="n">npreloads</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="n">preloads</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">preloads</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">npreloads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef NEED_DL_SYSINFO_DSO
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Now that the audit modules are opened, call la_objopen for the vDSO.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 现在已经打开了审计模块，调用 la_objopen 来打开 vDSO。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_audit_objopen</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">),</span> <span class="n">LM_ID_BASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Load all the libraries specified by DT_NEEDED entries.  If LD_PRELOAD
</span></span></span><span class="line"><span class="cl"><span class="cm">    specified some libraries to load, these are inserted before the actual
</span></span></span><span class="line"><span class="cl"><span class="cm">    dependencies in the executable&#39;s searchlist for symbol resolution.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 加载 DT_NEEDED 条目指定的所有库。如果 LD_PRELOAD 指定要加载一些库，则将这些库插入到可执行文件的搜索列表中，
</span></span></span><span class="line"><span class="cl"><span class="cm">    以便在符号解析中插入实际依赖项。 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_map_object_deps</span><span class="p">(</span><span class="n">main_map</span><span class="p">,</span> <span class="n">preloads</span><span class="p">,</span> <span class="n">npreloads</span><span class="p">,</span>  <span class="c1">// 分析可执行文件的依赖项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">state</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">rtld_mode_trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">rtld_timer_accum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>程序运行到这里时，全局的 link_map 列表（即<code>dl_ns[LM_ID_BASE]</code>里的第一个位置）存放的是要加载的应用程序对应的 link_map（也即前面的 main_map），第二个位置存放的是 ld.so 对应的 link_map，也即<code>dl_rtld_map</code>，第三个位置开始存放的是前面预加载的共享库对应的link_map。而此时<code>first_preload</code>指向的是第一个预加载共享库 link_map 的起始指针</li>
<li>这段代码首先分配<code>npreloads</code>个预加载的 link_map 指针大小的空间<code>preloads</code>，然后将刚刚预加载的共享库对应的 link_map 结构指针存入<code>preloads</code>数组中，最后调用<code>_dl_map_object_deps</code>开始处理共享库间的依赖关系
<ul>
<li><code>_dl_map_object_deps</code>这个函数涉及使用算法来分析动态链接库的依赖关系，比较复杂，后续如果需要再单独进行分析</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="cm">/* Mark all objects as being in the global scope.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 将所有对象标记为处于全局范围。 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span>
</span></span><span class="line"><span class="cl">    <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_list</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">l_global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Remove _dl_rtld_map from the chain.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 从链中删除 _dl_rtld_map。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="o">-&gt;</span><span class="n">l_next</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="o">-&gt;</span><span class="n">l_prev</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">rtld_multiple_ref</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_likely</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Some DT_NEEDED entry referred to the interpreter object itself, so
</span></span></span><span class="line"><span class="cl"><span class="cm">    put it back in the list of visible objects.  We insert it into the
</span></span></span><span class="line"><span class="cl"><span class="cm">    chain in symbol search order because gdb uses the chain&#39;s order as
</span></span></span><span class="line"><span class="cl"><span class="cm">    its symbol search order.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 一些 DT_NEEDED 条目引用了解释器对象本身，因此将其放回可见对象的列表中。
</span></span></span><span class="line"><span class="cl"><span class="cm">    我们按符号搜索顺序将其插入到链中，因为 gdb 使用链的顺序作为其符号搜索顺序。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtld_multiple_ref</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_list</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_likely</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">rtld_mode_normal</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span>
</span></span><span class="line"><span class="cl">                      <span class="o">?</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                      <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef NEED_DL_SYSINFO_DSO
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="k">if</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="o">-&gt;</span><span class="n">l_next</span> <span class="o">==</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                      <span class="o">&amp;&amp;</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span> <span class="o">!=</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span> <span class="o">=</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_sysinfo_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* In trace mode there might be an invisible object (which we
</span></span></span><span class="line"><span class="cl"><span class="cm">        could not find) after the previous one in the search list.
</span></span></span><span class="line"><span class="cl"><span class="cm">        In this case it doesn&#39;t matter much where we put the
</span></span></span><span class="line"><span class="cl"><span class="cm">        interpreter object, so we just initialize the list pointer so
</span></span></span><span class="line"><span class="cl"><span class="cm">        that the assertion below holds.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 在跟踪模式下，搜索列表中的前一个对象后可能有一个不可见的对象（我们找不到）。
</span></span></span><span class="line"><span class="cl"><span class="cm">        在这种情况下，我们放置解释器对象并不重要，因此我们只需初始化列表指针，以便下面的断言成立。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="o">-&gt;</span><span class="n">l_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="o">-&gt;</span><span class="n">l_next</span> <span class="o">==</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="o">-&gt;</span><span class="n">l_next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">assert</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="o">-&gt;</span><span class="n">l_prev</span> <span class="o">==</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_next</span><span class="o">-&gt;</span><span class="n">l_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Now let us see whether all libraries are available in the
</span></span></span><span class="line"><span class="cl"><span class="cm">    versions we need.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 现在让我们看看所有库是否都在我们需要的版本中可用。 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">version_check_args</span> <span class="n">args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">args</span><span class="p">.</span><span class="n">doexit</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">rtld_mode_normal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">args</span><span class="p">.</span><span class="n">dotrace</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">rtld_mode_trace</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_receive_error</span><span class="p">(</span><span class="n">print_missing_version</span><span class="p">,</span> <span class="n">version_check_doit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>首先将 main_map 依赖的所有共享库的<code>l_global</code>置位，标识为全局</li>
<li>接下来将 ld.so 自身的 link_map，也即<code>dl_rtld_map</code>从全局链表<code>dl_ns</code>中移除。由于依赖的共享库<code>l_searchlist.r_list</code>数组的第一个项为 main_map 自身，因此<code>i</code>从 1 开始，查找其依赖的共享库是否包含了 ld.so。接下来，如果<code>i</code>小于<code>r_nlist</code>，则表示应用程序 main_map 依赖的共享库包含了解释器 ld.so 自身，这时将 ld.so 的 link_map 结构<code>dl_rtld_map</code>重新插入到全局链表 <code>dl_ns</code> 中去</li>
<li><code>version_check_doit</code>函数从 main_map 开始，向后遍历所有的共享库<code>link_map</code>，通过<code>_dl_check_map_versions</code>检查其符号信息</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Now we have all the objects loaded.  Relocate them all except for
</span></span></span><span class="line"><span class="cl"><span class="cm">  the dynamic linker itself.  We do this in reverse order so that copy
</span></span></span><span class="line"><span class="cl"><span class="cm">  relocs of earlier objects overwrite the data written by later
</span></span></span><span class="line"><span class="cl"><span class="cm">  objects.  We do not re-relocate the dynamic linker itself in this
</span></span></span><span class="line"><span class="cl"><span class="cm">  loop because that could result in the GOT entries for functions we
</span></span></span><span class="line"><span class="cl"><span class="cm">  call being changed, and that would break us.  It is safe to relocate
</span></span></span><span class="line"><span class="cl"><span class="cm">  the dynamic linker out of order because it has no copy relocs (we
</span></span></span><span class="line"><span class="cl"><span class="cm">  know that because it is self-contained).  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 现在我们已经加载了所有对象。重新定位它们，除了动态链接器本身。我们以相反的顺序执行此操作，
</span></span></span><span class="line"><span class="cl"><span class="cm">  以便较早对象的复制重定位覆盖稍后对象写入的数据。在此循环中，我们不会重新定位动态链接器本身，
</span></span></span><span class="line"><span class="cl"><span class="cm">  因为这可能导致我们调用的函数的 GOT 条目发生更改，这将使我们中断。可以安全地重新定位动态链接器，
</span></span></span><span class="line"><span class="cl"><span class="cm">  因为它没有复制重定位（我们知道这一点，因为它是自包含的）。 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">consider_profiling</span> <span class="o">=</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_profile</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If we are profiling we also must do lazy reloaction.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果我们正在进行分析，我们还必须进行延迟重定位。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_lazy</span><span class="p">)</span> <span class="o">|=</span> <span class="n">consider_profiling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_initfini</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* While we are at it, help the memory handling a bit.  We have to
</span></span></span><span class="line"><span class="cl"><span class="cm">      mark some data structures as allocated with the fake malloc()
</span></span></span><span class="line"><span class="cl"><span class="cm">      implementation in ld.so.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 当我们在处理它时，帮助内存处理一点。我们必须将某些数据结构标记为使用 ld.so 中的伪 malloc() 实现分配。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">libname_list</span> <span class="o">*</span><span class="n">lnp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_libname</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">__builtin_expect</span><span class="p">(</span><span class="n">lnp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">lnp</span><span class="o">-&gt;</span><span class="n">dont_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">lnp</span> <span class="o">=</span> <span class="n">lnp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Also allocated with the fake malloc().  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 也使用伪 malloc() 分配。 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_free_initfini</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_relocate_object</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_scope</span><span class="p">,</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_lazy</span><span class="p">)</span> <span class="o">?</span> <span class="nl">RTLD_LAZY</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">consider_profiling</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Add object to slot information data if necessasy.  */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果需要，将对象添加到槽信息数据中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_tls_blocksize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tls_init_tp_called</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_add_to_slotinfo</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">rtld_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">relocate_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Now enable profiling if needed.  Like the previous call,
</span></span></span><span class="line"><span class="cl"><span class="cm">    this has to go here because the calls it makes should use the
</span></span></span><span class="line"><span class="cl"><span class="cm">    rtld versions of the functions (particularly calloc()), but it
</span></span></span><span class="line"><span class="cl"><span class="cm">    needs to have _dl_profile_map set up by the relocator.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 现在根据需要启用分析。与前面的调用一样，这必须放在这里，因为它所做的调用应该使用函数的 rtld 版本
</span></span></span><span class="line"><span class="cl"><span class="cm">    （特别是 calloc()），但它需要由重定位器设置 _dl_profile_map。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_profile_map</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* We must prepare the profiling.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 我们必须准备分析。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_dl_start_profile</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>这部分代码首先设置一些全局变量，然后遍历应用程序 main_map 依赖的共享库（除了 ld.so，因为前面在<code>dl_start</code>函数中已经自己对自己进行了重定位了），调用<code>dl_relocate_object</code>对每个动态链接库进行重定位</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prelinked</span> <span class="o">&amp;&amp;</span> <span class="n">rtld_multiple_ref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* There was an explicit ref to the dynamic linker as a shared lib.
</span></span></span><span class="line"><span class="cl"><span class="cm">  Re-relocate ourselves with user-controlled symbol definitions.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">  We must do this after TLS initialization in case after this
</span></span></span><span class="line"><span class="cl"><span class="cm">  re-relocation, we might call a user-supplied function
</span></span></span><span class="line"><span class="cl"><span class="cm">  (e.g. calloc from _dl_relocate_object) that uses TLS data.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 动态链接器作为共享库有一个显式引用。使用用户控制的符号定义重新定位自己。
</span></span></span><span class="line"><span class="cl"><span class="cm">  我们必须在 TLS 初始化之后执行此操作，以防在此重新定位之后，我们可能会调用用户提供的函数
</span></span></span><span class="line"><span class="cl"><span class="cm">  （例如，_dl_relocate_object 中的 calloc）使用 TLS 数据。 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Set up the object lookup structures.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 设置对象查找结构。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_find_object_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* The malloc implementation has been relocated, so resolving
</span></span></span><span class="line"><span class="cl"><span class="cm">  its symbols (and potentially calling IFUNC resolvers) is safe
</span></span></span><span class="line"><span class="cl"><span class="cm">  at this point.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* malloc 实现已被重定位，因此在此时解析其符号（并潜在地调用 IFUNC 解析器）是安全的。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__rtld_malloc_init_real</span><span class="p">(</span><span class="n">main_map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Likewise for the locking implementation.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 同样适用于锁定实现。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__rtld_mutex_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">RTLD_TIMING_VAR</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Mark the link map as not yet relocated again.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 将链接映射标记为尚未重新定位。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">).</span><span class="n">l_relocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_relocate_object</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_rtld_map</span><span class="p">),</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_scope</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">rtld_timer_accum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">relocate_time</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Relocation is complete.  Perform early libc initialization.  This
</span></span></span><span class="line"><span class="cl"><span class="cm">  is the initial libc, even if audit modules have been loaded with
</span></span></span><span class="line"><span class="cl"><span class="cm">  other libcs.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 重定位完成。执行 libc 早期初始化。这是初始 libc，即使已经使用其他 libc 加载了审核模块。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_call_libc_early_init</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">LM_ID_BASE</span><span class="p">].</span><span class="n">libc_map</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Do any necessary cleanups for the startup OS interface code.
</span></span></span><span class="line"><span class="cl"><span class="cm">  We do these now so that no calls are made after rtld re-relocation
</span></span></span><span class="line"><span class="cl"><span class="cm">  which might be resolved to different functions than we expect.
</span></span></span><span class="line"><span class="cl"><span class="cm">  We cannot do this before relocating the other objects because
</span></span></span><span class="line"><span class="cl"><span class="cm">  _dl_relocate_object might need to call `mprotect&#39; for DT_TEXTREL.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 对启动 OS 接口代码进行任何必要的清理。我们现在这样做是为了在 rtld 重新定位之后不进行任何调用，
</span></span></span><span class="line"><span class="cl"><span class="cm">  因为这些调用可能会解析为与我们期望的不同的函数。我们不能在重定位其他对象之前这样做，
</span></span></span><span class="line"><span class="cl"><span class="cm">  因为 _dl_relocate_object 可能需要为 DT_TEXTREL 调用 `mprotect&#39;。 */</span>
</span></span><span class="line"><span class="cl"><span class="nf">_dl_sysdep_start_cleanup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Notify the debugger all new objects are now ready to go.  We must re-get
</span></span></span><span class="line"><span class="cl"><span class="cm">    the address since by now the variable might be in another object.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 通知调试器所有新对象现在都准备就绪。我们必须重新获取地址，因为现在该变量可能在另一个对象中。 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">r</span> <span class="o">=</span> <span class="nf">_dl_debug_update</span><span class="p">(</span><span class="n">LM_ID_BASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_state</span> <span class="o">=</span> <span class="n">RT_CONSISTENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_debug_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">LIBC_PROBE</span><span class="p">(</span><span class="n">init_complete</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">LM_ID_BASE</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if defined USE_LDCONFIG &amp;&amp; !defined MAP_COPY
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* We must munmap() the cache file.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 我们必须 munmap() 缓存文件。 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">_dl_unload_cache</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Once we return, _dl_sysdep_start will invoke
</span></span></span><span class="line"><span class="cl"><span class="cm">  the DT_INIT functions and then *USER_ENTRY.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 一旦我们返回，_dl_sysdep_start 将调用 DT_INIT 函数，然后 *USER_ENTRY。 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>最后就是运行 libc 的一些早期初始化函数、清理痕迹、释放内存等</li>
<li>至此启动阶段告一段落</li>
</ul>
<h3 id="_dl_init">_dl_init</h3>
<p>在<code>_start</code>中，调用完<code>_dl_start</code>后就轮到这个函数了，它主要负责一些初始化操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">_dl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">main_map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">env</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// main_map 是指向主程序的 link_map 结构体的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">)</span> <span class="o">*</span><span class="n">preinit_array</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_PREINIT_ARRAY</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">)</span> <span class="o">*</span><span class="n">preinit_array_size</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_PREINIT_ARRAYSZ</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果存在全局初始化函数 GL(dl_initfirst)，则调用该函数并将其设为 NULL。这是为了在启动时执行全局初始化函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_initfirst</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>   <span class="c1">// 如果存在全局初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call_init</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_initfirst</span><span class="p">),</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>   <span class="c1">// 调用全局初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">GL</span><span class="p">(</span><span class="n">dl_initfirst</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Don&#39;t do anything if there is no preinit array.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果存在预初始化数组 preinit_array，则按照数组中的顺序调用其中的初始化函数。
</span></span></span><span class="line"><span class="cl"><span class="cm">  这些函数在动态链接器启动过程中执行，用于执行一些必要的初始化工作 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__builtin_expect</span><span class="p">(</span><span class="n">preinit_array</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">preinit_array_size</span> <span class="o">!=</span> <span class="nb">NULL</span>  <span class="c1">// 如果存在预初始化数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">preinit_array_size</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">// 遍历预初始化数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span> <span class="n">addrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_debug_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DL_DEBUG_IMPCALLS</span><span class="p">))</span>  <span class="c1">// 如果设置了 DL_DEBUG_IMPCALLS 标志，则打印调试信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">_dl_debug_printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">calling preinit: %s</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nf">DSO_FILENAME</span><span class="p">(</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addrs</span> <span class="o">=</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span><span class="p">)(</span><span class="n">preinit_array</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span> <span class="o">+</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_addr</span><span class="p">);</span> <span class="c1">// 获取预初始化数组的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">((</span><span class="kt">dl_init_t</span><span class="p">)</span><span class="n">addrs</span><span class="p">[</span><span class="n">cnt</span><span class="p">])(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>   <span class="c1">// 遍历函数指针数组，调用其中的初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Stupid users forced the ELF specification to be changed.  It now
</span></span></span><span class="line"><span class="cl"><span class="cm">    says that the dynamic loader is responsible for determining the
</span></span></span><span class="line"><span class="cl"><span class="cm">    order in which the constructors have to run.  The constructors
</span></span></span><span class="line"><span class="cl"><span class="cm">    for all dependencies of an object must run before the constructor
</span></span></span><span class="line"><span class="cl"><span class="cm">    for the object itself.  Circular dependencies are left unspecified.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    This is highly questionable since it puts the burden on the dynamic
</span></span></span><span class="line"><span class="cl"><span class="cm">    loader which has to find the dependencies at runtime instead of
</span></span></span><span class="line"><span class="cl"><span class="cm">    letting the user do it right.  Stupidity rules!  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 愚蠢的用户迫使 ELF 规范被修改。现在规范中说动态加载器负责确定构造函数的运行顺序。
</span></span></span><span class="line"><span class="cl"><span class="cm">    对象的所有依赖项的构造函数必须在对象本身的构造函数之前运行。循环依赖未指定。
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    这是非常可疑的，因为它将负担放在了动态加载器上，动态加载器必须在运行时找到依赖项，
</span></span></span><span class="line"><span class="cl"><span class="cm">    而不是让用户做正确的事情。愚蠢的规则！ */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">i</span> <span class="o">=</span> <span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_searchlist</span><span class="p">.</span><span class="n">r_nlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call_init</span><span class="p">(</span><span class="n">main_map</span><span class="o">-&gt;</span><span class="n">l_initfini</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef HAVE_INLINED_SYSCALLS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* Finished starting up.  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置全局变量 GL(dl_starting_up) 为 0，表示动态链接器已经启动完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 此后若有新的动态链接库被加载，就不会再调用 _dl_init 函数了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_dl_starting_up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>主要是调用全局构造函数（初始化函数）和一系列构造函数，这里不关心</li>
</ul>
<h3 id="_dl_fini">_dl_fini</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Type of the constructor functions.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 构造函数的类型。 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="kt">fini_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">_dl_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Lots of fun ahead.  We have to call the destructors for all still
</span></span></span><span class="line"><span class="cl"><span class="cm">     loaded objects, in all namespaces.  The problem is that the ELF
</span></span></span><span class="line"><span class="cl"><span class="cm">     specification now demands that dependencies between the modules
</span></span></span><span class="line"><span class="cl"><span class="cm">     are taken into account.  I.e., the destructor for a module is
</span></span></span><span class="line"><span class="cl"><span class="cm">     called before the ones for any of its dependencies.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">     To make things more complicated, we cannot simply use the reverse
</span></span></span><span class="line"><span class="cl"><span class="cm">     order of the constructors.  Since the user might have loaded objects
</span></span></span><span class="line"><span class="cl"><span class="cm">     using `dlopen&#39; there are possibly several other modules with its
</span></span></span><span class="line"><span class="cl"><span class="cm">     dependencies to be taken into account.  Therefore we have to start
</span></span></span><span class="line"><span class="cl"><span class="cm">     determining the order of the modules once again from the beginning.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 我们必须在所有命名空间中调用所有仍然加载的对象的析构函数。
</span></span></span><span class="line"><span class="cl"><span class="cm">     问题是 ELF 规范现在要求考虑模块之间的依赖关系。
</span></span></span><span class="line"><span class="cl"><span class="cm">     也就是说，模块的析构函数在其任何依赖项的析构函数之前被调用。
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">     为了使事情更加复杂，我们不能简单地使用构造函数的反向顺序。
</span></span></span><span class="line"><span class="cl"><span class="cm">     由于用户可能使用 `dlopen&#39; 加载对象，因此可能有几个其他模块及其依赖项需要考虑。
</span></span></span><span class="line"><span class="cl"><span class="cm">     因此，我们必须从头开始再次确定模块的顺序。 */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* We run the destructors of the main namespaces last.  As for the
</span></span></span><span class="line"><span class="cl"><span class="cm">     other namespaces, we pick run the destructors in them in reverse
</span></span></span><span class="line"><span class="cl"><span class="cm">     order of the namespace ID.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 我们最后运行主命名空间的析构函数。至于其他命名空间，我们选择以命名空间 ID 的反向顺序运行其中的析构函数。 */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">int</span> <span class="n">do_audit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">again</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">Lmid_t</span> <span class="n">ns</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_nns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">ns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Protect against concurrent loads and unloads.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 防止并发加载和卸载。 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__rtld_lock_lock_recursive</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_load_lock</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nloaded</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">ns</span><span class="p">].</span><span class="n">_ns_nloaded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* No need to do anything for empty namespaces or those used for
</span></span></span><span class="line"><span class="cl"><span class="cm">    auditing DSOs.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 对于空命名空间或用于审核 DSO 的命名空间，无需执行任何操作。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nloaded</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">__rtld_lock_unlock_recursive</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_load_lock</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Now we can allocate an array to hold all the pointers and
</span></span></span><span class="line"><span class="cl"><span class="cm">         copy the pointers in.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 现在我们可以分配一个数组来保存所有指针并将指针复制到其中。 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">maps</span><span class="p">[</span><span class="n">nloaded</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">assert</span><span class="p">(</span><span class="n">nloaded</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">ns</span><span class="p">].</span><span class="n">_ns_loaded</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="nf">GL</span><span class="p">(</span><span class="n">dl_ns</span><span class="p">)[</span><span class="n">ns</span><span class="p">].</span><span class="n">_ns_loaded</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Do not handle ld.so in secondary namespaces.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 不要在次要命名空间中处理 ld.so。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_real</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nf">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloaded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="cm">/* Bump l_direct_opencount of all objects so that they
</span></span></span><span class="line"><span class="cl"><span class="cm">             are not dlclose()ed from underneath us.  */</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* 增加所有对象的 l_direct_opencount，以便它们不会从我们下面的 dlclose()。 */</span>
</span></span><span class="line"><span class="cl">          <span class="o">++</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_direct_opencount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">assert</span><span class="p">(</span><span class="n">ns</span> <span class="o">!=</span> <span class="n">LM_ID_BASE</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nloaded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">assert</span><span class="p">(</span><span class="n">ns</span> <span class="o">==</span> <span class="n">LM_ID_BASE</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nloaded</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nloaded</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nmaps</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* Now we have to do the sorting.  We can skip looking for the
</span></span></span><span class="line"><span class="cl"><span class="cm">         binary itself which is at the front of the search list for
</span></span></span><span class="line"><span class="cl"><span class="cm">         the main namespace.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 现在我们必须进行排序。我们可以跳过查找二进制文件本身，它位于主命名空间的搜索列表的前面。 */</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_dl_sort_maps</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">nmaps</span><span class="p">,</span> <span class="p">(</span><span class="n">ns</span> <span class="o">==</span> <span class="n">LM_ID_BASE</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* We do not rely on the linked list of loaded object anymore
</span></span></span><span class="line"><span class="cl"><span class="cm">         from this point on.  We have our own list here (maps).  The
</span></span></span><span class="line"><span class="cl"><span class="cm">         various members of this list cannot vanish since the open
</span></span></span><span class="line"><span class="cl"><span class="cm">         count is too high and will be decremented in this loop.  So
</span></span></span><span class="line"><span class="cl"><span class="cm">         we release the lock so that some code which might be called
</span></span></span><span class="line"><span class="cl"><span class="cm">         from a destructor can directly or indirectly access the
</span></span></span><span class="line"><span class="cl"><span class="cm">         lock.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 从这一点开始，我们不再依赖于已加载对象的链接列表。我们在这里有自己的列表（maps）。
</span></span></span><span class="line"><span class="cl"><span class="cm">         该列表的各个成员不能消失，因为打开计数太高，并且将在此循环中递减。
</span></span></span><span class="line"><span class="cl"><span class="cm">         因此，我们释放锁，以便某些可能从析构函数调用的代码可以直接或间接地访问锁。 */</span>
</span></span><span class="line"><span class="cl">      <span class="nf">__rtld_lock_unlock_recursive</span><span class="p">(</span><span class="nf">GL</span><span class="p">(</span><span class="n">dl_load_lock</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* &#39;maps&#39; now contains the objects in the right order.  Now
</span></span></span><span class="line"><span class="cl"><span class="cm">         call the destructors.  We have to process this array from
</span></span></span><span class="line"><span class="cl"><span class="cm">         the front.  */</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* &#39;maps&#39; 现在包含正确顺序的对象。现在调用析构函数。我们必须从前面处理此数组。 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmaps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_init_called</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* Make sure nothing happens if we are called twice.  */</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* 确保我们被调用两次时不会发生任何事情。 */</span>
</span></span><span class="line"><span class="cl">          <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_init_called</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="cm">/* Is there a destructor function?  */</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* 有析构函数吗？ */</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="p">(</span><span class="n">ELF_INITFINI</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* When debugging print a message first.  */</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 调试时先打印一条消息。 */</span>
</span></span><span class="line"><span class="cl">            <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* First see whether an array is given.  */</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 首先看看是否给出了一个数组。 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span><span class="p">)(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAYSZ</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">              <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">((</span><span class="kt">fini_t</span><span class="p">)</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* Next try the old-style destructor.  */</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 接下来尝试旧式析构函数。 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ELF_INITFINI</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="nf">DL_CALL_DT_FINI</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>          <span class="cm">/* Auditing checkpoint: another object closed.  */</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* 审计检查点：另一个对象关闭。 */</span>
</span></span><span class="line"><span class="cl">          <span class="nf">_dl_audit_objclose</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Correct the previous increment.  */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 纠正先前的增量。 */</span>
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_direct_opencount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="nf">_dl_audit_activity_nsid</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">LA_ACT_CONSISTENT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_audit</span> <span class="o">&amp;&amp;</span> <span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_naudit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_audit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>这段代码大概是按依赖关系排序并调用动态链接库的析构函数，虽然出现在 _start 中但不会在 ld.so 启动阶段调用，可以不用关心
<ul>
<li>首先通过迭代命名空间来卸载共享库。命名空间是一种隔离的上下文，用于加载共享库。代码从命名空间的最高ID（<code>GL(dl_nns) - 1</code>）开始向 0 遍历。对于每个命名空间，它执行以下操作：
<ul>
<li>获取命名空间中已加载共享库的数量 <code>nloaded</code></li>
<li>如果命名空间为空（<code>nloaded == 0</code>）或者用于审核 DSO（动态共享对象），则跳过处理</li>
<li>否则创建一个数组 <code>maps</code> 用于保存已加载共享库的指针，并将这些指针复制到数组中</li>
</ul>
</li>
<li>在获得了已加载共享库的数组后对这些库进行排序，以确保按正确的顺序调用析构函数。排序规则会考虑到共享库之间的依赖关系</li>
<li>排序完成后，按照顺序依次调用已加载共享库的析构函数。它首先检查是否存在析构函数（<code>DT_FINI_ARRAY</code> 和 <code>DT_FINI</code>），如果存在，则调用相应的析构函数</li>
</ul>
</li>
</ul>
<h2 id="ldso-延迟绑定">ld.so 延迟绑定</h2>
<p>本节讲解 Linux 下的延迟绑定机制及相关源码</p>
<h2 id="延迟绑定机制">延迟绑定机制</h2>
<p>借用网上的两张图，个人认为将流程展示得非常清晰</p>
<p><img alt="ret2-dl-runtime-resolve-1" src="./img/ret2-dl-runtime-resolve-1.png"></p>
<p><img alt="ret2-dl-runtime-resolve-2" src="./img/ret2-dl-runtime-resolve-2.png"></p>
<p>基本流程如下</p>
<ul>
<li>ld.so 在加载 ELF 时会先在<code>.got.plt</code>的前两项中写入 ELF 的<code>link_map</code>以及<code>_dl_runtime_resolve</code>的地址</li>
<li>在程序首次调用外部函数时，首先跳到<code>.plt</code>中的地址</li>
<li><code>.plt</code>中有<code>jmp</code>指令跳转到<code>.got.plt</code>表中对应偏移位置记载的地址，对于第一次调用函数，这里存储的地址就是<code>jmp</code>指令的下一条指令，也就是图中的<code>push 0</code>（这个 0 其实就是个偏移量，对应函数在重定位表<code>.rela.plt</code>中函数的序号），这里<code>push</code>的数字就作为<code>_dl_runtime_resolve</code>的参数<code>reloc_offset</code>了</li>
<li>跳转回去<code>.plt</code>中的<code>push</code>，之后继续<code>jmp</code>到<code>.plt</code>中的一个固定地址中，<code>push</code>进<code>link_map</code>的地址，作为<code>_dl_runtime_resolve</code>的另一个参数</li>
<li>然后<code>jmp</code>到<code>_dl_runtime_resolve</code>开始执行延迟绑定</li>
</ul>
<h2 id="相关函数-1">相关函数</h2>
<h3 id="_dl_runtime_resolve">_dl_runtime_resolve</h3>
<p><code>dl_runtime_resolve</code>是一段汇编代码，位于<code>sysdeps/x86_64/dl-trampoline.h</code>中。由于指令级架构的原因这里的代码汇编混杂了各种预处理命令，所以这里放出简化的版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">  <span class="na">.text</span>
</span></span><span class="line"><span class="cl">  <span class="na">.globl</span> <span class="no">_dl_runtime_resolve</span>
</span></span><span class="line"><span class="cl">  <span class="na">.type</span> <span class="no">_dl_runtime_resolve</span><span class="p">,</span> <span class="na">@function</span>
</span></span><span class="line"><span class="cl">  <span class="na">.align</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cfi_startproc</span>
</span></span><span class="line"><span class="cl"><span class="nl">_dl_runtime_resolve:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cfi_adjust_cfa_offset</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">  <span class="no">subq</span> <span class="no">$56</span><span class="p">,</span><span class="nv">%rsp</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cfi_adjust_cfa_offset</span><span class="p">(</span><span class="mi">56</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%r8</span><span class="p">,</span> <span class="mi">40</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%r9</span><span class="p">,</span> <span class="mi">48</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">64</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rsi</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">56</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdi</span> 
</span></span><span class="line"><span class="cl">  <span class="no">call</span> <span class="no">_dl_fixup</span> 
</span></span><span class="line"><span class="cl">  <span class="no">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%r11</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">48</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r9</span>  
</span></span><span class="line"><span class="cl">  <span class="no">movq</span> <span class="mi">40</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r8</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">32</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdi</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">24</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rsi</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">16</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rcx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
</span></span><span class="line"><span class="cl">  <span class="nf">addq</span> <span class="no">$72</span><span class="p">,</span> <span class="nv">%rsp</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cfi_adjust_cfa_offset</span><span class="p">(-</span><span class="mi">72</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">jmp</span> <span class="p">*</span><span class="nv">%r11</span>  <span class="c1"># Jump to function address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">cfi_endproc</span>
</span></span><span class="line"><span class="cl">  <span class="na">.size</span> <span class="no">_dl_runtime_resolve</span><span class="p">,</span> <span class="no">.-_dl_runtime_resolve</span>
</span></span></code></pre></div><ul>
<li><code>cfi</code>开头的指令和函数检测有关，即 GNU Profiler，这里不关心</li>
<li><code>_dl_runtime_resolve</code>函数的这段汇编代码就是保存寄存器的值到栈中，然后调用<code>_dl_fixup</code>执行具体的功能，最后从栈中恢复寄存器</li>
<li><code>_dl_fixup</code>函数传入的两个参数一个是<code>rdi</code>寄存器中存储的<code>link_map</code>，<code>rsi</code>是 GOT 表中关于 PLT 重定位的索引值，后面要根据该索引值写入新的地址</li>
</ul>
<h3 id="_dl_fixup">_dl_fixup</h3>
<p>鸽了（骄傲）</p>
<p>（存疑）这里的<code>link_map</code>结构体与之前加载时提到的那个似乎不一样，其位于<code>elf/link.h</code>，定义如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">link_map</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* These first few members are part of the protocol with the debugger.
</span></span></span><span class="line"><span class="cl"><span class="cm">  This is the same format used in SVR4.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这几个成员是与调试器的协议的一部分。这是SVR4中使用的相同格式。 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_addr</span><span class="p">;</span>  <span class="cm">/* Difference between the address in the ELF file and the addresses in memory.  */</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ELF文件中的地址与内存中的地址之间的差异。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="o">*</span><span class="n">l_name</span><span class="p">;</span>    <span class="cm">/* Absolute file name object was found in.  */</span>  <span class="c1">// 找到对象的绝对文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">)</span> <span class="o">*</span><span class="n">l_ld</span><span class="p">;</span>    <span class="cm">/* Dynamic section of the shared object.  */</span>  <span class="c1">// 共享对象的动态部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l_next</span><span class="p">,</span> <span class="o">*</span><span class="n">l_prev</span><span class="p">;</span> <span class="cm">/* Chain of loaded objects.  */</span> <span class="c1">// 加载对象的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h2 id="结构体">结构体</h2>
<p>以下是前面笔记中提到的重要的结构体，篇幅所限故放到最后避免影响阅读</p>
<h3 id="ehdrphdr">Ehdr、Phdr</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span>  <span class="cm">/* Magic number and other info */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_type</span><span class="p">;</span>        <span class="cm">/* Object file type */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_machine</span><span class="p">;</span>      <span class="cm">/* Architecture */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Word</span>  <span class="n">e_version</span><span class="p">;</span>      <span class="cm">/* Object file version */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Addr</span>  <span class="n">e_entry</span><span class="p">;</span>      <span class="cm">/* Entry point virtual address */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Off</span>  <span class="n">e_phoff</span><span class="p">;</span>      <span class="cm">/* Program header table file offset */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Off</span>  <span class="n">e_shoff</span><span class="p">;</span>      <span class="cm">/* Section header table file offset */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Word</span>  <span class="n">e_flags</span><span class="p">;</span>      <span class="cm">/* Processor-specific flags */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_ehsize</span><span class="p">;</span>      <span class="cm">/* ELF header size in bytes */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_phentsize</span><span class="p">;</span>    <span class="cm">/* Program header table entry size */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_phnum</span><span class="p">;</span>      <span class="cm">/* Program header table entry count */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_shentsize</span><span class="p">;</span>    <span class="cm">/* Section header table entry size */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_shnum</span><span class="p">;</span>      <span class="cm">/* Section header table entry count */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Half</span>  <span class="n">e_shstrndx</span><span class="p">;</span>      <span class="cm">/* Section header string table index */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Elf64_Ehdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Word</span>  <span class="n">p_type</span><span class="p">;</span>      <span class="cm">/* Segment type */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Word</span>  <span class="n">p_flags</span><span class="p">;</span>    <span class="cm">/* Segment flags */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Off</span>  <span class="n">p_offset</span><span class="p">;</span>    <span class="cm">/* Segment file offset */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Addr</span>  <span class="n">p_vaddr</span><span class="p">;</span>    <span class="cm">/* Segment virtual address */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Addr</span>  <span class="n">p_paddr</span><span class="p">;</span>    <span class="cm">/* Segment physical address */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Xword</span>  <span class="n">p_filesz</span><span class="p">;</span>    <span class="cm">/* Segment size in file */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Xword</span>  <span class="n">p_memsz</span><span class="p">;</span>    <span class="cm">/* Segment size in memory */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Xword</span>  <span class="n">p_align</span><span class="p">;</span>    <span class="cm">/* Segment alignment */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Elf64_Phdr</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Ehdr 对应于 elf 的文件头，Phdr 对应于 elf 格式的程序头</li>
</ul>
<h3 id="link_map">link_map</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Structure describing a loaded shared object.  The `l_next&#39; and `l_prev&#39;
</span></span></span><span class="line"><span class="cl"><span class="cm">   members form a chain of all the shared objects loaded at startup.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">   These data structures exist in space used by the run-time dynamic linker;
</span></span></span><span class="line"><span class="cl"><span class="cm">   modifying them may have disastrous results.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">   This data structure might change in future, if necessary.  User-level
</span></span></span><span class="line"><span class="cl"><span class="cm">   programs must avoid defining objects of this type.  */</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 描述已加载的共享对象的结构。l_next和l_prev成员形成启动时加载的所有共享对象的链。
</span></span></span><span class="line"><span class="cl"><span class="cm">   这些数据结构存在于运行时动态链接器使用的空间中；修改它们可能会产生灾难性的结果。
</span></span></span><span class="line"><span class="cl"><span class="cm">   如果需要，此数据结构可能会在将来发生变化。用户级程序必须避免定义此类型的对象。*/</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">link_map</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* These first few members are part of the protocol with the debugger.
</span></span></span><span class="line"><span class="cl"><span class="cm">    This is the same format used in SVR4.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这个结构体的前几个成员是与调试器的协议的一部分。这是在SVR4中使用的相同格式。*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_addr</span><span class="p">;</span>        <span class="cm">/* Difference between the address in the ELF   // ELF文件中的地址与内存中的地址的差值
</span></span></span><span class="line"><span class="cl"><span class="cm">                    file and the addresses in memory.  */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">l_name</span><span class="p">;</span>          <span class="cm">/* Absolute file name object was found in.  */</span> <span class="c1">// 被找到的对象的绝对文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">)</span> <span class="o">*</span> <span class="n">l_ld</span><span class="p">;</span>        <span class="cm">/* Dynamic section of the shared object.  */</span>   <span class="c1">// 共享对象的动态段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l_next</span><span class="p">,</span> <span class="o">*</span><span class="n">l_prev</span><span class="p">;</span> <span class="cm">/* Chain of loaded objects.  */</span>  <span class="c1">// 已加载对象的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* All following members are internal to the dynamic linker.
</span></span></span><span class="line"><span class="cl"><span class="cm">    They may change without notice.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 以下所有成员都是动态链接器内部的。
</span></span></span><span class="line"><span class="cl"><span class="cm">    他们可能会在没有通知的情况下改变。*/</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* This is an element which is only ever different from a pointer to
</span></span></span><span class="line"><span class="cl"><span class="cm">    the very same copy of this type for ld.so when it is used in more
</span></span></span><span class="line"><span class="cl"><span class="cm">    than one namespace.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这是一个元素，它与ld.so的指针只有在它在多个命名空间中使用时才会与此类型的完全相同的副本不同。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l_real</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Number of the namespace this link map belongs to.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 此链接映射所属的命名空间的编号。*/</span>
</span></span><span class="line"><span class="cl">  <span class="n">Lmid_t</span> <span class="n">l_ns</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">libname_list</span> <span class="o">*</span><span class="n">l_libname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Indexed pointers to dynamic section.   // 动态段的索引指针
</span></span></span><span class="line"><span class="cl"><span class="cm">    [0,DT_NUM) are indexed by the processor-independent tags.
</span></span></span><span class="line"><span class="cl"><span class="cm">    [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.
</span></span></span><span class="line"><span class="cl"><span class="cm">    [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are
</span></span></span><span class="line"><span class="cl"><span class="cm">    indexed by DT_VERSIONTAGIDX(tagvalue).
</span></span></span><span class="line"><span class="cl"><span class="cm">    [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,
</span></span></span><span class="line"><span class="cl"><span class="cm">  DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by
</span></span></span><span class="line"><span class="cl"><span class="cm">    DT_EXTRATAGIDX(tagvalue).
</span></span></span><span class="line"><span class="cl"><span class="cm">    [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,
</span></span></span><span class="line"><span class="cl"><span class="cm">  DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are
</span></span></span><span class="line"><span class="cl"><span class="cm">    indexed by DT_VALTAGIDX(tagvalue) and
</span></span></span><span class="line"><span class="cl"><span class="cm">    [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,
</span></span></span><span class="line"><span class="cl"><span class="cm">  DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)
</span></span></span><span class="line"><span class="cl"><span class="cm">    are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Dyn</span><span class="p">)</span> <span class="o">*</span> <span class="n">l_info</span><span class="p">[</span><span class="n">DT_NUM</span> <span class="o">+</span> <span class="n">DT_THISPROCNUM</span> <span class="o">+</span> <span class="n">DT_VERSIONTAGNUM</span> <span class="o">+</span> <span class="n">DT_EXTRANUM</span> <span class="o">+</span> <span class="n">DT_VALNUM</span> <span class="o">+</span> <span class="n">DT_ADDRNUM</span><span class="p">];</span>   <span class="c1">// 动态段的索引指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">l_phdr</span><span class="p">;</span> <span class="cm">/* Pointer to program header table in core.  */</span> <span class="c1">// 指向内核中程序头表的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_entry</span><span class="p">;</span>    <span class="cm">/* Entry point location.  */</span>  <span class="c1">// 入口点位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Half</span><span class="p">)</span> <span class="n">l_phnum</span><span class="p">;</span>    <span class="cm">/* Number of program header entries.  */</span>  <span class="c1">// 程序头表条目数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Half</span><span class="p">)</span> <span class="n">l_ldnum</span><span class="p">;</span>    <span class="cm">/* Number of dynamic segment entries.  */</span>   <span class="c1">// 动态段条目数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Array of DT_NEEDED dependencies and their dependencies, in
</span></span></span><span class="line"><span class="cl"><span class="cm">    dependency order for symbol lookup (with and without
</span></span></span><span class="line"><span class="cl"><span class="cm">    duplicates).  There is no entry before the dependencies have
</span></span></span><span class="line"><span class="cl"><span class="cm">    been loaded.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* DT_NEEDED依赖项及其依赖项的数组，按依赖项顺序进行符号查找（有和没有重复项）。
</span></span></span><span class="line"><span class="cl"><span class="cm">    在依赖项加载之前没有条目。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_scope_elem</span> <span class="n">l_searchlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* We need a special searchlist to process objects marked with
</span></span></span><span class="line"><span class="cl"><span class="cm">    DT_SYMBOLIC.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 我们需要一个特殊的searchlist来处理标记为DT_SYMBOLIC的对象。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_scope_elem</span> <span class="n">l_symbolic_searchlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Dependent object that first caused this object to be loaded.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 第一个导致加载此对象的依赖对象。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l_loader</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Array with version names.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 版本名称数组。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_found_version</span> <span class="o">*</span><span class="n">l_versions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l_nversions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Symbol hash table.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 符号哈希表。*/</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf_Symndx</span> <span class="n">l_nbuckets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf32_Word</span> <span class="n">l_gnu_bitmask_idxbits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf32_Word</span> <span class="n">l_gnu_shift</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span> <span class="n">l_gnu_bitmask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Elf32_Word</span> <span class="o">*</span><span class="n">l_gnu_buckets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Elf_Symndx</span> <span class="o">*</span><span class="n">l_chain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Elf32_Word</span> <span class="o">*</span><span class="n">l_gnu_chain_zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Elf_Symndx</span> <span class="o">*</span><span class="n">l_buckets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l_direct_opencount</span><span class="p">;</span> <span class="cm">/* Reference count for dlopen/dlclose. */</span>  <span class="c1">// dlopen/dlclose的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">enum</span>               <span class="cm">/* Where this object came from. */</span>  <span class="c1">// 这个对象来自哪里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lt_executable</span><span class="p">,</span>   <span class="cm">/* The main executable program. */</span>      <span class="c1">// 主可执行程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lt_library</span><span class="p">,</span>    <span class="cm">/* Library needed by main executable. */</span>    <span class="c1">// 主可执行程序所需的库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lt_loaded</span>    <span class="cm">/* Extra run-time loaded shared object. */</span>   <span class="c1">// 额外的运行时加载的共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="nl">l_type</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_relocated</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if object&#39;s relocations done. */</span>  <span class="c1">// 如果对象的重定位完成，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_init_called</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if DT_INIT function called. */</span>  <span class="c1">// 如果调用了DT_INIT函数，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_global</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Nonzero if object in _dl_global_scope. */</span> <span class="c1">// 如果对象在_dl_global_scope中，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_reserved</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* Reserved for internal use. */</span>  <span class="c1">// 保留供内部使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_main_map</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero for the map of the main program. */</span>  <span class="c1">// 主程序的映射为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_visited</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Used internally for map dependency
</span></span></span><span class="line"><span class="cl"><span class="cm">                    graph traversal. */</span>  <span class="c1">// 用于映射依赖图遍历的内部使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_map_used</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* These two bits are used during traversal */</span>   <span class="c1">// 在遍历期间使用这两个位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_map_done</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* of maps in _dl_close_worker. */</span>  <span class="c1">// 在_dl_close_worker中的映射。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_phdr_allocated</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if the data structure pointed
</span></span></span><span class="line"><span class="cl"><span class="cm">                      to by `l_phdr&#39; is allocated. */</span>  <span class="c1">// 如果由“l_phdr”指向的数据结构已分配，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_soname_added</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if the SONAME is for sure in
</span></span></span><span class="line"><span class="cl"><span class="cm">                      the l_libname list. */</span>        <span class="c1">// 如果SONAME肯定在l_libname列表中，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_faked</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Nonzero if this is a faked descriptor
</span></span></span><span class="line"><span class="cl"><span class="cm">                      without associated file. */</span>    <span class="c1">// 如果这是一个没有关联文件的伪描述符，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_need_tls_init</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if GL(dl_init_static_tls)
</span></span></span><span class="line"><span class="cl"><span class="cm">                      should be called on this link map
</span></span></span><span class="line"><span class="cl"><span class="cm">                      when relocation finishes. */</span>    <span class="c1">// 如果在重定位完成时应该在此链接映射上调用GL（dl_init_static_tls），则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_auditing</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Nonzero if the DSO is used in auditing.  */</span>   <span class="c1">// 如果DSO在审计中使用，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_audit_any_plt</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if at least one audit module
</span></span></span><span class="line"><span class="cl"><span class="cm">                      is interested in the PLT interception.*/</span>  <span class="c1">// 如果至少有一个审计模块对PLT拦截感兴趣，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_removed</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Nozero if the object cannot be used anymore
</span></span></span><span class="line"><span class="cl"><span class="cm">                      since it is removed. */</span>  <span class="c1">// 如果对象已被删除，则不再使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_contiguous</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Nonzero if inter-segment holes are
</span></span></span><span class="line"><span class="cl"><span class="cm">                      mprotected or if no holes are present at  // 如果mprotected存在段间空洞或者没有空洞
</span></span></span><span class="line"><span class="cl"><span class="cm">                      all. */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_symbolic_in_local_scope</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Nonzero if l_local_scope
</span></span></span><span class="line"><span class="cl"><span class="cm">                        during LD_TRACE_PRELINKING=1
</span></span></span><span class="line"><span class="cl"><span class="cm">                        contains any DT_SYMBOLIC
</span></span></span><span class="line"><span class="cl"><span class="cm">                        libraries. */</span>  <span class="c1">// 如果l_local_scope在LD_TRACE_PRELINKING=1期间包含任何DT_SYMBOLIC库，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_free_initfini</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Nonzero if l_initfini can be
</span></span></span><span class="line"><span class="cl"><span class="cm">                      freed, ie. not allocated with
</span></span></span><span class="line"><span class="cl"><span class="cm">                      the dummy malloc in ld.so. */</span>  <span class="c1">// 如果l_initfini可以被释放，则为非零，即不是用ld.so中的虚拟malloc分配的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_ld_readonly</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Nonzero if dynamic section is readonly. */</span>   <span class="c1">// 如果动态段是只读的，则为非零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">l_find_object_processed</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Zero if _dl_find_object_update
</span></span></span><span class="line"><span class="cl"><span class="cm">                        needs to process this
</span></span></span><span class="line"><span class="cl"><span class="cm">                        lt_library map. */</span>  <span class="c1">// 如果_dl_find_object_update需要处理此lt_library映射，则为零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* NODELETE status of the map.  Only valid for maps of type
</span></span></span><span class="line"><span class="cl"><span class="cm">    lt_loaded.  Lazy binding sets l_nodelete_active directly,
</span></span></span><span class="line"><span class="cl"><span class="cm">    potentially from signal handlers.  Initial loading of an
</span></span></span><span class="line"><span class="cl"><span class="cm">    DF_1_NODELETE object set l_nodelete_pending.  Relocation may
</span></span></span><span class="line"><span class="cl"><span class="cm">    set l_nodelete_pending as well.  l_nodelete_pending maps are
</span></span></span><span class="line"><span class="cl"><span class="cm">    promoted to l_nodelete_active status in the final stages of
</span></span></span><span class="line"><span class="cl"><span class="cm">    dlopen, prior to calling ELF constructors.  dlclose only
</span></span></span><span class="line"><span class="cl"><span class="cm">    refuses to unload l_nodelete_active maps, the pending status is
</span></span></span><span class="line"><span class="cl"><span class="cm">    ignored.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 映射的NODELETE状态。仅对lt_loaded类型的映射有效。
</span></span></span><span class="line"><span class="cl"><span class="cm">    惰性绑定直接设置l_nodelete_active，可能来自信号处理程序。
</span></span></span><span class="line"><span class="cl"><span class="cm">    初始加载DF_1_NODELETE对象设置l_nodelete_pending。
</span></span></span><span class="line"><span class="cl"><span class="cm">    重定位也可能设置l_nodelete_pending。
</span></span></span><span class="line"><span class="cl"><span class="cm">    l_nodelete_pending映射在dlopen的最后阶段，在调用ELF构造函数之前，被提升为l_nodelete_active状态。
</span></span></span><span class="line"><span class="cl"><span class="cm">    dlclose只拒绝卸载l_nodelete_active映射，忽略挂起状态。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">l_nodelete_active</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">l_nodelete_pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;link_map.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Collected information about own RPATH directories.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 收集有关自己的RPATH目录的信息。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_search_path_struct</span> <span class="n">l_rpath_dirs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Collected results of relocation while profiling.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 在分析过程中收集的重定位结果。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">reloc_result</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DL_FIXUP_VALUE_TYPE</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">bound</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boundndx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">enterexit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* CONCURRENCY NOTE: This is used to guard the concurrent initialization
</span></span></span><span class="line"><span class="cl"><span class="cm">      of the relocation result across multiple threads.  See the more
</span></span></span><span class="line"><span class="cl"><span class="cm">      detailed notes in elf/dl-runtime.c.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 并发注意事项：这用于保护多个线程之间的重定位结果的并发初始化。
</span></span></span><span class="line"><span class="cl"><span class="cm">      请参阅elf/dl-runtime.c中的更详细说明。*/</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="o">*</span><span class="n">l_reloc_result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Pointer to the version information if available.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果可用，则指向版本信息。*/</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Versym</span><span class="p">)</span> <span class="o">*</span> <span class="n">l_versyms</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* String specifying the path where this object was found.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 字符串，指定找到此对象的路径。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">l_origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Start and finish of memory map for this object.  l_map_start
</span></span></span><span class="line"><span class="cl"><span class="cm">    need not be the same as l_addr.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 此对象的内存映射的开始和结束。l_map_start不需要与l_addr相同。*/</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_map_start</span><span class="p">,</span> <span class="n">l_map_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* End of the executable part of the mapping.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 映射的可执行部分的结束。*/</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_text_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Default array for &#39;l_scope&#39;.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* l_scope的默认数组。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_scope_elem</span> <span class="o">*</span><span class="n">l_scope_mem</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Size of array allocated for &#39;l_scope&#39;.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 为“l_scope”分配的数组的大小。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_scope_max</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* This is an array defining the lookup scope for this link map.
</span></span></span><span class="line"><span class="cl"><span class="cm">    There are initially at most three different scope lists.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这是一个数组，定义了此链接映射的查找范围。
</span></span></span><span class="line"><span class="cl"><span class="cm">    最初最多有三个不同的范围列表。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_scope_elem</span> <span class="o">**</span><span class="n">l_scope</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* A similar array, this time only with the local scope.  This is
</span></span></span><span class="line"><span class="cl"><span class="cm">    used occasionally.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 类似的数组，这次只有本地范围。这是偶尔使用的。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_scope_elem</span> <span class="o">*</span><span class="n">l_local_scope</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* This information is kept to check for sure whether a shared
</span></span></span><span class="line"><span class="cl"><span class="cm">    object is the same as one already loaded.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 保留此信息以确保共享对象与已加载的对象相同。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_file_id</span> <span class="n">l_file_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Collected information about own RUNPATH directories.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 收集有关自己的RUNPATH目录的信息。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">r_search_path_struct</span> <span class="n">l_runpath_dirs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* List of object in order of the init and fini calls.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 按init和fini调用顺序列出对象。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">**</span><span class="n">l_initfini</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* List of the dependencies introduced through symbol binding.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 通过符号绑定引入的依赖项列表。*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map_reldeps</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">act</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">list</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="o">*</span><span class="n">l_reldeps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l_reldepsmax</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Nonzero if the DSO is used.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 如果DSO被使用，则为非零。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l_used</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Various flag words.  */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Word</span><span class="p">)</span> <span class="n">l_feature_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Word</span><span class="p">)</span> <span class="n">l_flags_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Word</span><span class="p">)</span> <span class="n">l_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Temporarily used in `dl_close&#39;.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 在“dl_close”中临时使用。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">l_idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">link_map_machine</span> <span class="n">l_mach</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span> <span class="o">*</span> <span class="n">sym</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">type_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="nf">ElfW</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span> <span class="o">*</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">l_lookup_cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Thread-local storage related info.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 与TLS相关的信息。*/</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Start of the initialization image.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 初始化图像的开始。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="n">l_tls_initimage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Size of the initialization image.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 初始化图像的大小。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_initimage_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Size of the TLS block.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* TLS块的大小。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_blocksize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Alignment requirement of the TLS block.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* TLS块的对齐要求。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_align</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Offset of first byte module alignment.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 第一个字节模块对齐的偏移量。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_firstbyte_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef NO_TLS_OFFSET
</span></span></span><span class="line"><span class="cl"><span class="cp">#define NO_TLS_OFFSET 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifndef FORCED_DYNAMIC_TLS_OFFSET
</span></span></span><span class="line"><span class="cl"><span class="cp">#if NO_TLS_OFFSET == 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FORCED_DYNAMIC_TLS_OFFSET -1
</span></span></span><span class="line"><span class="cl"><span class="cp">#elif NO_TLS_OFFSET == -1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FORCED_DYNAMIC_TLS_OFFSET -2
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#error &#34;FORCED_DYNAMIC_TLS_OFFSET is not defined&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cm">/* For objects present at startup time: offset in the static TLS block.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 对于在启动时存在的对象：静态TLS块中的偏移量。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ptrdiff_t</span> <span class="n">l_tls_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Index of the module in the dtv array.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* dtv数组中模块的索引。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_modid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Number of thread_local objects constructed by this DSO.  This is
</span></span></span><span class="line"><span class="cl"><span class="cm">    atomically accessed and modified and is not always protected by the load
</span></span></span><span class="line"><span class="cl"><span class="cm">    lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 此DSO构造的thread_local对象的数量。这是原子访问和修改的，并且并不总是由加载锁保护。
</span></span></span><span class="line"><span class="cl"><span class="cm">    另请参阅：cxa_thread_atexit_impl.c中的并发注意事项。*/</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_tls_dtor_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Information used to change permission after the relocations are
</span></span></span><span class="line"><span class="cl"><span class="cm">    done.  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 在重定位完成后更改权限时使用的信息。*/</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="n">l_relro_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">l_relro_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">l_serial</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dl-relocate-ld.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Information used by audit modules.  For most link maps, this data
</span></span></span><span class="line"><span class="cl"><span class="cm">   immediate follows the link map in memory.  For the dynamic linker,
</span></span></span><span class="line"><span class="cl"><span class="cm">   it is allocated separately.  See link_map_audit_state in
</span></span></span><span class="line"><span class="cl"><span class="cm">   &lt;ldsodefs.h&gt;.  */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">auditstate</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uintptr_t</span> <span class="n">cookie</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bindflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>struct link_map</code> 是在动态链接器（ld.so）中用于管理加载的共享对象（共享库或可执行文件）的数据结构，定义在<code>/include/link.h</code>中。这个结构体非常巨大，所以放在最后</p>
<p>该结构体的定义包含了与调试器协议相关的一些成员以及动态链接器内部使用的成员，一个 <code>link_map</code> 对应一个动态链接库，各个 <code>link_map</code> 之间以链表形式串联。下面是对其中一些关键成员的简要说明：</p>
<ol>
<li><strong>l_addr:</strong>
<ul>
<li>类型：<code>ElfW(Addr)</code></li>
<li>作用：ELF 文件中地址和内存中地址之间的差异</li>
</ul>
</li>
<li><strong>l_name:</strong>
<ul>
<li>类型：<code>char *</code></li>
<li>作用：共享对象的绝对文件路径</li>
</ul>
</li>
<li><strong>l_ld:</strong>
<ul>
<li>类型：<code>ElfW(Dyn) *</code></li>
<li>作用：指向共享对象的动态段</li>
</ul>
</li>
<li><strong>l_next, l_prev:</strong>
<ul>
<li>类型：<code>struct link_map *</code></li>
<li>作用：链表中的下一个和前一个加载的共享对象</li>
</ul>
</li>
<li><strong>l_real:</strong>
<ul>
<li>类型：<code>struct link_map *</code></li>
<li>作用：多个命名空间中使用时，与相同类型的对象指针不同</li>
</ul>
</li>
<li><strong>l_ns:</strong>
<ul>
<li>类型：<code>Lmid_t</code></li>
<li>作用：指定命名空间的编号</li>
</ul>
</li>
<li><strong>l_type:</strong>
<ul>
<li>类型：<code>enum</code></li>
<li>作用：指示对象的类型（可执行文件、库或额外运行时加载的共享对象）</li>
</ul>
</li>
<li><strong>l_relocated:</strong>
<ul>
<li>类型：<code>unsigned int</code></li>
<li>作用：非零表示对象的重定位已完成</li>
</ul>
</li>
<li><strong>l_init_called:</strong>
<ul>
<li>类型：<code>unsigned int</code></li>
<li>作用：非零表示已调用 DT_INIT 函数</li>
</ul>
</li>
<li><strong>l_global:</strong>
<ul>
<li>类型：<code>unsigned int</code></li>
<li>作用：非零表示对象在 <code>_dl_global_scope</code> 中</li>
</ul>
</li>
<li><strong>l_main_map:</strong>
<ul>
<li>类型：<code>unsigned int</code></li>
<li>作用：非零表示这是主程序的映射</li>
</ul>
</li>
<li><strong>l_map_start, l_map_end:</strong>
<ul>
<li>类型：<code>ElfW(Addr)</code></li>
<li>作用：对象在内存中映射的起始和结束地址</li>
</ul>
</li>
<li><strong>l_text_end:</strong>
<ul>
<li>类型：<code>ElfW(Addr)</code></li>
<li>作用：可执行部分的映射结束地址</li>
</ul>
</li>
<li><strong>l_phdr, l_phnum, l_ldnum:</strong>
<ul>
<li>类型：<code>const ElfW(Phdr) *</code>, <code>ElfW(Half)</code>, <code>ElfW(Half)</code></li>
<li>作用：指向程序头表、程序头表的数量和动态段的数量</li>
</ul>
</li>
<li><strong>l_searchlist:</strong>
<ul>
<li>类型：<code>struct r_scope_elem</code></li>
<li>作用：DT_NEEDED 依赖项的链表，按照符号查找的顺序排列</li>
</ul>
</li>
<li><strong>l_symbolic_searchlist:</strong>
<ul>
<li>类型：<code>struct r_scope_elem</code></li>
<li>作用：用于处理标记为 DT_SYMBOLIC 的对象的特殊搜索列表</li>
</ul>
</li>
<li><strong>l_loader:</strong>
<ul>
<li>类型：<code>struct link_map *</code></li>
<li>作用：加载此对象的依赖对象</li>
</ul>
</li>
<li><strong>l_versions, l_nversions:</strong>
<ul>
<li>类型：<code>struct r_found_version *</code>, <code>unsigned int</code></li>
<li>作用：版本信息的数组和数量</li>
</ul>
</li>
<li><strong>l_nbuckets, l_gnu_bitmask_idxbits, l_gnu_shift:</strong>
<ul>
<li>类型：<code>Elf_Symndx</code>, <code>Elf32_Word</code>, <code>Elf32_Word</code></li>
<li>作用：符号哈希表的信息</li>
</ul>
</li>
<li><strong>l_gnu_bitmask, l_gnu_buckets, l_gnu_chain_zero:</strong>
<ul>
<li>类型：<code>const ElfW(Addr) *</code>, <code>const Elf32_Word *</code>, <code>const Elf32_Word *</code></li>
<li>作用：GNU 格式的符号哈希表和链接</li>
</ul>
</li>
<li><strong>l_direct_opencount:</strong>
<ul>
<li>类型：<code>unsigned int</code></li>
<li>作用：用于 dlopen/dlclose 的引用计数</li>
</ul>
</li>
<li><strong>l_lookup_cache:</strong>
<ul>
<li>类型：结构体</li>
<li>作用：符号查找缓存</li>
</ul>
</li>
<li><strong>l_tls_initimage, l_tls_initimage_size, l_tls_blocksize, l_tls_align, l_tls_firstbyte_offset:</strong>
<ul>
<li>类型：<code>void *</code>, <code>size_t</code>, <code>size_t</code>, <code>size_t</code>, <code>size_t</code></li>
<li>作用：与线程局部存储（TLS）相关的初始化图像和属性</li>
</ul>
</li>
<li><strong>l_tls_offset, l_tls_modid, l_tls_dtor_count:</strong>
<ul>
<li>类型：<code>ptrdiff_t</code>, <code>size_t</code>, <code>size_t</code></li>
<li>作用：TLS 相关信息</li>
</ul>
</li>
<li><strong>l_relro_addr, l_relro_size:</strong>
<ul>
<li>类型：<code>ElfW(Addr)</code>, <code>size_t</code></li>
<li>作用：重定位只读段的地址和大小</li>
</ul>
</li>
<li><strong>l_serial:</strong>
<ul>
<li>类型：<code>unsigned long long int</code></li>
<li>作用：对象的序列号</li>
</ul>
</li>
</ol>

            </div>
        </article>





<br>
<script src="https://utteranc.es/client.js"
        repo="ASUKA39/asuka39.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script></main>
</div>
<footer class="footer">
    

    
    
</footer><a href="#" title="Go to top" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    




    
    
        
    

    
    
        
    



    
    <script src="https://asuka39.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js" integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30&#43;lSNuSkl4QXuNyy8="></script>

    

</body>
</html>
